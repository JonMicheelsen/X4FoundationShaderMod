#include <common.h>
#include <ssr_common.h>

#ifdef OUT_R8_UINT
layout(location = 0) out uint OUT_UINT;
#elif defined(OUT_ENVMAP)
layout(location = 0) out vec4 OUT_Color;
layout(location = 1) out vec4 OUT_Color1;
layout(location = 2) out vec4 OUT_Color2;
layout(location = 3) out vec4 OUT_Color3;
layout(location = 4) out vec4 OUT_Color4;
layout(location = 5) out vec4 OUT_Color5;
#elif defined(OUT_1)
layout(location = 0) out vec4 OUT_Color;
#else
layout(location = 0) out vec4 OUT_Color;
layout(location = 1) out vec4 OUT_Color1;
layout(location = 2) out vec4 OUT_Color2;
layout(location = 3) out vec4 OUT_Color3;
#endif


#define DIR in
#include <vertex.h>
#undef DIR

#ifdef GFX_RT_DEBUG
void DebugStore(vec4 col)
{
	imageStore(T_debug, ivec2(gl_FragCoord.xy), col);
}
void DebugStore(vec3 col)
{
	DebugStore(vec4(col, 1));
}

void DebugStore(float val, float alpha)
{
	DebugStore(vec4(-val, val, 0, alpha));
}
void DebugStore(float val)
{
	DebugStore(val, 1);
}
#endif

#define LOCALSPEC

float Luminance()
{
#ifdef PROJECT_XR
	return 0.6f;
#else
	return 1.0f;
#endif
//	return textureLod(T_luminance, vec2(0, 0), 0).x;
}

float LuminanceLast()
{
	return Luminance();
//	return textureLod(T_luminance_last, vec2(0, 0), 0).x;
}

#ifdef GFX_VULKAN
layout(constant_id = 0) const bool B_alpha_test = false;
layout(constant_id = 1) const float F_alpha_ref = 0.5f;
#else
uniform float F_alpha_ref = 0.0f;	//for alpha-testing
#endif

void StandardControlTexture()
{
#ifdef SHADERTAG_CT
	if (texture(S_input_rt, IO_uv0).r < 0.5f) {
		discard;
	}
#endif
}

void AlphaTest(float a)
{
	if (B_alpha_test)
	{
		if (a < F_alpha_ref) {
			discard;
		}
	}/**/
}

void AlwaysAlphaTestWithCoverage(inout float a, float ref)
{
	if (a < ref) {
		discard;
	}
	a = (a - ref) / max(abs(dFdx(a)) + abs(dFdy(a)), FLOAT_SMALL_NUMBER) + 0.5;
}
void AlphaTestWithCoverage(inout float a)
{
	if (B_alpha_test)
	{
		AlwaysAlphaTestWithCoverage(a, F_alpha_ref);
	}
}

#if 0//don't use this it crashes on intel gpus
void Alpha2DepthScale(float a)// when using this preferrably add "layout (depth_less) out float gl_FragDepth;" before include "common.fh"
{
	gl_FragDepth = gl_FragCoord.z * sqrt(saturate(a));
}
#endif

#ifdef D_OBJECT_RENDER_MODE
	#define OBJECTRENDERMODE_SOLID()		\
		{			\
			if (B_alpha_test) {				\
				if (OUT_Color.a >= F_alpha_ref) {	\
					OUT_Color.a = 1.0f;			\
				}			\
			}			\
			else {			\
				OUT_Color.a = 1.0f;		\
			}			\
		}
#else
	#define OBJECTRENDERMODE_SOLID() /* OBJECTRENDERMODE_SOLID() */
#endif


/*void OrthogonalNTB(out vec3 n, out vec3 t, out vec3 b)
{
	n = normalize(IO_normal);//TODO @Timon referencing IO_normal from a function breaks vr_oculus_avatar_pbs naturally
	t = IO_tangent;
	b = IO_binormal;
	t = normalize(t - n * dot(n, t));
	b = normalize(b - n * dot(n, b));
	b = normalize(b - t * dot(t, b));
}*/

#define INPUT_NTB_ONESIDED()			\
	vec3 IO_normal, IO_tangent, IO_binormal;			\
	IO_normal = normalize(_IO_normal);			\
	IO_tangent = normalize(_IO_tangent);			\
	IO_binormal = normalize(_IO_binormal);

#define INPUT_NTB_TWOSIDED()			\
	vec3 IO_normal, IO_tangent, IO_binormal;			\
	IO_normal = normalize(_IO_normal);			\
	IO_tangent = normalize(_IO_tangent);			\
	IO_binormal = normalize(_IO_binormal);		\
	if (gl_FrontFacing) {				\
		IO_normal = -IO_normal;			\
	}

#define CalcWorldNormal(texnormal)	normalize( ((texnormal).x * -IO_tangent) + ((texnormal).y * IO_binormal) + ((texnormal).z * IO_normal) )

#define CalcViewNormalOffset(texnormal)	((mat3(M_view) * ((texnormal).x * -IO_tangent + (texnormal).y * IO_binormal)).xy)

float3 UncompressDXT5_NM(float4 normPacked)
{
	float3 norm = float3(normPacked.a * 2.0 - 1.0, normPacked.g * 2.0 - 1.0, 0.0);
	norm.z = sqrt(1.0 - norm.x * norm.x - norm.y * norm.y);
	return norm;
}

//TODO @Timon further dedup the various variants
vec3 NormalReZ(vec3 texnormal)
{
	texnormal.z = sqrt(1 - saturate(dotself(texnormal.xy)));	//without saturate we'd get NaNs in some textures
	return texnormal;
}

vec2 textureNormalXY(sampler2D samp, vec2 uv)
{
	return SIGNED(texture(samp, uv).xy);
}
vec2 textureNormalXY(sampler2D samp, vec2 uv, float str)
{
	return SIGNED(texture(samp, uv).xy) * str;
}

vec3 textureNormalXYZ(sampler2D samp, vec2 uv)
{
	vec3 ret;
	ret = SIGNED(texture(samp, uv).xyz);
	return ret;
}
vec3 textureNormalXYZ(sampler2D samp, vec2 uv, float str)
{
	vec3 ret;
	ret = SIGNED(texture(samp, uv).xyz);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2D samp, vec2 uv)
{
	vec3 ret;
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2D samp, vec2 uv, float str)
{
	vec3 ret;
#if 0
	// experimental jitter for TAA
	float t = fract(F_time * 10);
	vec2 off = vec2(random(t * gl_FragCoord.xy), random(t * gl_FragCoord.yx));
	// DebugStore(vec3(off, 0));
	off = uv2clip(off);
	off *= 0.5 / textureSize(samp, 0).xy;
//	uv += off;
#endif
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2DArray samp, vec3 uv, float str)
{
	vec3 ret;
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}

vec3 textureNormal(sampler2D samp, vec2 uv, float str)
{
	return textureNormalXYreZ(samp, uv, str);
}
vec3 textureNormal(sampler2DArray samp, vec3 uv, float str)
{
	return textureNormalXYreZ(samp, uv, str);
}
vec3 textureNormal(sampler2D samp, vec2 uv)
{
	return textureNormalXYreZ(samp, uv);
}

#define TEXTURE_NORMAL(name0, uv0)		textureNormal(S_##name0##_map, (uv0) * S_##name0##_tiling, S_##name0##str)
#define TEXTURE_NORMAL_XY(name0, uv0)	textureNormalXY(S_##name0##_map, (uv0) * S_##name0##_tiling, S_##name0##str)


#define SAMPLE_NORMAL_MAP(out, name0, uv0)			\
	{			\
		(out) = IO_normal;			\
		_IF(S_##name0##_bool) {			\
			vec3 texnorm = TEXTURE_NORMAL(name0, (uv0));			\
			(out) = CalcWorldNormal(texnorm);			\
		}			\
	}

#define SAMPLE_NORMAL_MAP2(out, name0, uv0, name1, uv1)			\
	{			\
		(out) = IO_normal;			\
		_IF(S_##name0##_bool) {			\
			vec3 texnorm = TEXTURE_NORMAL(name0, (uv0));			\
			_IF(S_##name1##_bool) {			\
				texnorm.xy += TEXTURE_NORMAL_XY(name1, (uv1));			\
			}			\
			texnorm = normalize(texnorm);				\
			(out) = CalcWorldNormal(texnorm);			\
		}			\
	}

#define STANDARD_NORMAL_MAP(out)			SAMPLE_NORMAL_MAP(out, normal, IO_uv0)
#define STANDARD_NORMAL_DETAIL_MAP(out)		SAMPLE_NORMAL_MAP2(out, normal, IO_uv0, normal_detail, IO_uv0)
#define STANDARD_NORMAL_NOISE_MAP(out)		SAMPLE_NORMAL_MAP2(out, normal, IO_uv0, normal_noise, IO_uv0)

#define STANDARD_NORMAL_DETAIL_MAPUV(out,uv)		SAMPLE_NORMAL_MAP2(out, normal, uv, normal_detail, uv)

vec3 calcWorldNormal(vec3 TexNormal, vec3 Norm, vec3 Tang, vec3 BiNo)
{
	return normalize(TexNormal.x * normalize(-Tang) + TexNormal.y * normalize(BiNo) + TexNormal.z * normalize(Norm));
}

float3 calcWorldNormal2(CONST float3 TexNormal, CONST float3 Norm, CONST float3 Tang, CONST float3 BiNo)
{
	return calcWorldNormal(TexNormal, Norm, Tang, BiNo);
}

half CalcNewViewAngleFading(CONST float3 normalWV, CONST float3 posWV, CONST half AnglePower)
{
	return lerp(0.0, 1.0, saturate((abs(dot(normalWV, normalize(posWV))) - AnglePower)));
}


vec2 GetFragUV()
{
	return gl_FragCoord.xy / V_viewportpixelsize.xy;
}

vec3 GetFragUVZ()
{
	return vec3(GetFragUV(), gl_FragCoord.z);
}

vec3 GetFragClip()
{
	return uv2clipZ(GetFragUVZ());
}

vec3 GetFragView()
{
	return UnProject(GetFragClip());
}

vec3 GetFragViewDir()
{
	return normalize(GetFragView());
}

vec3 GetFragWorld()
{
	return view2world(GetFragView());
}

vec3 GetCheckers(int size)
{
	uvec2 pix = uvec2(gl_FragCoord.xy) / size;
	if (((pix.x + pix.y) & 1) != 0)
		return vec3(0.2);
	return vec3(0.4);
}
vec3 GetCheckers()
{
	return GetCheckers(16);
}

half4 RTResolve(sampler2D samp)
{
	return texelFetch(samp, ivec2(gl_FragCoord.xy), 0);	//TODO should be better, but need to test perf/compat
	
//	float2 uv = float2(inVPos.xy / ViewPort.xy); // use ps3 inputs and set LOD to 0
	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / V_viewportpixelsize.xy;
//	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / textureSize(samp, 0);
//	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / vec2(1024, 768);
	
	//CONST half localoccl = pow(Occl, 1.0/4.0); // scale power up, allow locallight to ignore occl to some degree, but if its very dark still scale down more.
//	return vec4(textureLod(samp, uv, 0).rgb, 0.8f);
//	return textureLod(samp, uv, 0).rgba * vec4(1, 1, 1, 0.5f); 
	return textureLod(samp, uv, 0);
}
half4 RTResolve(sampler2D samp, vec2 uv)
{
#ifndef VIEWPORT_HACK2
	#ifdef UPMODE_FSR
		//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
		#ifdef VIEWPORT_HALF_RES_FSR_HACK
		uv *= 2;
		#endif
		uv *= V_viewportpixelsize.xy / textureSize(samp, 0);
	#endif
#endif
	return textureLod(samp, uv, 0);
}
half4 RTResolveSoft(sampler2D samp)
{
	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / V_viewportpixelsize.xy;
	//float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / textureSize(samp, 0);
	return textureLod(samp, uv, 0);
}
half4 RTResolveSample(sampler2D samp, int idx)
{
	return RTResolve(samp);
}

half4 RTResolve(sampler2DMS samp)
{
#ifdef PER_SAMPLE
	vec4 col = texelFetch(samp, ivec2(gl_FragCoord.xy), gl_SampleID);
#elif defined(MAIN_MSAA)
	vec4 col = texelFetch(samp, ivec2(gl_FragCoord.xy), 0);
/*	for (int i = 1; i < MAIN_MSAA; ++i) {
		col += texelFetch(samp, ivec2(gl_FragCoord.xy), i);
	}
	/**/
/*	#if MAIN_MSAA > 1
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 1);
	#elif MAIN_MSAA > 2
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 2);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 3);
	#elif MAIN_MSAA > 4
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 4);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 5);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 6);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 7);
	#elif MAIN_MSAA > 8
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 8);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 9);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 10);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 11);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 12);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 13);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 14);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 15);
	#else
	#error weird MAIN_MSAA
	#endif
	/**/
// 	col /= vec4(MAIN_MSAA);
//	col = vec4(1, 0, 1, 1);
#else
	vec4 col = vec4(1, 0, 1, 1);
#endif
	return col;
}
half4 RTResolve(sampler2DMS samp, vec2 uv)
{
#ifndef VIEWPORT_HACK2
	#ifdef UPMODE_FSR
		//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
		uv *= V_viewportpixelsize.xy / textureSize(samp);
		#ifdef VIEWPORT_HALF_RES_FSR_HACK
		uv *= 2;
		#endif
	#endif
#endif
// 	uv *= V_viewportpixelsize.xy;
	uv *= textureSize(samp).xy;
#ifdef PER_SAMPLE
	return texelFetch(samp, ivec2(uv), gl_SampleID);
#else
	return texelFetch(samp, ivec2(uv), 0);
#endif
}
half4 RTResolveSample(sampler2DMS samp, int idx)
{
	return texelFetch(samp, ivec2(gl_FragCoord.xy), idx);
}

#define FLAG_COMPLEX_DEPTH (1 << 7)
#define FLAG_COMPLEX_NORMAL (1 << 6)
#define FLAG_STATIONARY (1 << 5)
#define FLAG_BACKGROUND (1 << 4)
#define FLAG_COMPLEX (FLAG_COMPLEX_DEPTH | FLAG_COMPLEX_NORMAL)

bool IsComplex(uint flags)
{
	return (flags & FLAG_COMPLEX) != 0;
}
bool IsComplexDepth(uint flags)
{
	return (flags & FLAG_COMPLEX_DEPTH) != 0;
}
bool IsStationary(uint flags)
{
	return (flags & FLAG_STATIONARY) != 0;
}


uint GetFlags()
{
	return texelFetch(T_flags, ivec2(gl_FragCoord.xy), 0).r;
}
uint GetFlagsLevel1()
{
	return texelFetch(T_flags, ivec2(gl_FragCoord.xy) >> 1, 1).r;
}

uint GetFlags(vec2 uv)
{
#ifdef UPMODE_FSR
	//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
	#ifdef VIEWPORT_HALF_RES_FSR_HACK
	#endif
	uv *= V_viewportpixelsize.xy / textureSize(T_flags, 0);
#endif
	return textureLod(T_flags, uv, 0).r;
}


//offset has to be a constant/literal, AMD is more anal about this! they check before optimizations
#define RTResolveOffset(samp,offset)	texelFetchOffset(samp, ivec2(gl_FragCoord.xy), 0, offset)


float GetDepth()
{
#ifdef OVERRIDE_DEPTH
	return RTResolve(OVERRIDE_DEPTH).r;
#else
	return RTResolve(T_zdepth).r;
#endif
}
float GetDepth(vec2 uv)
{
#ifdef OVERRIDE_DEPTH
	return RTResolve(OVERRIDE_DEPTH, uv).r;
#else
	return RTResolve(T_zdepth, uv).r;
#endif
}

vec3 GetUVPos()
{
	return vec3(GetFragUV(), GetDepth());
}
vec3 GetUVPos(vec2 uv)
{
	return vec3(uv, GetDepth(uv));
}

vec3 GetClipPos()
{
	return uv2clipZ(GetUVPos());
}
vec3 GetClipPos(vec2 uv)
{
	return uv2clipZ(GetUVPos(uv));
}

vec3 GetViewPos()
{
	return UnProject(GetClipPos());
}
vec3 GetViewPos(vec2 uv)
{
	return UnProject(GetClipPos(uv));
}

half Brightness(half3 c)
{
    return max(max(c.r, c.g), c.b);
}

#define LUM_ITU601 half3(0.299, 0.587, 0.114)

// avoid clutter
#include <p1/deferred/lighting_common.h>
#include <p1/deferred/gbuffer_access.h>

half lluma(vec3 c)
{
	return dot(c, vec3(0.2126, 0.7152, 0.0722));
}
half luminance(CONST half3 c)
{
	return dot( c, LUM_ITU601 );
}

float blendScreen(CONST float A, CONST float B)
{
	return (1 - (1 - A) * (1 - B));
}
half3 blendScreen(CONST half3 A, CONST half3 B)
{
	return (1 - (1 - A) * (1 - B));
}

float blendAvg(CONST float A, CONST float B)
{
 	return ((A + B) / 2);
}

half3 blendAvg(CONST half3 A, CONST half3 B)
{
 	return ((A + B) / 2);
}

half3 blendAdd(CONST half3 A, CONST half3 B)
{
 	return (A + B);
}

half3 blendMix(CONST half3 A, const half3 B, const half fac)
{
	return A+(B-A)*fac;
}

half blendMix(CONST half A, const half B, const half fac)
{
	return A+(B-A)*fac;
}

float blendMultiply(CONST float A, CONST float B)
{
 	return (A * B);
}

float blendMultiply(CONST float A, CONST float B, CONST float fac)
{
	return ((1-fac) * A + fac * A * B);
}

half3 blendMultiply(CONST half3 A, CONST half3 B)
{
 	return (A * B);
}

half3 blendAlpha(CONST half3 A, CONST half3 B, CONST half alpha)
{
 	//return ( (A * alpha) +  (B * (1 - alpha)) );
 	return lerp(A, B, saturate(alpha));
}
float4 blendAlphaF(float4 A, float4 B)
{
	return float4((A.rgb * A.a) + (B.rgb * (1.0f - A.a)), min(A.a + B.a, 1.0f));
}


float blendOverlay(CONST float A, CONST float B)
{
	half L = saturate(10 * (A - 0.45));
	float result1 = 2.0 * A * B;
	float result2 = 1.0 - 2.0 * (1.0 - B) * (1.0 - A);
	return lerp(result1, result2, L);
}

half3 blendOverlay(CONST half3 A, CONST half3 B)
{
	//half3 lumCoeff = half3(0.25,0.65,0.1);
	//half L = min(1,max(0,10*(dot(lumCoeff,A)- 0.45)));
	half L = saturate(10 * (luminance(A) - 0.45));
	half3 result1 = 2.0 * A * B;
	half3 result2 = 1.0 - 2.0 * (1.0 - B) * (1.0 - A);
	return lerp(result1, result2, L);
}
 
half3 blendClimate(CONST half3 A, CONST half3 B)
{
	if (A.r>0.99 && A.g>0.99 && A.b>0.99)
	{
		return half3(1.0,1.0,1.0);
	}else
	return A*B + ((A + B)/4.0 );
}

half3 blendOverlayHDR2(CONST half3 A, CONST half3 B, CONST half strength)
{
//float3 multiplyResults = base * blend;  
//float3 screenResults = 1 - (1 - base) * (1 - blend);  
//float3 t = max(0, sign(base - 0.5));  
//float3 finalColor = 2 * lerp(multiplyResults, screenResults, t); 
	half3 multiplyResults = A*B;//	base * blend;  
	half3 screenResults = half3(4) - (half3(4) - A) * (half3(1) - B);  
	half3 t = max(half3(0), sign(A - half3(10)));  
	//return (A+B+ 8*lerp(multiplyResults, screenResults, t)); 
	//return (A+strength*screenResults+ strength*20 * multiplyResults ); //the one
	return (A+strength*B);//+ strength*20 * multiplyResults ); 
	//return screenResults; 
}




float fresnel_a(float x)
{
	return ((( 1.0f/(pow(abs(x-1.12f),2))) - (1.0f/pow(1.12f,2))) / 68.652f);// (( 1/pow(1.0f-1.12f,2)) - (1/pow(1.12f,2)));
}

float fresnel(CONST float3 V, CONST float3 N, CONST half Power, CONST half Str, CONST half minRange)
{
	//TODO @Timon investigate the exact source of the NaN on the glass floor in the Thresher
//	float fresnel = pow(1-abs(dot(V, N)), Power) * Str;    // note: abs() makes 2-sided materials work
    float fresnel = pow(saturate(1-abs(dot(V, N))), Power) * Str;    // note: abs() makes 2-sided materials work
    float result = minRange + (1-minRange) * fresnel;
    return result;
}

float shadow(float x)
{
	//return ((10000.0f - (1.0f/(pow(abs(x-1.01f),2)))) / 9999.2f);//(( 1/pow(1.0f-1.01f,2)) - (1/pow(1.01f,2)));
	return ((10000.0f - (1.0f/(pow((x-1.01f),2)))) / 9999.2f);//(( 1/pow(1.0f-1.01f,2)) - (1/pow(1.01f,2)));
}

float SoftParticleAttenuation(float softmin, float softmax, float z)
{
	float delta = z - softmin;
	float range = softmax - softmin;
	return saturate(delta / (range + 0.00001)); // prevent division by zero
}

vec3 Tonemap(vec3 color)
{
	color *= half3(F_exposure / (Luminance() + 0.001f));
	color /= half3(1.0f + color);
	return color;
}
vec3 InvTonemap(vec3 color)
{
	color *= half3(Luminance() / F_exposure);
	return color;
}

mat2x3 calc_Light_Hair_PS(float3 DiffColor, float3 VertexToLight, float3 VertexToEye, float3 Normal, float3 Tangent, half SpecPower, half3 LightColor)
{
	mat2x3 Light = mat2x3(0); //(half2x3)0; // 698
	float3 Diff;
	float3 Spec;
	float3 HalfAngle = normalize(VertexToEye + VertexToLight);
	float NdL = dot(Normal, VertexToLight);
	Diff = float3(max(0.0, 0.75 * NdL + 0.25));

	float3 T1 = normalize(Tangent - 0.2 * Normal);
	float3 T2 = normalize(Tangent + 0.1 * Normal);
	
	float3 T1dH = float3(dot(T1, HalfAngle));
	float3 T2dH = float3(dot(T2, HalfAngle));
	
	float3 colorkey = DiffColor / luminance(DiffColor);
	Spec = pow(float3(1) - T1dH * T1dH, float3(0.5 * SpecPower * 0.2)) * (float3(0.5) + float3(0.5) * colorkey);
	Spec += pow(float3(1) - T2dH * T2dH, float3(0.5 * SpecPower)) * (float3(0.9) + float3(0.1) * colorkey);
	Spec *= saturate(3.0 * saturate(NdL) ); //Shadow term
	
	Light[0].rgb = Diff * LightColor.rgb;
	Light[1].rgb = Spec * LightColor.rgb;
	return Light;
}

//rescaled lambert
float lambert_half(CONST float NdL, CONST half lambertpower)
{
	return (pow( (NdL * 0.5) + 0.5, lambertpower));
}

half2 calc_LambertHalf_Phong(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;

	float3 R = reflect(-L, N);
	half NdL = dot(N, L);
		
	Light.x = lambert_half(NdL, Power.y);		// Diffuse (half lambert/scaled up)
	Light.y = pow(saturate(dot(R, V)) + HALF_SMALL_NUMBER, Power.x);	// Phong (half precission)
	Light.y *= saturate(3.0 * saturate(NdL)); 	// Shadow term
	
   	return Light;
}

half2 calc_LambertHalf_Blinn(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;
	
	CONST float3 H = normalize(V + L);
	CONST half NdL = dot(N, L);
	
	Light.x = lambert_half(NdL, Power.y);
	Light.y = pow(saturate(dot(N, H)), Power.x);//Specular
	Light.y *= saturate(3.0 * saturate(NdL)); //Shadow term
	
	return Light;
}

half2 calc_Lambert_Phong(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;

	CONST float3 R = reflect(-L, N); 	
	CONST half NdL = dot(N, L);
		
	Light.x = saturate(NdL);		// Diffuse
	Light.y = pow(saturate(dot(R, V)), Power.x);	// Phong (half precission)
	Light.y *= saturate(3.0 * Light.x); 	// Shadow term
	
   	return Light;
}

half2 calc_Lambert_Blinn(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;
	
	CONST float3 H = normalize(V + L); // NOTE: we need float here, but this triggers the flow control bug...???
	CONST half NdL = dot(N, L);
	
	Light.x = saturate(NdL); 		//Diffuse
	Light.y = pow(saturate(dot(N, H)), Power.x);//Specular
	Light.y *= saturate(3.0 * Light.x); //Shadow term
	
	return Light;
}

half3 calc_StraussNew(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float _smooth, 
					CONST float metal,
					CONST float diffusestr,
					CONST float specularstr,
					CONST float specfunc,
					CONST half3 lightcolor,
					CONST half3 diffusecolor,
					CONST half3 F0)
{
//	return specularstr *= 0.001;
	  // Make sure the interpolated inputs and
    // constant parameters are normalized
	half3 diffuse;
	
   //  float3 nn = normalize( N );
   //  float3 ln = normalize( L );
   //  float3 vn = normalize( V );
 
	
	float3 h = reflect( -L, N );
 
	    
    // Declare any aliases:
    float NdotL   = (dot( N, L ));
	
	float NdotV   = (dot( N, V ));
    float HdotV   = (dot( h, V ));
    float fNdotL  = fresnel_a( NdotL ); //((( 1.0f/(pow(abs(NdotL-1.12f),2)+0.01f)) - 0.797f) / 68.652f);
    float s_cubed = _smooth * _smooth * _smooth;
	//float s_cubed = _smooth * _smooth ;
		
	float fTransparency = 0.0f;
	
    // Evaluate the diffuse term
    float d  = ( 1.0f - metal * _smooth );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	
	
	diffuse = NdotL * d * Rd * diffusecolor;
   // Compute the inputs into the specular term
    float r = ( 1.0f - fTransparency ) - Rd;
 
	
    float j = fNdotL;// * shadow( NdotL ) * shadow( NdotV );
 
 

    // 'k' is used to provide small off-specular
    // peak for very rough surfaces. Can be changed
    // to suit desired results...
 /*   float k = 0.0f;//was 0.1
    float reflect = min( 1.0f, r + j * ( r + k ) );
 
    float3 C1 = float3( 1.0f, 1.0f, 1.0f );
    float3 Cs = C1 + metal * (1.0f - fNdotL) * (diffusecolor - C1);
 
 	half specatten = saturate(3.0 * saturate(NdotL));*/
	//half specatten = saturate(NdotL);

	

    // Evaluate the specular term
    
	//half3 specular = Cs* reflect*specatten;
    //specular *= pow( -HdotV, 3.0f / ((1.0f - smooth)) ); //(0.000000134123f + (1.0f - smooth))
	
	//specular = C1 * pow(saturate(HdotV), 32.0f);

	CONST float3 H2 = normalize(V + L);
	half3 specular = half3(pow(saturate(dot(N,H2)), 60.0f));
	//specular = float3(0.0f,0.0f,0.0f);

    // Composite the final result, ensuring
    // the values are >= 0.0f yields better results. Some
    // combinations of inputs generate negative values which
    // looks wrong when rendered...
    diffuse  = max( half3(0.0f), diffusestr*diffuse*lightcolor.rgb );
    specular = max( half3(0.0f), specularstr*specular*lightcolor.rgb * diffusecolor.rgb );
	//new : additive/multiply mix

	CONST half3 addSpecular = specfunc*specular;
	CONST half3 mulSpecular = (1.0 - specfunc)*specular;
	diffuse = (diffuse + addSpecular) + (diffuse*mulSpecular);
//	diffuse *= 0.00001;
	
	//old style aditive only
//	diffuse += specular/1.0; //diffuse += diffuse*specular;
//	diffuse += specular;
//	diffuse = half3(specularstr) / 100;
//	diffuse += V / 10;
//	diffuse += L / 100;
//	diffuse += V + L;
//	diffuse += N / 100;
//	diffuse += H2 / 100;
//	diffuse += half3(NdotL, NdotV, HdotV) / 100.0;
//	diffuse += half3(saturate(dot(N,H2)) / 50.0);
//	diffuse += half3(pow(saturate(dot(N,H2)), 60.0f));
	
    return diffuse;
}

half3 calc_StraussNew2(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float _smooth, 
					CONST float metal,
					CONST float diffusestr,
					CONST float specularstr,
					CONST float specfunc,
					CONST half3 lightcolor,
					CONST half3 diffusecolor,
					CONST half3 F0,
					CONST half3 specularcolor)
{
	  // Make sure the interpolated inputs and
    // constant parameters are normalized
	half3 diffuse;
	
   //  float3 nn = normalize( N );
   //  float3 ln = normalize( L );
   //  float3 vn = normalize( V );
     float3 h = reflect( -L, N );
 
	    
    // Declare any aliases:
    float NdotL   = (dot( N, L ));
	
	float NdotV   = (dot( N, V ));
    float HdotV   = (dot( h, V ));
    float fNdotL  = fresnel_a( NdotL ); //((( 1.0f/(pow(abs(NdotL-1.12f),2)+0.01f)) - 0.797f) / 68.652f);
    float s_cubed = _smooth * _smooth * _smooth;
	//float s_cubed = smooth * smooth ;
		
	float fTransparency = 0.0f;
	
    // Evaluate the diffuse term
    float d  = ( 1.0f - metal * _smooth );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	
	
	diffuse = NdotL * d * Rd * diffusecolor;
   // Compute the inputs into the specular term
    float r = ( 1.0f - fTransparency ) - Rd;
 
	
    float j = fNdotL;// * shadow( NdotL ) * shadow( NdotV );
 


    // 'k' is used to provide small off-specular
    // peak for very rough surfaces. Can be changed
    // to suit desired results...
     float k = 0.1f;//was 0.1
    float reflect = min( 1.0f, r + j * ( r + k ) );
 
    float3 C1 = specularcolor;//float3( 1.0f, 1.0f, 1.0f );
    //float3 Cs = C1 + metal * (1.0f - fNdotL) * (diffusecolor - C1);
	float3 Cs = C1 + metal * (1.0f - NdotL) * (diffusecolor - C1);
 
 	//half specatten = saturate(3.0 * saturate(NdotL));
	half specatten = saturate(NdotL);

	

    // Evaluate the specular term
 //   half3 specular = Cs * reflect*specatten;
//	specular *= pow( -HdotV, 3.0f / ((1.0f - _smooth)) ); //(0.000000134123f + (1.0f - _smooth))
	
	CONST float3 H2 = normalize(V+L);
	half3 specular = half3(pow(saturate(dot(N,H2)), 40.0f));

	
    // Composite the final result, ensuring
    // the values are >= 0.0f yields better results. Some
    // combinations of inputs generate negative values which
    // looks wrong when rendered...
    diffuse  = max(half3(0.0f), diffusestr*diffuse*lightcolor.rgb );
    specular = max(half3(0.0f), specularstr*specular*specularcolor.rgb*diffusecolor.rgb ); //*diffusecolor.rgb
	//new : additive/multiply mix

	CONST half3 addSpecular = specfunc*specular;
	CONST half3 mulSpecular = (1.0 - specfunc)*specular;
	diffuse = (diffuse + addSpecular) + (diffuse*mulSpecular);

	//old style aditive only
	//diffuse += specular; //diffuse += diffuse*specular;
	
    return diffuse;
}

#include <common_shadows.h>

#ifndef DISABLE_SHADOW_HELPERS
#ifndef OCULUS_SHADER
#ifndef DISABLE_SHADOW_SUPPORT

vec3 CSMColorCascades(in float depth)
{
	int cascadeIndex = -1;
	for(int i = 0; i < 4; ++i) {
		if(depth < V_csmthresholds[i]) {	
			cascadeIndex = i;
			break;
		}
	}
	if (cascadeIndex == -1) {
		return vec3(0.0f, 0.0f, 1.0f);
	}
	if (cascadeIndex == 0) {
		return vec3(1.0f, 0.0f, 0.0f);
	}
	if (cascadeIndex == 1) {
		return vec3(1.0f, 1.0f, 0.0f);
	}
	if (cascadeIndex == 2) {
		return vec3(0.0f, 1.0f, 0.0f);
	}
	if (cascadeIndex == 3) {
		return vec3(0.0f, 1.0f, 1.0f);
	}
	
	return vec3(1.0f, 1.0f, 1.0f);
}

//vec3 csmDebugRender(in float ndotl)
vec3 csmDebugRender(in float ndotl, in vec4 coords[5])
{
	
	float z = IO_worldview_pos.z; // would not work for deferred
	
	vec4 weights = getCSMWeights(coords, ndotl);
	//weights = getCSMWeightsChar(coords);
	float w0 = weights.x;
	float w1 = min(1.0f - weights.x, weights.y);
	float w2 = min(1.0f - weights.y, weights.z);
	float w3 = min(1.0f - weights.z, weights.w);
	float w4 = 1.0f - (weights.w + weights.z + weights.y + weights.x); // recheck this one
	w4 = 1 - saturate(w0 + w1 + w2 + w3);

	
	CONST vec3 c0color = vec3(4, 0,0);
	CONST vec3 c1color = vec3(0, 4, 4);
	CONST vec3 c2color = vec3(4, 0, 4);
	CONST vec3 c3color = vec3(4, 4, 4);
	CONST vec3 c4color = vec3(4, 4, 4);
	
	float ndotle = max(epsilon, ndotl);
	
#define CSM_DRAW_TEXELS

	vec3 dbgcol = vec3(0);
	dbgcol += c0color*w0;
#ifdef CSM_DRAW_TEXELS
	float t = floor(coords[0].x * F_shadowmapsize + 0.5f) + floor(coords[0].y * F_shadowmapsize + 0.5f);
	float s0 = w0 * GetCSMSampleHard(T_shadowCSM0, coords[0].xyz + biasCSM[0] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w0+s0);
#endif
#ifdef D_USE_CSM_C1
	dbgcol += c1color*w1;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[1].x * F_shadowmapsize + 0.5f) + floor(coords[1].y * F_shadowmapsize + 0.5f);
	float s1 = w1 * GetCSMSampleHard(T_shadowCSM1, coords[1].xyz + biasCSM[1] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w1+s1);
#endif
#endif
#ifdef D_USE_CSM_C2
	dbgcol += c2color*w2;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[2].x * F_shadowmapsize + 0.5f) + floor(coords[2].y * F_shadowmapsize + 0.5f);
	float s2 = w2 * GetCSMSampleHard(T_shadowCSM2, coords[2].xyz + biasCSM[2] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w2+s2);
#endif
#endif
#ifdef D_USE_CSM_C3
	dbgcol += c3color*w3;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[3].x * F_shadowmapsize + 0.5f) + floor(coords[3].y * F_shadowmapsize + 0.5f);
	float s3 = w3 * GetCSMSampleHard(T_shadowCSM3, coords[3].xyz + biasCSM[3] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w3+s3);
#endif
#endif
#ifdef D_USE_CSM_C4
	dbgcol += c4color*w4;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[4].x * F_shadowmapsize + 0.5f) + floor(coords[4].y * F_shadowmapsize + 0.5f);
	float s4 = w4 * GetCSMSampleHard(T_shadowCSM4, coords[4].xyz + biasCSM[4] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w4+s4);
#endif
#endif

	//if(z>F_shadowmaxdistance)
	//	dbgcol *= 0.0f;
	//
	//// draw cascade boundaries
	//CONST float linetreshold = z/500.0f;
	//
	//for(int i=0; i<4; ++i) {
	//	if(abs(z - V_csmthresholds[i]) < linetreshold)
	//		dbgcol = vec3(100.0f);
	//	// if(F_csm_blendstrength > 1.0f && abs(z - V_csmthresholds[i]) < linetreshold)
	//	// 	dbgcol = vec3(100.0f, 0.0f, 100.0f);
	//}

	
	return dbgcol;
		}


vec3 csmDebugRender(in float ndotl) {
	vec4 coords[5];
	return csmDebugRender(ndotl, coords);
}




// unified shadow interface
// make also depend on B_shadow?

float GetShadow(in float ndotl)
{
	// float z = RTResolve(T_gbuffer3).w;
	float z = IO_worldview_pos.z; // would not work for deferred
    
	CONST float FADE_OUT_PERCENTAGE = 0.1;
	float fade = saturate((z - (1.0 - FADE_OUT_PERCENTAGE) * F_shadowmaxdistance) / (FADE_OUT_PERCENTAGE * F_shadowmaxdistance));

	// if(fade>0.99)
	// 	return 1.0f;
	
	vec4 coords[5];
	coords[0] = IO_texshadowCSM0;
	coords[1] = IO_texshadowCSM1;
	coords[2] = IO_texshadowCSM2;
	coords[3] = IO_texshadowCSM3;
	coords[4] = IO_texshadowCSM4;
	return saturate(GetCSMShadow(ndotl, coords) + fade);
}

float GetShadow()
{
	return GetShadow(1.0f);
}

#endif //DISABLE_SHADOW_SUPPORT
#endif //OCULUS_SHADER
#endif //DISABLE_SHADOW_HELPERS

// #else /*GFX_VULKAN*/
/*
float GetShadow(in float ndotl)
{
	return 1.0f;
}

float GetShadow()
{
	return 1.0f;
}

#endif*/

//-------------------------------------------------------------------------------
// Lighting/Shadow defines ( pixel-shader specific )
//-------------------------------------------------------------------------------

#define CALC_AMBIENT(DIFFUSE, AMBIENT, OUT_COLOR)														\
	OUT_COLOR += AMBIENT * DIFFUSE;


#define CALC_GLOBAL_DIRLIGHT(NR, LIGHTFUNCTION) 														\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;											\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);										\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * F_globallightscale);								\
       	half2 DiffSpecTerms = LIGHTFUNCTION(Normal, V_direction##NR.rgb, VertexToEye, LightPower.xy); 	\
		DiffuseLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 									\
		SpecularLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y;									\
	}

#define CALC_GLOBAL_DIRLIGHT_SHADOW(NR, LIGHTFUNCTION_GLOBAL, LIGHT_POWER, IN_OUT_DIFFUSE, IN_OUT_SPECULAR, SHADOW) 	\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																										\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;												\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);											\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * F_globallightscale);									\
       	half2 DiffSpecTerms = LIGHTFUNCTION_GLOBAL(Normal.xyz, V_direction##NR.xyz, VertexToEye, LIGHT_POWER); 	\
       	DiffSpecTerms.x *= saturate(SHADOW * 0.9 + 0.1); /* sum to 1.0, 10% light still at shadow) */		\
       	DiffSpecTerms.y *= saturate(SHADOW * SHADOW); /* we dont want specular in shadow areas */			\
		IN_OUT_DIFFUSE.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 									\
		IN_OUT_SPECULAR.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y; 									\
	}

#define CALC_STRAUSS_DIRLIGHT_SHADOW(NR, DIFFUSE, F0, SHADOW, OUT_COLOR)								\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*12.0f;								\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew(Normal.rgb, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 		0.5,				\
										LightColor.rgb, DIFFUSE, F0); 								\
	/*	OUT_COLOR.rgb *= 0.0001; OUT_COLOR.rgb += half3(specstr);*/	\
	}
	
#define CALC_STRAUSS_DIRLIGHT_2_SHADOW(NR, DIFFUSE, SPECULAR, F0, SHADOW, OUT_COLOR)								\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*6.0f;								\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew2(Normal, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 		0.5,				\
										LightColor.rgb, DIFFUSE, F0,SPECULAR); 								\
	}

#define CALC_STRAUSS_DIRLIGHT_COCKPIT_SHADOW(NR, DIFFUSE, F0, SHADOW, OUT_COLOR)							\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																										\
		half4 LightColor = V_lightcolor##NR.rgba;															\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale*0.5;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*256.0f;					\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 1.0,			\
										LightColor.rgb, DIFFUSE, F0); 										\
	}

#define CALC_GLOBAL_DIRLIGHT_PLANET(NR, LIGHTFUNCTION) \
	if (V_lightcolor##NR.a > 0.0)									\
	{																	\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;			\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);		\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * 0.15); /* HACK layer multiply + HDR = bad idea */					\
       	half2 DiffSpecTerms = LIGHTFUNCTION(Normal, V_direction##NR.xyz, VertexToEye, LightPower.xy ); \
		DiffuseLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 	\
		SpecularLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y;	\
	}																	

#define CALC_STRAUSS_PLANET_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		float specstr = S_specularstr * (TexSpecularStr.g)*12.0f;												\
		float diffstr = S_diffusestr;																	\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.xyz, VertexToEye, 						\
										Smoothness2, Metallness2, diffstr, specstr, 0.0	,					\
										LightColor.rgb, DIFFUSE, F0);								\
	/*	OUT_COLOR.rgb *= 0.0001; OUT_COLOR.rgb += LightColor.xyz/ 10;*/	\
	}


#define CALC_STRAUSS_2ND_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
		LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g)*4.0f;												\
		CONST float diffstr = S_diffusestr;																	\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.xyz, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 	1.0,					\
										LightColor.rgb, DIFFUSE, F0);								\
	}

#ifdef P1_SHADERS

float4 calc_Strauss_PBR(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float fSmoothness, 
					CONST float fMetalness,
					CONST float fTransparency,
					CONST float refractionIndex,
					CONST half3 lightcolor,
					CONST half3 cDiffuse
					)
{
	// Make sure the interpolated inputs and
	// constant parameters are normalized
	float3 n = N;//normalize( N );
	float3 l =normalize( L );
	float3 v = V;//normalize( V );
	float3 h = reflect( l, n );

	// Declare any aliases:
	float NdotL   = dot( n, l );
	float NdotV   = dot( n, v );
	float HdotV   = dot( h, v );
	float fNdotL  = fresnel_a( NdotL );
	float s_cubed = fSmoothness * fSmoothness * fSmoothness;

	//	return float4(fNdotL,fNdotL,fNdotL,1.0f);

	// Evaluate the diffuse term
	float d  = ( 1.0f - fMetalness * fSmoothness );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	float3 diffuse = NdotL * d * Rd * cDiffuse  * lightcolor;

	// Compute the inputs into the specular term
	float r = ( 1.0f - fTransparency ) - Rd;

	float j = fNdotL * shadow( NdotL ) * shadow( NdotV );

	// 'k' is used to provide small off-specular
	// peak for very rough surfaces. Can be changed
	// to suit desired results...
	CONST float k = 0.01f;
	float reflect = min( 1.0f, r + j * ( r + k ) );

	float3 C1 = float3( 1.0f, 1.0f, 1.0f );
	float3 Cs = C1 + fMetalness * (1.0f - fNdotL) * (cDiffuse - C1);


	// Evaluate the specular term
	float3 specular = Cs * reflect;
	specular *= pow( -HdotV, 3.0f / (1.0f - fSmoothness) );
	//below: test to tint spec more to material color
	specular = specular * (1.1f-fMetalness)+ specular*(fMetalness+0.1f)*cDiffuse * lightcolor;
	// Composite the final result, ensuring
	// the values are >= 0.0f yields better results. Some
	// combinations of inputs generate negative values which
	// looks wrong when rendered...
	diffuse  = max( float3(0.0f), diffuse );
	specular = max( float3(0.0f), specular*2.0f *  float3(lambert_half(NdotL, 2.2)) );
	// return float4(specular, 1.0f );
	return float4( diffuse + specular, luminance(specular));
}

	float4 calc_Strauss_PBR_aniso(	CONST float3 N,
					CONST float3 L,
					CONST float3 V,
					CONST float fSmoothness,
					CONST float fMetalness,
					CONST float fTransparency,
					CONST float refractionIndex,
					CONST half3 lightcolor,
					CONST half3 cDiffuse,
					float2 fAnisotropicRoughness
					)
	{
		// Make sure the interpolated inputs and
		// constant parameters are normalized
		float3 n = N;//normalize( N );
		float3 l =normalize( L );
		float3 v = V;//normalize( V );
		float3 h = reflect( l, n );
		float3 h2 = normalize( l + v );

		// Declare any aliases:
		float NdotL   = dot( n, l );
		float NdotV   = dot( n, v );
		float HdotV   = dot( h, v );
		float fNdotL  = fresnel_a( NdotL );
		float s_cubed = fSmoothness * fSmoothness * fSmoothness;

		// Apply a small bias to the roughness
		// coefficients to avoid divide-by-zero
		fAnisotropicRoughness += float2( 1e-5f, 1e-5f );

		// Define the coordinate frame
		float3 epsilon   = float3( 1.0f, 0.0f, 0.0f );
		float3 tangent   = normalize( cross( n, epsilon ) );
		float3 bitangent = normalize( cross( n, tangent ) );
		// float VdotN = dot( v, n );
		// float LdotN = dot( l, n );
		float H2dotN = dot( h2, n );

		float H2dotT = dot( h2, tangent );
		float H2dotB = dot( h2, bitangent );

		// Evaluate the specular exponent
		float beta_a  = H2dotT / fAnisotropicRoughness.x;
		beta_a       *= beta_a;

		float beta_b  = H2dotB / fAnisotropicRoughness.y;
		beta_b       *= beta_b;

		float beta = -2.0f * ( ( beta_a + beta_b ) / ( 1.0f + H2dotN ) );

		// Evaluate the specular denominator
		float s_den  = 4.0f * 3.14159f; 
		s_den       *= fAnisotropicRoughness.x;
		s_den       *= fAnisotropicRoughness.y;
		s_den       *= sqrt( abs(NdotL * NdotV) );	//<Timon> I had to add the abs because apparently in HLSL sqrt of negative values is fine

		// Compute the final specular term
		//float3 Specular = Ps * ( exp( beta ) / s_den );


		// Evaluate the diffuse term
		float d  = ( 1.0f - fMetalness * fSmoothness );
		float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
		float3 diffuse = NdotL * d * Rd * cDiffuse * lightcolor;

		// Compute the inputs into the specular term
		float r = ( 1.0f - fTransparency ) - Rd;

		float j = fNdotL * shadow( NdotL ) * shadow( NdotV );

		// 'k' is used to provide small off-specular
		// peak for very rough surfaces. Can be changed
		// to suit desired results...
		CONST float k = 0.01f;
		float reflect = min( 1.0f, r + j * ( r + k ) );

		float3 C1 = float3( 1.0f, 1.0f, 1.0f );
		float3 Cs = C1 + fMetalness * (1.00001f - fNdotL) * (cDiffuse - C1);

		// Evaluate the specular term
		float3 specular;
// 		specular = Cs * reflect;
// 		specular *= pow( -HdotV, 3.0f / (1.00001f - fSmoothness) );
	//	specular = C1*NdotL*( exp( beta ) / s_den);
		specular = float3( exp( beta ) / s_den) * float3(fSmoothness+0.001f);
		//to tint spec more to material color
		specular = (specular * saturate(1.00001f-fMetalness)+ specular*saturate(fMetalness+0.0001f)*cDiffuse) * lightcolor ;
		//specular = (specular * saturate(1.00001f-pow(fMetalness,0.1f))+ specular*saturate(pow(fMetalness,0.1f)+0.0001f)*cDiffuse) * lightcolor ;
	
		// Composite the final result, ensuring
		// the values are >= 0.0f yields better results. Some
		// combinations of inputs generate negative values which
		// looks wrong when rendered...
		diffuse  = max( float3(0.0f), diffuse );
		specular = max( float3(0.0f), specular *  lambert_half(NdotL, 6.2) );
		//specular = max( 0.0f, specular*(30.0f+15.0f*fMetalness) *  lambert_half(NdotL, 2.2) );
		//return float4(specular, 1.0f );
		return saturate(float4( diffuse + specular, luminance(specular) ));
	}

	#define CALC_STRAUSS_PBR_ANI(NR, DIFFUSE, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;														\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float transparency = 0.0f;																\
		CONST float refraction = 1.0f;																	\
		OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.rgb, VertexToEye, 			\
										SmoothnessVal, MetalnessVal, transparency, refraction,			\
										LightColor.rgb, DIFFUSE,SmoothnessVal);							\
	}

	#define CALC_STRAUSS_PBR_ANI2(NR, DIFFUSE, OUT_COLOR)												\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;														\
    	LightColor.rgb = (LightColor.rgb) * F_globallightscale;											\
		CONST float transparency = 0.0f;																\
		CONST float refraction = 0.0f;																	\
		OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.rgb, VertexToEye, 			\
										SmoothnessVal, MetalnessVal, transparency, refraction,			\
										LightColor.rgb, DIFFUSE,fAnisotropicRoughness).rgb;					\
	}

	#define CALC_STRAUSS_PBR_ANI2_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
		{																									\
			half4 LightColor = V_lightcolor##NR.rgba;													\
			LightColor.rgb = (LightColor.rgb) * F_globallightscale;				\
			CONST float transparency = 0.0f;																\
			CONST float refraction = 0.0f;																\
			OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.xyz, VertexToEye, 						\
											SmoothnessVal, MetalnessVal, transparency, refraction,						\
											LightColor.rgb, DIFFUSE, fAnisotropicRoughness).rgb;								\
		}
	#define CALC_STRAUSS_PBR_TRANSP_DIRLIGHT(NR, DIFFUSE, ALPHA, OUT_COLOR)												\
		{																									\
			half4 LightColor = V_lightcolor##NR.rgba;													\
			LightColor.rgb = (LightColor.rgb) * F_globallightscale;				\
			CONST float transparency = 1.0f-ALPHA;																\
			CONST float refraction = 0.0f;																\
			CONST float SmoothnessVal = 0.20f;																\
			CONST float MetalnessVal = 0.0f;																\
			CONST float2 fAnisotropicRoughness = float2(0.75f,0.75f);											\
			OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.xyz, VertexToEye, 						\
											SmoothnessVal, MetalnessVal, transparency, refraction,						\
											LightColor.rgb, DIFFUSE,fAnisotropicRoughness).rgb;								\
		}
	
#endif

#include <../../extensions/X4FoundationShaderMod-main/shadergl/shaders/jm_includes/jm_lighting_functions.h>

vec3 global_lights(in vec3 wn, in vec3 view_pos, in vec3 Albedo, in float Metalness, in float Roughness, bool dossr, vec4 prev)
{
	vec3 wv = normalize(-view_pos) * mat3(M_view);
	vec3 wr = reflect(-wv, wn);

	float ambient_occlusion = 1.0f;
	// ambient_occlusion = mix(1, Shadow, n_dot_l); // ambient attenuation wrt. shadow (sometimes "weird")
	ambient_occlusion = GetSSAO();
	
	// vec3 cspec = mix(vec3(0.04), Albedo, Metalness);
	// vec3 cdiff = Albedo * (1-Metalness);
	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	vec3 csub = vec3(0);
	vec3 wnsub = wn;
	float Subsurface = 0;
	float SubsurfaceMask = 0;
	float RoughnessEpidermal = 0.5;
	#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
		get_colors(	Albedo, 
					Metalness, 
					Roughness, 
					cspec, 
					cdiff, 
					csub,
					wnsub,					
					Subsurface, 
					RoughnessEpidermal, 
					SubsurfaceMask);
	#else
		get_colors(Albedo, Metalness, cspec, cdiff);
	#endif
	// vec3 cdiff = Albedo * saturate(1.0f - luminance(cspec)); // alt energy conservation
#ifdef JM_DEBUG_SUBSURFACE_NORMALS
	return pow(vec3(wnsub * 0.5 + 0.5), vec3(2.2));
#endif
#ifdef JM_DEBUG_BASE_NORMALS
	return pow(vec3(wn * 0.5 + 0.5), vec3(2.2));
#endif
	
	// dirlight data
	vec3 ldirs[2];
	vec3 lcolors[2];
	vec3 direct_occlusions[2];

	ldirs[0] = normalize(V_direction1.xyz);
	ldirs[1] = normalize(V_direction2.xyz);

#ifdef LOCALSPEC
	lcolors[0] = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale*2.0f;
	lcolors[1] = XR_TO_linearRGB(V_lightcolor2.rgb) * F_globallightscale*2.0f;
#else
	lcolors[0] = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale;
	lcolors[1] = XR_TO_linearRGB(V_lightcolor2.rgb) * F_globallightscale;
#endif
#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES
	float level = dot(LUM_ITU601, lcolors[0]);
	lcolors[0] = vec3(level, 0.0, 0.0);
	level = dot(LUM_ITU601, lcolors[1]);
	lcolors[1] = vec3(0.0, level, level);
#endif 
	for (int i = 0; i < 2; ++i) {
		direct_occlusions[i] = vec3(saturate(dot(ldirs[i], wn)), saturate(dot(ldirs[i], wn)), SubsurfaceMask * sss_wrap_dot(ldirs[i], wnsub, Subsurface));
	}
	
	//vec3 l = mat3(M_view) * normalize(V_direction1.xyz);

	// shadows for mainlight
	float Shadow = 0.0f;
	vec4 test = vec4(0);
#ifdef JM_SSSHADOWS
	float fade = 0.0;
#endif 		
	
#ifndef DISABLE_SHADOW_HELPERS
#ifndef DISABLE_SHADOW_SUPPORT
	if (B_shadow && direct_occlusions[0].x > 0.0f) {
//		float ndotle = max(epsilon, direct_occlusions[0]);
		CONST float FADE_STR = 0.1;
		CONST float FADE_STR_DIST = 0.5;
		if (F_shadowmaxdistance < 6000.0f) {
			FADE_STR_DIST = 0.7;
		}
		#ifdef JM_SSSHADOWS
			fade = saturate((length(view_pos) - (1.0 - FADE_STR) * F_shadowmaxdistance) / (FADE_STR_DIST * F_shadowmaxdistance));
		#else
			float fade = saturate((length(view_pos) - (1.0 - FADE_STR) * F_shadowmaxdistance) / (FADE_STR_DIST * F_shadowmaxdistance));
		#endif

		vec4 coords[5];
		coords[0] = mul(float4(view_pos, 1), M_shadowCSM0);
		coords[1] = mul(float4(view_pos, 1), M_shadowCSM1);
		coords[2] = mul(float4(view_pos, 1), M_shadowCSM2);
		coords[3] = mul(float4(view_pos, 1), M_shadowCSM3);
		coords[4] = mul(float4(view_pos, 1), M_shadowCSM4);
		direct_occlusions[0] *= saturate(fade + GetCSMShadow(direct_occlusions[0].x, coords));	
	/*	vec4 weights = getCSMWeights(coords);
		float w0 = weights.x;
		float w1 = min(1.0f-weights.x, weights.y);
		float w2 = min(1.0f-weights.y, weights.z);
		float w3 = min(1.0f-weights.z, weights.w);
		float w4 = 1.0f - (weights.w+weights.z+weights.y+weights.x); // recheck this one
		w4 = 1 - saturate(w0+w1+w2+w3);
		
// 		direct_occlusions[0] *= GetCSMSample3Taps(T_shadowCSM2, mul(float4(view_pos, 1), M_shadowCSM2).xyz + biasC2/ndotle);
// 		direct_occlusions[0] *= GetCSMSample3Taps(T_shadowCSM3, mul(float4(view_pos, 1), M_shadowCSM3).xyz + biasC3/ndotle);
		
// 		Shadow += GetCSMSample3Taps(T_shadowCSM2, mul(float4(view_pos, 1), M_shadowCSM2).xyz + biasC2/ndotle);
		
// 			Shadow += w0 * GetCSMSample3Taps(T_shadowCSM0, coords[0].xyz + biasC0/ndotle);
// 			Shadow += w1 * GetCSMSample3Taps(T_shadowCSM1, coords[1].xyz + biasC1/ndotle);
// 			Shadow += w2 * GetCSMSample3Taps(T_shadowCSM2, coords[2].xyz + biasC2/ndotle);
// 			Shadow += w3 * GetCSMSample2Taps(T_shadowCSM3, coords[3].xyz + biasC3/ndotle);
// 			Shadow += w4 * GetCSMSampleFast(T_shadowCSM4, coords[4].xyz + biasC4/ndotle);
		
		direct_occlusions[0] *= saturate(Shadow);
// 		test = getCSMWeights(coords);
// 		test = coords[1];/**/
	}
#endif
#endif


	// light accumulation
	vec3 light_accum = vec3(0.0);

#ifdef JM_SSSHADOWS
	vec3 ss_shadow_debug = vec3(0.0);
#endif	
	// dirlights
	for(int i=0; i<2; i++) {
		//float n_dot_l = saturate(dot(Normal, ldirs[i]));
		//float direct_occlusion = n_dot_l;
		//if(i==0) { // only attenuation for 1st light
		//	direct_occlusion *= Shadow;
		//}
		CONST float light_radius = V_deferred_lightparams.x*10; // dbg scale

		float ss_shadow = 1.0;
		
		#ifdef JM_SSSHADOWS
			float fade_near = saturate(-(length(view_pos) - JM_SSSHADOWS_FADE_DISTANCE_NEAR) / (JM_SSSHADOWS_FADE_DISTANCE_NEAR * 0.5));
			fade = max(fade, saturate((length(view_pos) - (1.0 - 0.1) * JM_SSSHADOWS_FADE_DISTANCE) / (0.5 * JM_SSSHADOWS_FADE_DISTANCE)));
			#ifdef JM_SSSHADOWS_DEBUG_MODE
				ss_shadow_debug.r = direct_occlusions[JM_SSSHADOWS_LIGHT_TO_DEBUG].x * (fade_near + fade);
				ss_shadow_debug.b = direct_occlusions[JM_SSSHADOWS_LIGHT_TO_DEBUG].x;
			#endif
			//screenspace shadow
			if(min(direct_occlusions[i].x, direct_occlusions[i].y) * (fade_near + fade) > 0.001)
			{
				#ifndef JM_SSSHADOWS_SUPPORT_BOTH_PRIMARY_LIGHTS
				if(i > 0)
					continue;
				#endif
				
				#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
					if(GetViewPos().x > 0.0)
				#endif
				ss_shadow = ScreenSpaceShadows(	world2view_rot(-ldirs[i]),
												dot(ldirs[i], wn),
												vec2(fade_near, fade), 
												ss_shadow_debug);
			}
			#ifdef JM_SSSHADOWS_FILTER
				#if 1
					ss_shadow = mix(ss_shadow, 0.5, saturate((fwidth(ss_shadow))));
				#else
					ss_shadow = mix(ss_shadow, 0.5, saturate(max(abs(dFdxFine(ss_shadow)), abs(dFdyFine(ss_shadow)))));
				#endif
			#endif
		#endif
		direct_occlusions[i] *= ss_shadow;
		// todo: slightly refactor the following
		vec3 L;
		direct_occlusions[i] *= EvalSphereLight(light_radius, ldirs[i] * 1000, wv, wn, wr, Roughness, L);

		L = normalize(L);

		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
			light_accum += EvalBRDF(cspec,
									cdiff, 
									Roughness, 
									L, 
									wv, 
									wn, 
									direct_occlusions[i], 
									Subsurface, 
									RoughnessEpidermal, 
									csub,
									wnsub,			
									true) * lcolors[i];
		#else
			light_accum += (EvalBRDF(cspec, cdiff, Roughness, L, wv, wn, vec2(1)) * lcolors[i]) * direct_occlusions[i].y;
		#endif

		// clearcoat
		//float clearcoat_spec = cc * EvalBRDF(vec3(0.05), cdiff, 0.1, L, v, Normal2, vec2(0,1)).r; // ok since dielectric reflection
		//light_accum += clearcoat_spec * E_sph;

		//vec3 E_diffuse = direct_occlusions[i] * ambient_occlusion * lcolors[i];
		//light_accum += cdiff / PI * E_diffuse; // diffuse
		//light_accum += cdiff * E_diffuse; // diffuse
	}
	{// ambient light
		// reduce roughness based on v_dot_n yields nicer fresnel contours
		float v_dot_n = saturate(dot(wv, wn));
		
		/*
		Jon Note if anyone from Egosoft ever reads this, I would stronly recommend against this!! 
		None of the AAA engines does it. It leads to insane levels of specular aliasing, even with TAA.
		And the high anisotropic strething reflections you're trying to acomplish with it can't be achieved like this.
		It is technically possible to stretch the derivatives for a textureCUBEgrad() however. ;)
		*/
		#ifdef JM_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE
			#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
				float ambRoughness = GetViewPos().x > 0.0 ? Roughness : mix(Roughness*0.3, Roughness, pow(v_dot_n, 1.0/3.0));	
			#else				
				float ambRoughness = Roughness;
			#endif
		#else
			// smaller cone at edges to highlight fresnel
			float ambRoughness = mix(Roughness*0.3, Roughness, pow(v_dot_n, 1.0/3.0));
			//ambRoughness = Roughness; // deactivated, effect too strong
		#endif		

		// vec3 spec_amb =  simple_spec_brdf_ibl(T_ibl_envmap, cspec, Roughness, wn, wv);
		// vec3 spec_amb =  spec_brdf_ibl(T_ibl_envmap, vec3(0,0,0), T_preintegrated_GGX, cspec, ambRoughness, wn, wv);
		vec3 Eamb = V_ambient1.rgb;//Flat color in the age of PBR :(

		//TODO SSR has higher priority!
		vec4 ssr = vec4(0);
		if (dossr) {
			ssr = RTResolveSoft(T_ssr);
			ssr.a = SSR_GetHit(ssr.a);
// 			ssr *= (1 - ambRoughness);
// 			ssr.rgb *= cspec;
// 			float n_dot_v = saturate(dot(wn, wv));

// 			vec2 env_brdf = textureLod(T_preintegrated_GGX, vec2(ambRoughness, n_dot_v), 0).xy;
			// return vec3(env_brdf, 0);
// 			ssr.rgb *= (cspec*env_brdf.x + env_brdf.y);
		}

		#ifdef JM_USE_RETROREFLECTIVE_DIFFUSE_MODEL
			#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
				if(GetViewPos().x > 0.0)
				{
					light_accum += combined_ambient_brdf(T_ibl_envmap, cspec, cdiff, csub, wn, wnsub, wv, ambRoughness, RoughnessEpidermal, SubsurfaceMask, Subsurface, ambient_occlusion, ssr, Eamb);
				}
				else
				{
					float a = ssr.a;
					vec3 first_sum = a * ssr.rgb;
			
					a += prev.a;
					first_sum += saturate(1 - a) * spec_first_sum_ibl(T_ibl_envmap, ambRoughness, wn, wv).rgb;
					first_sum += Eamb;
					vec3 spec_amb = spec_brdf(first_sum, cspec, ambRoughness, v_dot_n);
					vec3 diff_amb = saturate(1 - prev.a) * cdiff * (get_irradiance(T_ibl_envmap, wn) + Eamb);
			
					light_accum += (spec_amb + diff_amb) * ambient_occlusion;			
				}
			#else
				light_accum += combined_ambient_brdf(T_ibl_envmap, cspec, cdiff, csub, wn, wnsub, wv, ambRoughness, RoughnessEpidermal, SubsurfaceMask, Subsurface, ambient_occlusion, ssr, Eamb);
			#endif
		#else
			float a = ssr.a;
			vec3 first_sum = a * ssr.rgb;
	
			a += prev.a;
			first_sum += saturate(1 - a) * spec_first_sum_ibl(T_ibl_envmap, ambRoughness, wn, wv).rgb;
			first_sum += Eamb;
			vec3 spec_amb = spec_brdf(first_sum, cspec, ambRoughness, v_dot_n);
			vec3 diff_amb = saturate(1 - prev.a) * cdiff * (get_irradiance(T_ibl_envmap, wn) + Eamb);
	
			light_accum += (spec_amb + diff_amb) * ambient_occlusion;
		#endif
	}
	
	light_accum = clamp(light_accum.rgb, 0, 10); // safety clamp, not visible
	#ifdef JM_SSSHADOWS_DEBUG_MODE
		light_accum = ss_shadow_debug;
	#endif
	#ifdef JM_DEBUG_SUBSURFACE
		light_accum += SubsurfaceMask * vec3(1.0, Subsurface, 0.0);
	#endif

	return DEFERRED_HACK_TO_sRGB(light_accum);//Jon No, we already acounted for this!// * ambient_occlusion;	//TODO why is there a double ambient_occlusion multiply?!
}

vec3 global_lights(in vec3 wn, in vec3 view_pos, in vec3 Albedo, in float Metalness, in float Roughness, bool dossr)
{
	return global_lights(wn, view_pos, Albedo, Metalness, Roughness, dossr, vec4(0));
}

#include <common_envmap.h>

#if SHADERFLAGS & SHADERFLAG_FORWARD_ENVMAP_PROBES

// // #define GLASS_PROBE_BLENDING_DEBUG /* def or ndef */
// WARNING also uncomment the undef below for safety

vec4 global_envmap_resolve_glass(vec3 wn, vec3 wv, float Roughness, float shadow)
{
	//TODO @Timon/Florian the below sampling math seems "a bit sketchy" and has somewhat specific to the glass shader,
	// would be nice to generalize it into multiple functions, at least one with proper math? further and do the proper math if we ever have a use-case for it?
	vec3 wpos = GetFragWorld();
	half3 R = reflect(-wv, wn);
	vec4 env = vec4(0);
#ifdef GLASS_PROBE_BLENDING_DEBUG
	vec3 col = vec3(0);
#endif
	for (uint i = 0; i < U_envmapprobe_num; ++i) {
		// spec str,rgb vs luminosity, aka bright areas reflect more than dark, "shiny" also reflect more -> spec str?
		//ColorEnvi.rgb += S_environmentstr * textureLod/*texCUBE*/(T_ibl_envmap, R_Eye,Roughness*MaxSpecularLevel(T_ibl_envmap)).rgb * ((saturate(1.0f-pow(dot(Normal,VertexToEye),0.5f))+0.1)/1.1f)*(1.0-ColorBaseDiffuse.a);
		vec3 r = R;
		r = EnvMapAdjust(i, wpos, r);
		vec4 e = textureLod(S_environment_map[i], r, Roughness * MaxSpecularLevel(S_environment_map[i]) + 0.50); //TODO darkening, etc?? like for dirt border
		float fade = EnvMapFading(i);
		e *= fade;
		// only multiply rgb here, so we still block the cluster envmap from shining through geometry
		e.rgb *= U_envmapprobe_insideglassfadein;

#ifdef GLASS_PROBE_BLENDING_DEBUG
		col += V_envmapprobe_color[i].rgb * fade * (1 - env.a);
#endif
		// e.a = 1; return e;
		env += e * (1 - env.a);
	}
#ifdef GLASS_PROBE_BLENDING_DEBUG
	DebugStore(vec4(col, 0.2f));
#endif
	{
		vec4 e = textureLod(T_ibl_envmap, R, Roughness * MaxSpecularLevel(T_ibl_envmap) + 0.50) * shadow; //TODO darkening, etc?? like for dirt border
		e.rgb *= U_envmapprobe_insideglassfadein;
		env += e * (1 - env.a);
	}
	return env;
}

// #undef GLASS_PROBE_BLENDING_DEBUG

#endif

//#extension GL_ARB_shading_language_420pack : enable // not supported on OSX (10.10.4)

/*useful pragmas for nvidia
#pragma optionNV(fastmath on)
#pragma optionNV(fastprecision on)
#pragma optionNV(ifcvt none)
#pragma optionNV(inline all)
#pragma optionNV(strict on)
#pragma optionNV(unroll all)
#pragma optionNV(inline all)
*/

#define D_DYNAMIC 1
#define D_STATIC 2
#define D_SPECIAL 3

#define X_CONCAT(a,b) a##b

// #define centroid /*centroid*/	//workaround for RADV:/


	#define VK_BLOCK(name,block)			\
		layout(set = ENUM_BUFFER_##name, binding = 0, std140) uniform BUFFER_##name			\
		{			\
			block			\
		};


#ifdef XIMGUI
	#define I_HATE_MACROS			\
		uniform mat4 DEBUG_Matrix0;			\
		uniform mat4 DEBUG_Matrix1;			\
		uniform vec4 DEBUG_Vector0;			\
		uniform vec4 DEBUG_Vector1;			\
		uniform vec4 DEBUG_Vector2;			\
		uniform vec4 DEBUG_Vector3;			\
		uniform float DEBUG_Float0;			\
		uniform float DEBUG_Float1;			\
		uniform float DEBUG_Float2;			\
		uniform float DEBUG_Float3;			\
		uniform int DEBUG_Int0;				\
		uniform int DEBUG_Int1;				\
		uniform int DEBUG_Int2;				\
		uniform int DEBUG_Int3;
#else
	#define I_HATE_MACROS
#endif
	
VK_BLOCK(CAMERA,
	uniform mat4 M_view;
	uniform mat4 M_projection;
	uniform mat4 M_invprojection;
	uniform mat4 M_viewprojection;
	uniform mat4 M_viewinverse;
	
	uniform mat4 M_shadowCSM0Clip;
	uniform mat4 M_shadowCSM1Clip;
	
	uniform vec4 V_viewportpixelsize/* = vec4(1024, 768, 3, 5000000)*/;
	uniform vec4 V_cameraposition;
	
	uniform vec4 V_ambient1;

	uniform vec4 V_direction1;
	uniform vec4 V_lightcolor1;
	uniform vec4 V_direction2;
	uniform vec4 V_lightcolor2;
	uniform vec4 V_direction3;
	uniform vec4 V_lightcolor3;

	uniform vec4 V_light_direction_view[3];
	
	uniform vec4 V_tintcolor;			//for tinted_glass: DEF_AUTO_PARA(BlendColor	, TINTCOLOR				, float3	, {1.0, 1.0, 1.0})

	uniform vec4 V_csmthresholds;
	
	
	uniform vec4 V_volume_range;
	uniform vec4 V_volume_size;
	
	uniform vec4 V_volume_scatter_power[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_sigma_extinction[GFX_MAX_VOLUME_TYPES];
	
	uniform vec4 V_volume_phase0_param[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_phase1_param[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_phase2_param[GFX_MAX_VOLUME_TYPES];
	
	uniform ivec4 I_volume_phases[GFX_MAX_VOLUME_TYPES];
/*	uniform int I_volume_phase_num[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase0[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase1[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase2[GFX_MAX_VOLUME_TYPES];*/
	
/*	uniform vec4 V_volume_type0_scatter_power;
	uniform vec4 V_volume_type0_sigma_extinction;
	
	uniform vec4 V_volume_type0_phase0_param;
	uniform vec4 V_volume_type0_phase1_param;
	uniform vec4 V_volume_type0_phase2_param;
	
	uniform vec4 V_volume_type1_scatter_power;
	uniform vec4 V_volume_type1_sigma_extinction;
	
	uniform vec4 V_volume_type1_phase0_param;
	uniform vec4 V_volume_type1_phase1_param;
	uniform vec4 V_volume_type1_phase2_param;
	
	uniform vec4 V_volume_type2_scatter_power;
	uniform vec4 V_volume_type2_sigma_extinction;
	
	uniform vec4 V_volume_type2_phase0_param;
	uniform vec4 V_volume_type2_phase1_param;
	uniform vec4 V_volume_type2_phase2_param;*/
	
	uniform float F_globallightscale;
	uniform float F_locallightscale;
	uniform float F_time;
	uniform float F_framedeltatime;
	uniform float F_exposure;			//DEF_AUTO_PARA(Exposure, EXPOSURE, float, (0.5))
	uniform float F_ibl_maxvalidlevel;

	uniform float F_csm_blendstrength;
	uniform float F_shadowmapsize; // used for kernel width adjustment
	uniform float F_shadowmaxdistance;		//DEF_AUTO_PARA(ShadowMaxDist	, SHADOWMAXDISTANCE			, float		, {5000.0})
	//I think F_shadowbias, F_shadowtexelbias, F_shadowmaxdistance is never set,
	// and F_shadowmapsize is never used...
	// F_shadowmaxdistance is set according to videoparameters
	uniform bool B_csmpcfenabled;
	uniform float F_texturefactorCSM0;
	uniform float F_texturefactorCSM1;
	uniform float F_texturefactorCSM2;
	uniform float F_texturefactorCSM3;
	uniform float F_texturefactorCSM4;

	uniform bool B_ssao_enabled;
	uniform bool B_lighting;
	
	uniform bool B_csmdebugcolor;
	
	uniform bool B_shadow;
	
	uniform float F_volume_off;
	uniform float F_volume_scale;

	uniform bool B_pom_enabled;
	uniform float F_pom_minlayers;
	uniform float F_pom_maxlayers;
	
	I_HATE_MACROS
)

#undef I_HATE_MACROS

#ifdef GFX_VULKAN
	layout(constant_id = 2) const bool B_deferred_draw = false;
	layout(constant_id = 3) const int I_instancetype = VERTEXTYPE_ENUMSIZE;
	
#ifdef GFX_EXTENDEDVDATA
	VK_BLOCK(WORLD,
		uniform mat4 M_worldviewprojection;
		uniform mat4 M_world;
		
		uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
		uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
		uniform mat4 M_shadowCSM2;
		uniform mat4 M_shadowCSM3;
		uniform mat4 M_shadowCSM4;
		
		uniform vec4 V_blendcolor;
		uniform float F_alphascale;
		uniform bool B_packedtangentframe;
		uniform bool B_vertexdata0;
		uniform bool B_vertexdata1;
		uniform bool B_vertexdata2;
		uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)
	)
#else
	VK_BLOCK(WORLD,
		uniform mat4 M_worldviewprojection;
		uniform mat4 M_world;

		uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
		uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
		uniform mat4 M_shadowCSM2;
		uniform mat4 M_shadowCSM3;
		uniform mat4 M_shadowCSM4;

		uniform vec4 V_blendcolor;
		uniform float F_alphascale;
		uniform bool B_packedtangentframe;
		uniform bool B_vertexdata0;
		uniform bool B_vertexdata1;
		uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)
	)
#endif

/*	layout(push_constant) uniform BUFFER_PC
	{
		mat4 worldviewprojection;
		mat4 world;
	}PC;
	#define M_worldviewprojection PC.worldviewprojection
	#define M_world PC.world*/
#else
	uniform mat4 M_worldviewprojection;
	uniform mat4 M_world;
	
	uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
	uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
	uniform mat4 M_shadowCSM2;
	uniform mat4 M_shadowCSM3;
	uniform mat4 M_shadowCSM4;
	
	// uniform mat4 M_worldview; // these two will be needed for proper view space lighting
	// uniform mat4 M_worldviewinversetranspose;
	uniform vec4 V_blendcolor;
	uniform float F_alphascale;
	uniform bool B_packedtangentframe;
	uniform bool B_vertexdata0;
	uniform bool B_vertexdata1;
#ifdef GFX_EXTENDEDVDATA
	uniform bool B_vertexdata2;
#endif
	uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)

	uniform bool B_deferred_draw;			// set whenever a deferred shader is called in a deferred way
	
	uniform int I_instancetype = VERTEXTYPE_ENUMSIZE;//TODO @Timon if we ever implement it in OGL it should be specialized
	
	D_shadow_QUAL bool B_shadow = D_shadow_VALUE;
	
	#if D_alpha_test == D_DYNAMIC
	uniform bool B_alpha_test = false;		//for alpha-testing
	#elif D_alpha_test == D_SPECIAL
	const bool B_alpha_test = D_alpha_test_VALUE;
	//#define B_alpha_test D_alpha_test_VALUE
#endif

#endif

layout(set = ENUM_BUFFER_DYNAMIC, binding = 0, std140) uniform BUFFER_DYNAMIC
{
uniform mat4 M_texturematrix0;
uniform mat4 M_texturematrix1;
uniform mat4 M_texturematrix2;
uniform mat4 M_texturematrix3;
uniform bool B_textureanimation;

#define B_vertexcolorsrgb true

//for luminance
uniform float F_eyeadaptionspeed;	// DEF_AUTO_PARA(EyeAdaptionSpeed, EYEADAPTIONSPEED, float, 0.9)


//for SSAO
uniform vec4 V_frustumsize;			//DEF_AUTO_PARA(FrustumSize		, FRUSTUMSIZE		, float4	, {1.0, 1.0, 0.0, 0.0})

//for tonemap
//DEF_AUTO_PARA(ScreenLuminance, LUMINANCE, float4, (0,0,0,0))
uniform bool B_srgbout;			//DEF_AUTO_PARA(SRGBOut, SRGBOUT, bool, false)
uniform vec4 V_textureviews;	//DEF_AUTO_PARA(TextureViews, TEXTUREVIEWS, float4, {1280.0, 720.0, 1280.0, 720.0})

//#ifdef PROJECT_XR
uniform float F_lutblend;		//DEF_AUTO_PARA(ColorLUTBlend, DIFFUSE_SCALE, float, (0.0))
//#endif

#if SHADERFLAGS & SHADERFLAG_FORWARD_ENVMAP_PROBES
uniform vec4 V_envmapprobe_shape[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_color[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform mat4 M_envmapprobe_world[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform mat4 M_envmapprobe_world_rot[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_volumeoffset[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_fadein[GFX_MAX_FORWARD_ENVMAP_PROBES];
#else
uniform mat4 M_envmapprobe_world;
uniform mat4 M_envmapprobe_world_rot;
uniform vec4 V_envmapprobe_volumeoffset;
uniform vec4 V_envmapprobe_shape;
#endif

DPREDEF_BUFFER_DYNAMIC

#if defined(CHROMATIC_ABERRATION) && defined(GFX_CHROMA_SAMPLES)
	uniform vec4 V_color[GFX_CHROMA_SAMPLES];
#endif

#ifdef BONE_MATRICES
	//TODO @Timon/Florian this and actually most of these should be refactored to .ogl if/when possible
	//although given how many and common they are, it seems necessary to also extend .ogl handling to allow including files or something
	// (to group common param sets into separate files)
	uniform mat4 M_boneworld[50];		//float4x4 mBone0[50] : BONEWORLD0;
	// TODO: P1 specific stuff
#endif
	
#ifdef VOLUME_POINT
	#define VOLUME_POINT_NUM 32	//ALSO defined in renderframe.cpp
// 	uniform vec4 V_point_pos[VOLUME_POINT_NUM];
	uniform mat4 M_offset[VOLUME_POINT_NUM];
	uniform vec4 V_scale[VOLUME_POINT_NUM];
	uniform int I_index[VOLUME_POINT_NUM];
	#ifndef VOLUME_POINT_FULL
	uniform int I_point_num;
	#endif
#endif
	
};


#ifdef GFX_VULKAN
layout(set = ENUM_BUFFER_MATERIAL, binding = 0, std140) uniform BUFFER_MATERIAL
#else
/*layout(binding = ENUM_BUFFER_EXTRA)*/ uniform BUF_material
#endif
{
#ifdef OCULUS_SHADER
	#define MAX_LAYER_COUNT 8

	vec4 baseColor;
	int baseMaskType;
	vec4 baseMaskParameters;
	vec4 baseMaskAxis;
	vec4 alphaMaskScaleOffset;
	vec4 normalMapScaleOffset;
	vec4 parallaxMapScaleOffset;
	vec4 roughnessMapScaleOffset;

	mat4 projectorInv;

//	bool useAlpha;
//	bool useNormalMap;
//	bool useRoughnessMap;
	bool useProjector;
	float elapsedSeconds;

	int layerCount;

	int layerSamplerModes[MAX_LAYER_COUNT];
	int layerBlendModes[MAX_LAYER_COUNT];
	int layerMaskTypes[MAX_LAYER_COUNT];
	vec4 layerColors[MAX_LAYER_COUNT];
	vec4 layerSurfaceScaleOffsets[MAX_LAYER_COUNT];
	vec4 layerSampleParameters[MAX_LAYER_COUNT];
	vec4 layerMaskParameters[MAX_LAYER_COUNT];
	vec4 layerMaskAxes[MAX_LAYER_COUNT];
	
/*	sampler2D alphaMask;
	sampler2D normalMap;
	sampler2D parallaxMap;
	sampler2D roughnessMap;
	sampler2D layerSurfaces[MAX_LAYER_COUNT];*/
#endif
	DPREDEF_BUFFER_MATERIAL
};

float epsilon = 0.000001f;

//TODO @Timon especially with AA we get NaNs at edges of transparent draws (mostly simple_hdr_out, lightcone) this seems to be mostly due to TO_linearRGB calls
//#define pow(x,y)	pow(max((x),0) + HALF3_SMALL_NUMBER, (y))


#define BGDIST (2000000.0f)
#define BGZ (1.0f / BGDIST)

#define PI (3.141592654f)
#define EUL (2.718281828459f)

#define mul(a,b) ((b) * (a))

vec2 SIGNED(vec2 v)
{
	return (v * 2.0) - 1.0;
}
vec3 SIGNED(vec3 v)
{
	return (v * 2.0) - 1.0;
}
/*
vec4 UNSIGNED(vec4 v)
{
	return (v * 0.5) + 0.5;
*/
vec4 SIGNED(vec4 v)
{
	return (v * 2.0) - 1.0;
}
#define SIGNED_pp SIGNED

float clip2uv(float v)
{
	v += 1;
	v /= 2;
	return v;
}
float uv2clip(float v)
{
	v *= 2;
	v -= 1;
	return v;
}
vec2 clip2uv(vec2 v)
{
	v += vec2(1);
	v /= vec2(2);
	return v;
}
vec2 uv2clip(vec2 v)
{
	v *= vec2(2);
	v -= vec2(1);
	return v;
}
vec3 clip2uv(vec3 v)
{
	v += vec3(1);
	v /= vec3(2);
	return v;
}
vec3 uv2clip(vec3 v)
{
	v *= vec3(2);
	v -= vec3(1);
	return v;
}

vec3 clipZ2uv(vec3 v)
{
	v.xy += vec2(1);
	v.xy /= vec2(2);
	return v;
}
vec3 uv2clipZ(vec3 v)
{
	v.xy *= vec2(2);
	v.xy -= vec2(1);
	return v;
}

vec3 clip2view(vec3 cs)
{
	vec4 p = M_invprojection * vec4(cs, 1);
	return p.xyz / p.w;
}

#ifdef GFX_OGL
	#define DEFAULT_TES_WINDING ccw
#else
	#define DEFAULT_TES_WINDING cw
#endif

/*
Unfortunately there are issues with const:
- glsl < 4.2 has different meaning for const
- amd-vulkan crashes weirdly,	e.g.
	scaleMat(const) is fine
	make_ColorMatrix(any param const) crashes
*/
#define CONST /*const*/
#define _IF if

#define tex2D texture
#define tex1D texture
#define tex2Dproj textureProj
#define tex2Dlod textureLod
#define tex3D texture
#define float2 vec2
#define float3 vec3
#define float4 vec4

#define half float
#define half2 vec2
#define half3 vec3
#define half4 vec4

#define float3x3 mat3
#define float4x4 mat4

float saturate(float v) {
	return clamp(v, 0, 1);
}
float2 saturate(float2 v) {
	return clamp(v, 0, 1);
}
float3 saturate(float3 v) {
	return clamp(v, 0, 1);
}
float4 saturate(float4 v) {
	return clamp(v, 0, 1);
}

float saturate0(float v)	{ return max(v, 0); }
vec2 saturate0(vec2 v)		{ return max(v, 0); }
vec3 saturate0(vec3 v)		{ return max(v, 0); }
vec4 saturate0(vec4 v)		{ return max(v, 0); }

float maxvec(vec2 v)
{
	return max(v.r, v.g);
}
float maxvec(vec3 v)
{
	return max(maxvec(v.rg), v.b);
}
float maxvec(vec4 v)
{
	return max(maxvec(v.rgb), v.a);
}

#define lerp(x,y,s)	mix(x,y,s)
#define frac fract

#define pow2(val) ((val) * (val))
#define dotself(val) dot((val), (val))

#define HALF_SMALL_NUMBER (0.00001)
#define HALF3_SMALL_NUMBER half3(HALF_SMALL_NUMBER, HALF_SMALL_NUMBER, HALF_SMALL_NUMBER)

#define FLOAT_SMALL_NUMBER (0.000000001)

// simple sRGB color conversion with 2.2f NOTE: preserve alpha
half3 TO_sRGB(CONST half3 inColor)
{
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(1.0/2.2)));
}

half4 TO_sRGB(CONST half4 inColor)
{
	return half4(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(1.0/2.2)), inColor.a);
}

half TO_linearRGB(CONST half inColor)
{
	return pow(inColor + HALF_SMALL_NUMBER, 2.2);
}

half3 TO_linearRGB(CONST half3 inColor)
{
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, vec3(2.2)));
}

half4 TO_linearRGB(CONST half4 inColor)
{
	return half4(pow(inColor.rgb + HALF3_SMALL_NUMBER, vec3(2.2)), inColor.a);
}

half3 D3DCOLOR_X_TO_linearRGB_HDR(CONST half4 inColor)
{
	//return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, 2.2) * inColor.a * LIGHTINTENSITY_SCALE);
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(2.2)) );
}

float fresnel(CONST float3 V, CONST float3 N, CONST half Power)
{
	return (pow(1-abs(dot(V, N)), Power));    // note: abs() makes 2-sided materials work
}

//--- Color Correction matrix math ---

float4x4 scaleMat(CONST float s)
{
	return float4x4(
		s, 0, 0, 0,
		0, s, 0, 0,
		0, 0, s, 0,
		0, 0, 0, 1);
}
float4x4 scaleMat(CONST vec3 s)
{
	return float4x4(
		s.x, 0, 0, 0,
		0, s.y, 0, 0,
		0, 0, s.z, 0,
		0, 0, 0, 1);
}

float4x4 translateMat(CONST float3 t)
{
	return float4x4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		t, 1);
}

float4x4 saturationMat(CONST float s)
{ 
	CONST float rwgt = 0.3086;
	CONST float gwgt = 0.6094;
	CONST float bwgt = 0.0820;

	return float4x4(
		(1.0-s)*rwgt + s,	(1.0-s)*rwgt,  		(1.0-s)*rwgt,		0,
		(1.0-s)*gwgt, 		(1.0-s)*gwgt + s, 	(1.0-s)*gwgt,		0,
		(1.0-s)*bwgt,    	(1.0-s)*bwgt, 		(1.0-s)*bwgt + s,	0,
		0.0, 0.0, 0.0, 1.0);
}

float4x4 rotateMat(float3 d, CONST float ang)
{
	float s = sin(ang);
	float c = cos(ang);
	d = normalize(d);
	return float4x4(
		d.x*d.x*(1 - c) + c,		d.x*d.y*(1 - c) - d.z*s,	d.x*d.z*(1 - c) + d.y*s,	0,
		d.x*d.y*(1 - c) + d.z*s,	d.y*d.y*(1 - c) + c,		d.y*d.z*(1 - c) - d.x*s,	0, 
		d.x*d.z*(1 - c) - d.y*s,	d.y*d.z*(1 - c) + d.x*s,	d.z*d.z*(1 - c) + c,		0, 
		0, 0, 0, 1 );
}

mat4x3 make_ColorMatrix(CONST float inBrightness,CONST float inContrast,CONST float inSaturation,CONST float inHue)
{
	// construct color matrix

	// brightness - scale around (0.0, 0.0, 0.0)
	float4x4 brightnessMatrix = scaleMat(inBrightness);

	// contrast - scale around (0.5, 0.5, 0.5)
	float4x4 contrastMatrix = translateMat(vec3(-0.5));
	contrastMatrix = mul(contrastMatrix, scaleMat(inContrast) );
	contrastMatrix = mul(contrastMatrix, translateMat(vec3(0.5)) );

	// saturation
	float4x4 saturationMatrix = saturationMat(inSaturation);

	// hue - rotate around (1, 1, 1)
	float4x4 hueMatrix = rotateMat(float3(1, 1, 1), radians(inHue));

	// composite together matrices
	float4x4 m;
	m = brightnessMatrix;
	m = mul(m, contrastMatrix);
	m = mul(m, saturationMatrix);
	m = mul(m, hueMatrix);

	return mat4x3(m);
}

vec3 GetRGBBox(vec3 ray)
{
	ray = normalize(ray);
	vec3 mag = abs(ray);
	if (mag.r > mag.g && mag.r > mag.b) {
		if (ray.r >= 0)
			return vec3(1, 0, 0);
		else
			return vec3(0, 1, 1);
	}
	if (mag.g > mag.r && mag.g > mag.b) {
		if (ray.g >= 0)
			return vec3(0, 1, 0);
		else
			return vec3(1, 0, 1);
	}
	if (mag.b > mag.r && mag.b > mag.g) {
		if (ray.b >= 0)
			return vec3(0, 0, 1);
		else
			return vec3(1, 1, 0);
	}
	return vec3(0);
}


float random( float2 p )
{
  // We need irrationals for pseudo randomness.
  // Most (all?) known transcendental numbers will (generally) work.
  CONST float2 r = float2(
    23.1406926327792690,  // e^pi (Gelfond's constant)
     2.6651441426902251); // 2^sqrt(2) (Gelfond?Schneider constant)
  return frac( cos( /*f*/mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  //was 256.
}

float square(in float val)
{
	return val*val;
}

bool IsOutsideUV(float uv)
{
	return uv < 0 || uv > 1;
}

bool IsInsideUV(vec2 uv)
{
	return all(greaterThanEqual(uv, vec2(0))) && all(lessThanEqual(uv, vec2(1)));
}
bool IsOutsideUV(vec2 uv)
{
	return any(lessThan(uv, vec2(0))) || any(greaterThan(uv, vec2(1)));
}

vec4 Project(in vec4 val)
{
	val = M_projection * val;
	return val / val.w;
}
vec4 UnProject(in vec4 val)
{
	val = M_invprojection * val;
	return val / val.w;
}

vec3 Project(in vec3 val)
{
	vec4 tmp = M_projection * vec4(val, 1);
	return tmp.xyz / tmp.w;
}
vec3 UnProject(in vec3 val)
{
	vec4 tmp = M_invprojection * vec4(val, 1);
	return tmp.xyz / tmp.w;
}

vec3 view2world(in vec3 val)
{
	return (M_viewinverse * vec4(val, 1)).xyz;
// 	vec4 tmp = M_viewinverse * vec4(val, 1);
//	return tmp.xyz / tmp.w;
}
vec3 view2world_rot(in vec3 val)
{
	return mat3(M_viewinverse) * val;
}

vec3 world2view(in vec3 val)
{
	return (M_view * vec4(val, 1)).xyz;
}
vec3 world2view_rot(in vec3 val)
{
	return mat3(M_view) * val;
}


vec3 pix2volume(ivec3 pix)
{
	return pix / (V_volume_size.xyz - 1);
}
ivec3 volume2pix(vec3 uv)
{
	return ivec3(uv * (V_volume_size.xyz - 1));
}

/*
vec3 proj2volume(vec3 cs)
{
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}
vec3 volume2proj(vec3 uv)
{
	vec3 cs = uv2clipZ(uv);
// 	cs.z = 1 - cs.z;//flip for intuition
// 	cs.z *= 0.5;
// 	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
// 	cs.z = pow(cs.z, 2);
	cs.z *= F_volume_scale;
	cs.z += F_volume_off;
	return cs;
}*/

const float volume_near_scale = 1.0f;
const float volume_dist_scale = 1000.0f;

#define VOLUME_DIST_GODRAYS_LAYERS 1

const float volume_fom_min = 6000.0f;
// const float volume_fom_min = 0.0f;
const float volume_fom_max = 60000.0f;

#ifdef VOLUME_SHAD

#define VOLUME_SHAD_MARGIN /*def or ndef*/
#ifdef VOLUME_SHAD_MARGIN
	const float shvol_margin = 0.01;
#endif

const int shvol_offsets_num = 5;
const float shvol_offsets[shvol_offsets_num] = { 0, 0.63, 0.1, 0.32, 0.85 };

/*vec3 volume2shvol(vec3 uv)
{
	uv.xy += shvol_margin;
	uv.xy /= 1 + 2 * shvol_margin;
	return uv;
}
vec3 shvol2volume(vec3 uv)
{
	uv.xy *= 1 + 2 * shvol_margin;
	uv.xy -= shvol_margin;
	return uv;
}*/

float shvol_zoffset(ivec3 pix, int idx)
{
	if (idx >= 0 /*&& uv.z >= 1.0f / V_volume_size.z/**/) {
// 		idx /= 7;
// 		idx += pix.x + pix.y;
// 		idx += pix.x + int(V_volume_size.x) * pix.y;
// 		idx += pix.y + int(V_volume_size.y) * pix.x;
// 		idx = int(random(vec2(idx)) * shvol_offsets_num);
// 		idx = int(random(vec2(idx) + vec2(pix.xy)) * shvol_offsets_num);
// 		idx = int(random(vec2(idx) / 7 + vec2(pix.xy)) * (shvol_offsets_num - 1));
		idx %= shvol_offsets_num;
		return shvol_offsets[idx] / V_volume_size.z;
	}
	return 0;
}

vec3 volume2shvol(vec3 uv, ivec3 pix, int idx)
{
#ifdef VOLUME_SHAD_MARGIN
	uv.xy += shvol_margin;
	uv.xy /= 1 + 2 * shvol_margin;
#endif
	uv.z += shvol_zoffset(pix, idx);
	return uv;
}
vec3 volume2shvol(vec3 uv, ivec3 pix)
{
	return volume2shvol(uv, pix, U_offset);
}
vec3 volume2shvolPrev(vec3 uv, ivec3 pix)
{
	return volume2shvol(uv, pix, U_offset - 1);
}

vec3 shvol2volume(vec3 uv, ivec3 pix)
{
// 	return uv;
#ifdef VOLUME_SHAD_MARGIN
	uv.xy *= 1 + 2 * shvol_margin;
	uv.xy -= shvol_margin;
#endif
	uv.z -= shvol_zoffset(pix, U_offset);
	return uv;
}
#endif

float view2volume(float z)
{
	z = 0.1f / z; //TODO @Timon camera near-dist
	z -= F_volume_off;
	z /= F_volume_scale;
	z = sqrt(z);
	return z;
}
float volume2view(float z)
{
	z *= z;
	z *= F_volume_scale;
	z += F_volume_off;
	z = 0.1f / z; //TODO @Timon camera near-dist
	return z;
}


vec3 view2volume(vec3 vp)
{
	vec3 cs = Project(vp);
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
	cs.z = sqrt((cs.z));
// 	cs.z = sqrt(abs(cs.z));
// 	cs.z = pow(cs.z, 1.0f/2.0f);
// 	cs.z = pow(cs.z, 1.0f/4.0f);
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}
vec3 volume2view(vec3 uv)
{
	vec3 cs = uv2clipZ(uv);
// 	cs.z = 1 - cs.z;//flip for intuition
// 	cs.z *= 0.5;
	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
// 	cs.z = pow(cs.z, 2.0f);
// 	cs.z = pow(cs.z, 4.0f);
	cs.z *= F_volume_scale;
	cs.z += F_volume_off;
	vec3 view = UnProject(cs);
	return view;
}

vec3 view2volume_linear(vec3 vp)
{
	vec3 cs = Project(vp);
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
	cs.z = sqrt((cs.z));
// 	cs.z = sqrt(abs(cs.z));
// 	cs.z = pow(cs.z, 1.0f/2.0f);
// 	cs.z = pow(cs.z, 1.0f/4.0f);
	
	cs.xy -= cs.xy * vec2(1.0f / V_volume_size.xy);//compensate for difference to between texel addressing and linear texture filtering
	cs.z -= uv2clip(cs.z) * 0.5f / V_volume_size.z;
	
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}

vec3 volume_cellsize(vec3 uv)//TODO @Timon optimize, if needed with a precomputed matrix or something
{
	vec3 v0 = volume2view(uv);
	uv.xy += 1.0f / V_volume_size.xy;
	uv.z -= 1.0f / V_volume_size.z;
	vec3 v1 = volume2view(uv);
	return v1 - v0;
}

float cellsize_fadefactor(vec3 cellsize, float size)
{
// 	float fade = saturate(size * 0.5f - length(cellsize));
	float fade = saturate(size * 0.5f - cellsize.z);
	return fade;
}

float volume_getfadefactor(float viewz, float size)
{
/*	z = 0.1f / z; //TODO @Timon camera near-dist
	z -= F_volume_off;
	z /= F_volume_scale;
	z = sqrt(z);
	
	z -= 1.0f / V_volume_size.z;
	
	z *= z;
	z *= F_volume_scale;
	z += F_volume_off;
	z = 0.1f / z; //TODO @Timon camera near-dist
	/**/
// 	return 0.0;
	float n = 800 * size / 200;
	float f = 1400 * size / 200;
	n = min(n, V_volume_range[1] - min(size, V_volume_range[1] / 4));
	f = min(f, V_volume_range[1]);
	return smoothstep(n, f, viewz);
	
// 	float step = V_volume_range[1] - V_volume_range[0];
// 	step /= V_volume_size.z;
// 	float far = size;
// 	return smoothstep(, viewz);
/*	float volz = view2volume(viewz);
	volz -= 1.0f / V_volume_size.z;
	float nviewz = volume2view(volz);
	
	float dist = 0.1 / (0.1 / viewz + F_volume_scale / pow2(V_volume_size.z));	return saturate(size * 0.5 - abs(dist));
	
	return saturate(size * 0.5 - abs(nviewz - viewz));/**/
// 	return fade;
}

//-------------------------------------------------------------------------------
// Lighting/Shadow defines ( used in vertex + pixel shaders )
//-------------------------------------------------------------------------------

#define USE_TEXTURE_LIGHTING /**/
#define DEF_LIGHT_AMBIENT(_NR) /**/
#define DEF_LIGHT_DIR(_NR) /**/

#define B_material_override false
#define B_globallight_tonemap true
#define V_matparams vec4(0.5f)
#define V_deferred_lightparams vec4(1)
#define F_arealightcutoff 0.001f

#ifdef PROJECT_XR
	#define XR_TO_linearRGB(val)	TO_linearRGB(val)
#else
	#define XR_TO_linearRGB(val)	(val)
#endif

#include <../../extensions/X4FoundationShaderMod-main/shadergl/shaders/jm_includes/jm_defines.h>
#include <../../extensions/X4FoundationShaderMod-main/shadergl/shaders/jm_includes/jm_util_functions.h>
#define SHADOWMAP_SIZE 4096.0f
//#define SHADER_BIAS
float GetShadowSoft(sampler2D shadowmap, float4 coords)
{
	coords.xyz /= coords.w;
//	coords.y = 1.0 - coords.y;
	float2 coordfloor = floor(coords.xy * SHADOWMAP_SIZE) / SHADOWMAP_SIZE;
	float Shadow = 0.0f;
	int iterations =  7;
	float offset = 1.0f / 2048.0f;
	/*[unroll]*/ for (int i = -3; i <= 3; ++i)
	{
		/*[unroll]*/ for (int j = -3; j <= 3; ++j)
		{
			
			float2 coord = float2(i*offset,j*offset); 
			Shadow +=  tex2D(shadowmap, coordfloor.xy + coord).x < coords.z ? 0.0 : 1.0;
		}
	}
	Shadow /= float(iterations*iterations);
	return Shadow;
}

float GetShadowSimple(sampler2D shadowmap, float4 coords)
{
	CONST int OFFSET_COUNT = 4;
	CONST float RECIPROCAL_OFFSET_COUNT = 1.0 / OFFSET_COUNT;
#if 0//requires GL_ARB_shading_language_420pack
	float2 offsets[] = { float2(-0.5, -0.5), float2(0.5, -0.5), float2(-0.5, 0.5), float2(0.5, 0.5) };
#else
	float2 offsets[4];
	offsets[0] = float2(-0.5, -0.5);
	offsets[1] = float2(0.5, -0.5);
	offsets[2] = float2(-0.5, 0.5);
	offsets[3] = float2(0.5, 0.5);
#endif
	float4 results;
	
	float shadow = 1.0;
	
	coords.xyz /= coords.w;
//	coords.y = 1.0 - coords.y;

//	return tex2D(shadowmap, coords.xy).r < coords.z ? 0.0 : 1.0;
	
	float2 coordfloor = floor(coords.xy * SHADOWMAP_SIZE) / SHADOWMAP_SIZE;
	results.x = tex2D(shadowmap, coordfloor.xy).x < coords.z ? 0.0 : 1.0;
	results.y = tex2D(shadowmap, coordfloor.xy + float2(1.0, 0.0) / SHADOWMAP_SIZE).x < coords.z ? 0.0 : 1.0;
	results.z = tex2D(shadowmap, coordfloor.xy + float2(0.0, 1.0) / SHADOWMAP_SIZE).x < coords.z ? 0.0 : 1.0;
	results.w = tex2D(shadowmap, coordfloor.xy + float2(1.0, 1.0) / SHADOWMAP_SIZE).x < coords.z ? 0.0 : 1.0;

	float2 f = frac(coords.xy * SHADOWMAP_SIZE);
	float2 yinter = lerp(results.xz, results.yw, f.x);
	return lerp(yinter.x, yinter.y, f.y);
}


// no PCF, could be used for furthest cascades
float GetCSMSampleFast(sampler2DShadow shadowmap, vec3 coords)
{
	// float2 coordfloor = floor(coords.xy * F_shadowmapsize) / F_shadowmapsize;
	// return texture(shadowmap, coordfloor.xyz +vec3(coordfloor.xy, coords.z + CSM_BIAS));
	return texture(shadowmap, coords);
}

float GetCSMSampleHard(sampler2DShadow shadowmap, vec3 coords)
{
	return 1.0f-step(texture(shadowmap, coords), 0.0f);
	// return 1.0f-step(textureProj(shadowmap, vec4(coords.xy, coords.z + CSM_BIAS, coords.z)), 0.0f);
}

float GetCSMSample5Taps(sampler2DShadow shadowmap, vec3 coords)
{
#ifndef D_CSM_SOFT_SHADOWS
	return GetCSMSampleFast(shadowmap, coords);
#else
	// CONST float div = 1000;
	CONST float div = F_shadowmapsize;
	CONST vec2 offsets[] = vec2[](
		float2(-2, -2) / div,
		float2(-2, -1) / div,
		float2(-2,  0) / div,
		float2(-2,  1) / div,
		float2(-2,  2) / div,
		float2(-1, -2) / div,
		float2(-1, -1) / div,
		float2(-1,  0) / div,
		float2(-1,  1) / div,
		float2(-1,  2) / div,
		float2(0,  -2) / div,
		float2(0,  -1) / div,
		float2(0,   0) / div,
		float2(0,   1) / div,
		float2(0,   2) / div,
		float2(1,  -2) / div,
		float2(1,  -1) / div,
		float2(1,   0) / div,
		float2(1,   1) / div,
		float2(1,   2) / div,
		float2(2,  -2) / div,
		float2(2,  -1) / div,
		float2(2,   0) / div,
		float2(2,   1) / div,
		float2(2,   2) / div
	);
	
	float Shadow = 0.0f;
	
	
	for(int i=0; i<25; ++i)
	{
		Shadow += texture(shadowmap, coords + vec3(offsets[i], 0));
	}
	Shadow /= 25.0f;
	return Shadow;
#endif
}

float GetCSMSample3Taps(sampler2DShadow shadowmap, vec3 coords, float texturefactor)
{
#ifndef D_CSM_SOFT_SHADOWS
	return GetCSMSampleFast(shadowmap, coords);
#else
	CONST float kwidth = (1 / (F_shadowmapsize * texturefactor)); // want to stride samples by 2 texels
	CONST vec2 offsets[] = vec2[](
		float2(-1, -1) * kwidth,
		float2(-1,  0) * kwidth,
		float2(-1,  1) * kwidth,
		float2(0,  -1) * kwidth,
		float2(0,   0) * kwidth,
		float2(0,   1) * kwidth,
		float2(1,  -1) * kwidth,
		float2(1,   0) * kwidth,
		float2(1,   1) * kwidth
	);
	
	CONST float weights[] = float[](
		0.077847,
		0.123317,
		0.077847,
		0.123317,
		0.195346,
		0.123317,
		0.077847,
		0.123317,
		0.077847
	);
	
	
	float Shadow = 0.0f;
	
	for(int i=0; i<9; ++i)
	{
		// Shadow += (1.0f/9.0f) * texture(shadowmap, coords.xyz+ vec3(offsets[i], CSM_BIAS));
		Shadow += texture(shadowmap, coords + vec3(offsets[i], 0));
		// Shadow += weights[i] * texture(shadowmap, coords + vec3(offsets[i], 0));
		// Shadow += weights[i] * textureProj(shadowmap, vec4(coords.xyz+ vec3(offsets[i], CSM_BIAS), 1.0f));
	}
	// return Shadow;
	return Shadow / 9.0f;
#endif
}

float GetCSMSample2Taps(sampler2DShadow shadowmap, vec3 coords, float texturefactor)
{
#ifndef D_CSM_SOFT_SHADOWS
	return GetCSMSampleFast(shadowmap, coords);
#else
	CONST float kwidth = (1.0f / (F_shadowmapsize * texturefactor)); // want to stride samples by 2 texels
	
	CONST vec2 offsets[] = vec2[](
		float2(-1, -1) * kwidth,
		float2(-1,  1) * kwidth,
		float2(0,   0) * kwidth,
		float2(1,  -1) * kwidth,
		float2(1,   1) * kwidth
	);
	
	float Shadow = 0.0f;
	for(int i=0; i<5; ++i)
	{
		Shadow += texture(shadowmap, coords.xyz+ vec3(offsets[i], 0));
	}
	Shadow /= 5.0f;
	return Shadow;
#endif
}


float satElemMin3(in vec3 vec)
{
	return saturate(min(vec.x, min(vec.y, vec.z)));
}

struct CSMScaleBias
{
	float epsilon;
	float min;
	float max;
};

CSMScaleBias ScaleBiasCSM[5] = {
	CSMScaleBias(0.005f, 0, 0.0001f),
	CSMScaleBias(0.005f, 0, 0.0002f),
	CSMScaleBias(0.5f, 0, 0.0002f),
	CSMScaleBias(0.0005f, 0, 0.00003f),
	CSMScaleBias(0.00005f, 0, 0.001f),
};

float GetScaleBias(in CSMScaleBias bias, in float ndotl)
{
	float tmpbias;

	tmpbias = bias.epsilon * sqrt(1 - ndotl * ndotl) / ndotl;
	tmpbias = clamp(tmpbias, bias.min, bias.max);

	return tmpbias;
}

// empirical per cascade bias
CONST vec3 biasCSM[5] = {
	vec3(0, 0, -0.003f),
	vec3(0, 0, -0.002f),
	vec3(0, 0, -0.001f),
	vec3(0, 0, -0.0009f),
	vec3(0, 0, -0.0009f), // this one a bit broken
};

// computes per cascade weights based on interpolated tex coords
vec4 getCSMWeights(in vec4 coords[5], in float ndotl)
{
	float ndotle = max(epsilon, ndotl);

	float w = 80/(10.0001-(F_csm_blendstrength-1)*10);
	w = 100000.0f; // no blending for now
	w = 10;
	vec4 ret = vec4(0);//  
	ret[0] = satElemMin3(w*min(coords[0].xyz, -coords[0].xyz + 1));
	ret[1] = satElemMin3(w*min(coords[1].xyz, -coords[1].xyz + 1));
	ret[2] = satElemMin3(w*min(coords[2].xyz, -coords[2].xyz + 1));
	ret[3] = satElemMin3(w*min(coords[3].xyz, -coords[3].xyz + 1));

	for (int i = 0; i < 4; ++i) {
		float factor = 3;
#ifdef SHADER_BIAS
		vec3 coord = coords[i].xyz + biasCSM[i] / ndotle;
		// remap [0,1] to linear pyramid weight with max at f(0.5) = 1
#else
		vec3 coord = coords[i].xyz;
		if (i == 0) {
			coord -= GetScaleBias(ScaleBiasCSM[0], ndotl);
		}
#endif
		vec3 base_weight = 2 * min(coord, -coord + 1);
		vec3 weight;
		weight = factor * base_weight; // linear weight
		//weight = pow(base_weight, vec3(factor)); // exponential weight
		//weight = sqrt(weight);
		ret[i] = satElemMin3(weight);
	}

	//ret[0] = sqrt(ret[0]);
	//ret[1] = sqrt(ret[1]);
	//ret[2] = sqrt(ret[2]);
	//ret[3] = sqrt(ret[3]);
	//ret[0] = sqrt(ret[0]);
	//ret[1] = sqrt(ret[1]);
	//ret[2] = sqrt(ret[2]);
	//ret[3] = sqrt(ret[3]);
	//if(ret[0] > 0.0f) ret[0] = saturate(ret[0]+0.)

	//ret[0] = saturate(ret[0] + 0.95);
	
	// vec3 dir = normalize(IO_world_pos) * mat3(M_shadowCSM1);
	// float t = dot(dir, IO_texshadowCSM1.xyz);
	// if(t > 0.5)
	// ret[1] = 1;
	// ret[1] = satElemMin3(10000*min(IO_texshadowCSM1.xyz, -IO_texshadowCSM1.xyz + 1));
	// ret[1] = saturate(ret[1] + 0.6);
	// ret[1] = min(ret[1], saturate(dot(dir, IO_texshadowCSM1.xyz)));
	
	return ret;
}

vec3 view2csm2(vec3 vp)
{
	return mul(float4(vp, 1), M_shadowCSM2).xyz;
}

#ifndef DISABLE_SHADOW_HELPERS
float Get9Sample25TapGather(sampler2DShadow shadowmap, vec2 coords, float shadow_comparison)
{
	#if 0
		float shadow_sum = 0.0;
		//float shadow_transition_scale = 0.1;//is there an Egosoft value already something along these lines perhaps?
		//this method is actually NOT intended to be run on a sampler2DShadow bur that a reguler sampler2D
		//how about we just try to manually filter it?
		//for(int i = 5;)
		//shadow_comparison = shadow_comparison * shadow_transition_scale - 1.0;
		vec2 texel_pos = coords.xy * F_shadowmapsize - 0.5;
		vec2 sample_fraction = fract(texel_pos);
		vec2 sample_pos = ceil(texel_pos) / F_shadowmapsize;
		
		vec4 gather00 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2(-2, -2));// * shadow_transition_scale - shadow_comparison);
		vec4 gather20 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2( 0, -2));// * shadow_transition_scale - shadow_comparison);
		vec4 gather40 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2( 2, -2));// * shadow_transition_scale - shadow_comparison);
		vec2 sum0;
		sum0 =  gather00.wx * (1.0 - sample_fraction.x);
		sum0 += gather00.zy;
		sum0 += gather20.wx;
		sum0 += gather20.zy;
		sum0 += gather40.wx;
		sum0 += gather40.zy * sample_fraction.x;
		
		shadow_sum += sum0.x * (1.0 - sample_fraction.y) + sum0.y;
		
		vec4 gather02 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2(-2, 0));// * shadow_transition_scale - shadow_comparison);
		vec4 gather22 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2(0, 0));// * shadow_transition_scale - shadow_comparison);
		vec4 gather42 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2(2, 0));// * shadow_transition_scale - shadow_comparison);
		vec2 sum1;
		sum1 =  gather02.wx * (1.0 - sample_fraction.x);
		sum1 += gather02.zy;
		sum1 += gather22.wx;
		sum1 += gather22.zy;
		sum1 += gather42.wx;
		sum1 += gather42.zy * sample_fraction.x;	
		shadow_sum += sum1.x + sum1.y;
		
		vec4 gather04 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2(-2, 2));// * shadow_transition_scale - shadow_comparison);
		vec4 gather24 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2(0, 2));// * shadow_transition_scale - shadow_comparison);
		vec4 gather44 = textureGatherOffset(shadowmap, sample_pos, shadow_comparison, ivec2(2, 2));// * shadow_transition_scale - shadow_comparison);
		vec2 sum2;			
		sum2 =  gather04.wx * (1.0 - sample_fraction.x);
		sum2 += gather04.zy;
		sum2 += gather24.wx;
		sum2 += gather24.zy;
		sum2 += gather44.wx;
		sum2 += gather44.zy * sample_fraction.x;		
		shadow_sum += sum2.x + sum2.y * sample_fraction.y;
		return shadow_sum * 0.04;//*(1.0/25.0)
	#else
		return 1.0;
	#endif
}

float GetCustomCSM(in float ndotl, in vec4 coords[5])
{
	#if 0
		// cascade blending weights
		vec4 weights = getCSMWeights(coords, ndotl);
		float w0 = weights.x;
		float w1 = min(1.0 - weights.x, weights.y);
		float w2 = min(1.0 - weights.y, weights.z);
		float w3 = min(1.0 - weights.z, weights.w);
		float w4 = 1.0 - (weights.w + weights.z + weights.y + weights.x); // recheck this one
		w4 = 1.0 - saturate(w0 + w1 + w2 + w3);
		
		float shadow = 0.0;
		if (w0 > 0.0)
			shadow += w0 * Get9Sample25TapGather(T_shadowCSM0, coords[0].xy, shadow_comparison);
		if (w1 > 0.0)
			shadow += w1 * Get9Sample25TapGather(T_shadowCSM1, coords[1].xy, shadow_comparison);
		if (w2 > 0.0)
			shadow += w2 * Get9Sample25TapGather(T_shadowCSM2, coords[2].xy, shadow_comparison);
		if (w3 > 0.0)
			shadow += w3 * Get9Sample25TapGather(T_shadowCSM3, coords[3].xy, shadow_comparison);
		if (w4 > 0.0)
			shadow += w4 * Get9Sample25TapGather(T_shadowCSM4, coords[4].xy, shadow_comparison);
		
		return shadow;
	#else
		return 1.0;
	#endif
}	
float GetCSMShadow(in float ndotl, in vec4 coords[5])
{
#if D_SHADOW_QUALITY == 0
	return 1.0f;
#else

	float Shadow = 0.0f;
	// z = length(IO_worldview_pos)-5;
	
	// cascade blending weights
	vec4 weights = getCSMWeights(coords, ndotl);
	float w0 = weights.x;
	float w1 = min(1.0f-weights.x, weights.y);
	float w2 = min(1.0f-weights.y, weights.z);
	float w3 = min(1.0f-weights.z, weights.w);
	float w4 = 1.0f - (weights.w + weights.z + weights.y + weights.x); // recheck this one
	w4 = 1 - saturate(w0+w1+w2+w3);
	
	float ndotle = max(epsilon, ndotl);

#define USE_BRANCH

#ifdef USE_BRANCH
	if (w0 > 0.0f)
#endif
#ifdef SHADER_BIAS
		Shadow += w0 * GetCSMSample3Taps(T_shadowCSM0, coords[0].xyz + biasCSM[0] / ndotle, F_texturefactorCSM0);
#else
		Shadow += w0 * GetCSMSample3Taps(T_shadowCSM0, coords[0].xyz - GetScaleBias(ScaleBiasCSM[0], ndotl), F_texturefactorCSM0);
#endif
#ifdef D_USE_CSM_C1
#ifdef USE_BRANCH
	if (w1 > 0.0f)
#endif
#ifdef SHADER_BIAS
		Shadow += w1 * GetCSMSample3Taps(T_shadowCSM1, coords[1].xyz + biasCSM[1] / ndotle, F_texturefactorCSM1);
#else
		Shadow += w1 * GetCSMSample3Taps(T_shadowCSM1, coords[1].xyz - GetScaleBias(ScaleBiasCSM[1], ndotl), F_texturefactorCSM1);
#endif
#endif

#ifdef D_USE_CSM_C2
#ifdef USE_BRANCH
	if (w2 > 0.0f)
#endif
#ifdef SHADER_BIAS
		Shadow += w2 * GetCSMSample3Taps(T_shadowCSM2, coords[2].xyz + biasCSM[2] / ndotle, F_texturefactorCSM2);
#else
		Shadow += w2 * GetCSMSample3Taps(T_shadowCSM2, coords[2].xyz - GetScaleBias(ScaleBiasCSM[2], ndotl), F_texturefactorCSM2);
#endif
#endif

#ifdef D_USE_CSM_C3
#ifdef USE_BRANCH
	if (w3 > 0.0f)
#endif
#ifdef SHADER_BIAS
		Shadow += w3 * GetCSMSample2Taps(T_shadowCSM3, coords[3].xyz + biasCSM[3] / ndotle, F_texturefactorCSM3);
#else
		Shadow += w3 * GetCSMSample2Taps(T_shadowCSM3, coords[3].xyz - GetScaleBias(ScaleBiasCSM[3], ndotl), F_texturefactorCSM3);
#endif
#endif

#ifdef D_USE_CSM_C4
#ifdef USE_BRANCH
	if (w4 > 0.0f)
#endif
#ifdef SHADER_BIAS
		Shadow += w4 * GetCSMSampleFast(T_shadowCSM4, coords[4].xyz + biasCSM[4] / ndotle);
#else
		if (B_csmpcfenabled) {
			Shadow += w4 * GetCSMSample2Taps(T_shadowCSM4, coords[4].xyz - GetScaleBias(ScaleBiasCSM[4], ndotl), F_texturefactorCSM4);
		}
		else {
			Shadow += w4 * GetCSMSampleFast(T_shadowCSM4, coords[4].xyz - GetScaleBias(ScaleBiasCSM[4], ndotl));
		}
#endif
#endif

	return Shadow;
#endif // D_SHADOW_QUALITY
}

float GetCSMShadow(in float ndotl, in vec3 view_pos)
{
#if D_SHADOW_QUALITY == 0
	return 1.0f;
#else
	CONST float FADE_STR = 0.1;
	float fade = saturate((view_pos.z - (1.0 - FADE_STR) * F_shadowmaxdistance) / (FADE_STR * F_shadowmaxdistance));
	vec4 coords[5];
	coords[0] = mul(float4(view_pos, 1), M_shadowCSM0);
	coords[1] = mul(float4(view_pos, 1), M_shadowCSM1);
	coords[2] = mul(float4(view_pos, 1), M_shadowCSM2);
	coords[3] = mul(float4(view_pos, 1), M_shadowCSM3);
	coords[4] = mul(float4(view_pos, 1), M_shadowCSM4);
	return saturate(fade + GetCSMShadow(ndotl, coords));
#endif // D_SHADOW_QUALITY
}

#endif //DISABLE_SHADOW_HELPERS
#include <../../extensions/X4FoundationShaderMod-main/shadergl/shaders/jm_includes/jm_buffer_encoding_functions.h>
// #define USE24BITNORMALCOMPRESSION

//Lambert Azimuthal Equal-Area Projection
vec2 EncodeNormalLA(vec3 n)
{
	float p = sqrt(-n.z * 8 + 8);
	return n.xy / p + 0.5;
}
vec3 DecodeNormalLA(vec2 n)
{
	vec2 fenc = n * 4 - 2;
	float f = dot(fenc,fenc);
	float g = sqrt(1 - f/4);
	return vec3(fenc * g, f/2 - 1);
}

//Stereographic Projection
const float Normal_Stereographic_Scale = 0.3;	//TODO @Timon optimize for quality, keep in mind it affects normal blending for complex_projection*
//WARNING: if these are changed ffx_cacao_bindings.hlsl needs to be adjusted as well
float2 EncodeNormalSG(float3 n)
{
	float2 ret = n.xy / (1 - n.z);
	ret /= Normal_Stereographic_Scale;
//	return ret / 2 + 0.5;
	return ret;
}
float3 DecodeNormalSG(float2 n)
{
//	float3 ret = float3(n * 2 * Normal_Stereographic_Scale - Normal_Stereographic_Scale, 1);
	float3 ret = float3(n * Normal_Stereographic_Scale, 1);
	float g = 2.0 / dot(ret, ret);
	ret.xy *= g;
	ret.z = g - 1;
	ret.z = -ret.z;
	return ret;
}

#if 0

vec2 pack16(float value){
    float f = clamp(value, 0.0, 1.0)*255.0;
    float digitLow = fract(f);
    float digitHigh = floor(f)/255.0;
    return vec2(digitHigh, digitLow);
}       
    
float unpack16(vec2 value){
    return value.x+value.y/255.0;
}

vec4 packNormal32(in vec3 n) {
    vec2 spheremapped = encode(n);
	//return vec4(n, 1);
	return vec4(spheremapped, 0, 0);
    // return vec4(pack16(spheremapped.x), pack16(spheremapped.y));
}
vec3 unpackNormal32(in vec4 data) {
	//return data.xyz;
	return normalize(decode(data.x, data.y));
    // return normalize(decode(unpack16(data.xy), unpack16(data.zw)));
}

// Crytek BFN
//vec3 packBestFitNormal(in vec3 n) {
//    vec3 np = n.xyz;
//    // vec3 np = n.xyz*2-1;
//    np = normalize(np);
//    vec3 nu = abs(np);
//    float maxNU = max(nu.z, max(nu.x, nu.y));
//    vec2 uv = nu.z < maxNU ? (nu.y < maxNU ? nu.yz : nu.xz) : nu.xy; 
//    uv = uv.x < uv.y ? uv.yx : uv.xy;
//    uv.y /= uv.x;
//    np /= maxNU;
//    // float scale = pow(texture(T_normalfittex, uv).r, 1.0f/2);
//     //uv.y = 1- uv.y;
//    // float scale = texture(T_normalfittex, uv.xy + vec2(1.0f/256.0f)).r;
//    float scale = textureLod(T_normalfittex, uv.xy, 0).r;
//    np *= scale;
//    // return np;
//    np = np * 0.5 + 0.5;
//
//    // np = TO_linearRGB(vec4(np, 0)).xyz;
//
//    return np;
//    // return np * 0.5 + 0.5; // store unsigned
//}
//vec3 unpackBestFitNormal(in vec3 n) {
//	return normalize(n * 2 - 1);
//}
// octahedral normal encoding (http://jcgt.org/published/0003/02/01/paper.pdf)
float signNotZero(in float k) {
	return k >= 0.0 ? 1.0 : -1.0;
}
vec2 signNotZero(in vec2 v) {
	return vec2(signNotZero(v.x), signNotZero(v.y));
}
vec2 octEncode(in vec3 v) {
	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
	vec2 result = v.xy * (1.0 / l1norm);
	if (v.z < 0.0) {
		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
	}
	return result;
}

vec3 twoNorm12sEncodedAs3Unorm8sInVec3Format(vec2 s) {
	vec3 u;
	u.x = s.x * (1.0 / 16.0);
	float t = floor(s.y*(1.0 / 256));
	u.y = (frac(u.x) * 256) + t;
	u.z = s.y - (t * 256);
	// Instead of a floor, you could just add vec3(-0.5) to u, 
	// and the hardware will take care of the flooring for you on save to an RGB8 texture
	return floor(u) * (1.0 / 255.0);
}

float packSnorm12Float(float f) {
	return round(clamp(f + 1.0, 0.0, 2.0) * float(2047));
}
vec3 vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format(vec2 v) {
	vec2 s = vec2(packSnorm12Float(v.x), packSnorm12Float(v.y));
	return twoNorm12sEncodedAs3Unorm8sInVec3Format(s);
}
vec3 encodeOct(in vec3 v) {
#ifndef USE24BITNORMALCOMPRESSION
	return v;
#endif
	return vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format(octEncode(v));
}

// octahedral normal decoding
vec3 finalDecode(float x, float y) {
	vec3 v = vec3(x, y, 1.0 - abs(x) - abs(y));
	if (v.z < 0) {
		v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
	}
	return normalize(v);
}
vec2 twoNorm12sEncodedAsUVec3InVec3FormatToPackedVec2(vec3 v) {
	vec2 s;
	// Roll the (*255s) in during the quasi bit shifting. This causes two of the three multiplications to happen at compile time
	float temp = v.y * (255.0 / 16.0);
	s.x = v.x * (255.0*16.0) + floor(temp);
	s.y = fract(temp) * (16 * 256) + (v.z * 255.0);
	return s;
}

float unpackSnorm12(float f) {
	return clamp((float(f) / float(2047)) - 1.0, -1.0, 1.0);
}
float unpackSnorm12(uint u) {
	return unpackSnorm12(float(u));
}
vec2 twoSnorm12sEncodedAsUVec3InVec3FormatToVec2(vec3 v) {
	vec2 s = twoNorm12sEncodedAsUVec3InVec3FormatToPackedVec2(v);
	return vec2(unpackSnorm12(s.x), unpackSnorm12(s.y));
}
vec3 decodeOct(in vec3 p) {
#ifndef USE24BITNORMALCOMPRESSION
	p = normalize(p);	// the normals often aren't normal enough
	return p;
#endif
	vec2 v = twoSnorm12sEncodedAsUVec3InVec3FormatToVec2(p);
	return finalDecode(v.x, v.y);
}

// Most precise compression, only used for debug
vec2 octPEncode(in vec3 v) {
    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
    vec2 result = v.xy * (1.0/l1norm);
    if (v.z < 0.0) {
        result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
    }
    return result;
}
vec2 encodeIntoSnorm12sStoredAsVec2(vec3 v) {
    vec3 normv = normalize(v);
    vec2 s = octPEncode(normv);
    s = floor(clamp(s, -1.0, 1.0) * 2047 ) * ( 1.0 / 2047 );

    // Prime the loop
    vec2 bestRepresentation = s;
    float highestCosine = dot(finalDecode(s.x, s.y), normv);
    for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j) {
                // This branch will be evaluated at compile time
                if ( (i != 0) || (j != 0) ) {
                    vec2 candidate = vec2(i,j) * (1.0 / 2047 ) + s;
                    vec3 roundTrip = finalDecode(candidate.x, candidate.y);

                    float cosine = dot(roundTrip, normv);
                    if (cosine > highestCosine) {
                        bestRepresentation = candidate;
                        highestCosine      = cosine;
                    }
                }
            }
    }
    return bestRepresentation;
}
vec3 encodeOct2(in vec3 v) {
    return vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format(encodeIntoSnorm12sStoredAsVec2(v));
}

#endif

//WARNING: if these are changed ffx_cacao_bindings.hlsl needs to be adjusted as well
void UniWriteNormal(out vec4 col, vec3 normal)
{
	normal = mat3(M_view) * normal;
	col.xyz = normal;
//	col.xy = EncodeNormalLA(normal);
	col.xy = EncodeNormalSG(normal);
// 	col.z = 0;
}
void UniReadNormal(vec4 col, out vec3 normal)
{
	normal = col.xyz;
// 	normal = NormalReZ(normal);
//	normal = DecodeNormalLA(col.xy);
	normal = DecodeNormalSG(col.xy);
//	normal = mat3(M_view) * col.xyz;
}

void UniReadNormalRaw(vec4 col, out vec3 normal)
{
	normal = col.xyz;
// 	normal = NormalReZ(normal);
//	normal = DecodeNormalLA(col.xy);
	normal = DecodeNormalSG(col.xy);
	normal = mat3(M_viewinverse) * normal;
}

/************************************************************************
    Position from zbuffer
************************************************************************/

void RetrieveZBufferViewPos(out vec3 view_pos, in vec2 uv)
{
    // todo: somehow make sure that this is nooped when z writes are enabled
    if(!B_deferred_draw)
	{
#ifdef OVERRIDE_DEPTH
        vec4 p = M_invprojection * vec4(uv*2-1, RTResolve(OVERRIDE_DEPTH, uv).r, 1);
#else
        vec4 p = M_invprojection * vec4(uv*2-1, RTResolve(T_zdepth, uv).r, 1);
#endif
        view_pos = p.xyz / p.w;
    }
}

void RetrieveZBufferViewPos(out vec3 view_pos)
{
//	RetrieveZBufferViewPos(view_pos, gl_FragCoord.xy / V_viewportpixelsize.xy);
	//TODO @Timon the above doesn't work when rendering with a smaller viewport (most RenderTargets),
	//iirc the above is only used by ssao so maybe refactor to use a generic version with an offset? or something
	if(!B_deferred_draw) {
#ifdef OVERRIDE_DEPTH
		vec4 p = M_invprojection * vec4(gl_FragCoord.xy / V_viewportpixelsize.xy*2 - 1, RTResolve(OVERRIDE_DEPTH).r, 1);
#else
		vec4 p = M_invprojection * vec4(gl_FragCoord.xy / V_viewportpixelsize.xy*2 - 1, RTResolve(T_zdepth).r, 1);
#endif
		view_pos = p.xyz / p.w;
	}
}

/************************************************************************
	GBUFFER access
************************************************************************/

// full gbuffer read, mainly for ssr
#define RETRIEVE_GBUFFER(NORMAL, BASECOLOR, METAL, SMOOTH) \
{ \
	RETRIEVE_GBUFFER_NORMAL0(NORMAL); \
	RETRIEVE_GBUFFER_BASECOLOR(BASECOLOR); \
	RETRIEVE_GBUFFER_METAL_SMOOTH(METAL, SMOOTH); \
}

#define RETRIEVE_GBUFFER_NORMAL0(NORMAL0) \
{ \
	vec4 data0 = RTResolve(T_gbuffer3); \
	UniReadNormal(data0, NORMAL0);	\
}

#define RETRIEVE_GBUFFER_BASECOLOR(BASECOLOR) \
{ \
	vec4 data1 =  RTResolve(T_gbuffer2); \
	BASECOLOR.rgb = data1.rgb; \
}
#define RETRIEVE_GBUFFER_METAL_SMOOTH(METAL, SMOOTH) \
{ \
	vec4 data =  RTResolve(T_gbuffer4); \
	SMOOTH = data.r; \
	METAL = data.g; \
}

#define RETRIEVE_GBUFFER_UV_NORMAL0(UV, NORMAL0) \
{ \
	vec4 data = RTResolve(T_gbuffer3, UV); \
	UniReadNormal(data, NORMAL0);	\
}

#define RETRIEVE_GBUFFER_UV_SMOOTH(UV, SMOOTH) \
{ \
	vec4 data = RTResolve(T_gbuffer4, UV); \
	SMOOTH = data.r; \
}

#define RETRIEVE_GBUFFER_UV_NORMAL0_SMOOTH(UV, NORMAL0, SMOOTH) \
{ \
	vec2 _uv = (UV);			\
	RETRIEVE_GBUFFER_UV_NORMAL0(_uv, NORMAL0)	\
	RETRIEVE_GBUFFER_UV_SMOOTH(_uv, SMOOTH)	\
}


/************************************************************************
	legacy gbuffer access
************************************************************************/
// depending on final gbuffer layout, cherry picked access

void RetrieveGBufferNormal(out vec3 normal, in vec2 uv) {
	normal = vec3(0,0,1);
    if(!B_deferred_draw) {
		RETRIEVE_GBUFFER_UV_NORMAL0(uv, normal);
    }
}

// mainly for compability with code using old gbuffer layout
void RetrieveGBufferNormalViewZ(out vec3 normal, out float view_z, in vec2 uv) {
	normal = vec3(0,0,1);
	view_z = 0;
    // deferred draws are not allowed to read g/zbuffer
    if(!B_deferred_draw) {
        vec3 view_pos;
        RetrieveZBufferViewPos(view_pos, uv);
        view_z = view_pos.z;
		RETRIEVE_GBUFFER_UV_NORMAL0(uv, normal);
    }
}

// mainly for compability with code using old gbuffer layout
void RetrieveGBufferViewZ(out float view_z) {
    view_z = 0;
    // todo: check if this is problematic for transparent draws with z write
    // maybe use downsampled depth?
    if(!B_deferred_draw) {
        vec3 view_pos;
        RetrieveZBufferViewPos(view_pos);
        view_z = view_pos.z;
    }
}

/************************************************************************
	Renderpass input gbuffer access
************************************************************************/

#ifdef MAIN_MSAA
vec4 RI_SubpassLoad(in subpassInputMS inputattachment)
{
	#ifdef PER_SAMPLE
	return subpassLoad(inputattachment, gl_SampleID);
	#else
	return subpassLoad(inputattachment, 0);
	#endif
}
#else
vec4 RI_SubpassLoad(in subpassInput inputattachment)
{
	return subpassLoad(inputattachment);
}
#endif

#define RI_GBUFFER(NORMAL, BASECOLOR, METAL, SMOOTH) \
{ \
	RI_GBUFFER_NORMAL0(NORMAL); \
	RI_GBUFFER_BASECOLOR(BASECOLOR); \
	RI_GBUFFER_METAL_SMOOTH(METAL, SMOOTH);	\
}

#define RI_GBUFFER_RAW(NORMAL, BASECOLOR, METAL, SMOOTH) \
{ \
	RI_GBUFFER_NORMAL0_RAW(NORMAL); \
	RI_GBUFFER_BASECOLOR(BASECOLOR); \
	RI_GBUFFER_METAL_SMOOTH(METAL, SMOOTH);	\
}

#define RI_GBUFFER_NORMAL0(NORMAL0) \
{ \
	vec4 data0 = RI_SubpassLoad(Input_gbuffer3); \
	UniReadNormal(data0, NORMAL0);	\
}

#define RI_GBUFFER_NORMAL0_RAW(NORMAL0) \
{ \
	vec4 data0 = RI_SubpassLoad(Input_gbuffer3); \
	UniReadNormalRaw(data0, NORMAL0);	\
}

#define RI_GBUFFER_BASECOLOR(BASECOLOR) \
{ \
	vec4 data1 = RI_SubpassLoad(Input_gbuffer2); \
	BASECOLOR.rgb = data1.rgb; \
}

#define RI_GBUFFER_METAL_SMOOTH(METAL, SMOOTH) \
{ \
	vec2 data = RI_SubpassLoad(Input_gbuffer4).rg; \
	SMOOTH = data.r; \
	METAL = data.g; \
}

#define RI_GBUFFER_NORMAL_Z(DATA) RI_GBufferNormalViewZ(DATA.xyz, DATA.w);
void RI_GBufferNormalViewZ(out vec3 normal, out float view_z) {
	normal = vec3(0, 0, 1);
	view_z = 0;
	// deferred draws are not allowed to read g/zbuffer
	if (!B_deferred_draw) {
		vec3 view_pos;
		RetrieveZBufferViewPos(view_pos);
		view_z = view_pos.z;
		
		RI_GBUFFER_NORMAL0(normal);
	}
}

#define RI_GBUFFER_PBR(DATA) RI_GBufferPBR(DATA.x, DATA.y);
void RI_GBufferPBR(out float smoothness, out float metalness)
{
	RI_GBUFFER_METAL_SMOOTH(metalness, smoothness);
}

/************************************************************************
	OUTPUT thing
************************************************************************/
// let the engine choose between gbuffer output for full deferred lighting
// or simple mainlight lighting for non-deferred solids+transparents

#define STORE_GBUFFER(NORMAL, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	OUT_Color = vec4(GLOW, 1);				\
	OUT_Color1 = vec4(ALBEDO, 1);	\
	OUT_Color2 = vec4(0, 0, 0, 1);			\
	UniWriteNormal(OUT_Color2, NORMAL);		\
	OUT_Color3 = vec4(SMOOTH, METAL, 0, 1);			\
}

#define STORE_GBUFFERA(A, NORMAL, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	OUT_Color = vec4(GLOW, A);				\
	OUT_Color1 = vec4(ALBEDO, A);	\
	OUT_Color2 = vec4(0, 0, 0, A);			\
	UniWriteNormal(OUT_Color2, NORMAL);		\
	OUT_Color3 = vec4(SMOOTH, METAL, 0, A);	\
}

#define DEFERRED_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	STORE_GBUFFERA(A, N, ALBEDO, METAL, SMOOTH, GLOW); \
}

#define GENERAL_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
 	MetalStrict(METAL);	\
	PackMetal(METAL);	\
	RoughnessRemapSmoothVersion(SMOOTH);	\
   if (B_deferred_draw) { \
		DEFERRED_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW);	\
	} \
	else { \
		OUT_Color.a = (A); \
		OUT_Color.rgb = (GLOW) + global_lights(N, GetFragView(), ALBEDO, METAL, smooth2rough(SMOOTH), false); \
	} \
}

#define GENERAL_OUTPUT(N, ALBEDO, METAL, SMOOTH, GLOW) GENERAL_OUTPUTA(ColorBaseDiffuse.a * F_alphascale, N, ALBEDO, METAL, SMOOTH, GLOW)


#define DEFERRED_OVERLAY_ALPHA8(A, N_pp, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	MetalStrict(METAL);	\
	PackMetal(METAL);	\
	RoughnessRemapSmoothVersion(SMOOTH);	\
	OUT_Color = vec4(GLOW, 0);					\
	OUT_Color1 = vec4(ALBEDO, A);		\
	OUT_Color2 = vec4(CalcViewNormalOffset(N_pp), 0, A);	\
	OUT_Color3 = vec4(SMOOTH, METAL, 0, A);	\
}

#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING

	#define GENERAL_OUTPUTA_SUBSURFACE(A, N, ALBEDO, METAL, SUBSURFACE, SMOOTH, GLOW) \
	{ \
		MetalStrict(METAL);	\
		PackMetalSubsurface(METAL, SUBSURFACE);	\
		RoughnessRemapSmoothVersion(SMOOTH);	\
		if (B_deferred_draw) { \
			DEFERRED_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW);	\
		} \
		else { \
			OUT_Color.a = (A); \
			OUT_Color.rgb = (GLOW) + global_lights(N, GetFragView(), ALBEDO, METAL, smooth2rough(SMOOTH), false); \
		} \
	}
	
	#define GENERAL_OUTPUT_SUBSURFACE(N, ALBEDO, METAL, SUBSURFACE, SMOOTH, GLOW) GENERAL_OUTPUTA_SUBSURFACE(ColorBaseDiffuse.a * F_alphascale, N, ALBEDO, METAL, SUBSURFACE, SMOOTH, GLOW)
	
#endif#define P1_SHADERS
#include <common.fh>

vec2 good_blue_noise(vec2 coord)
{
    int i = int(mod(coord.x, 16.0));
    int j = int(mod(coord.y, 16.0));
    int finalDist = j*16+i;
    
    if(finalDist < 128) 
{
if(finalDist < 64) 
{
if(finalDist < 32) 
{
if(finalDist < 16) 
{
if(finalDist < 8) 
{
if(finalDist < 4) 
{
if(finalDist < 2) 
{
if(finalDist < 1) 
{
return vec2(0.332031, 0.707031);} else {
return vec2(0.652344, 0.972656);
}} else {
if(finalDist < 3) 
{
return vec2(0.457031, 0.5);} else {
return vec2(0.175781, 0.953125);
}
}} else {
if(finalDist < 6) 
{
if(finalDist < 5) 
{
return vec2(0.417969, 0.316406);} else {
return vec2(0.398438, 0.609375);
}} else {
if(finalDist < 7) 
{
return vec2(0.660156, 0.769531);} else {
return vec2(0.960938, 0.804688);
}
}
}} else {
if(finalDist < 12) 
{
if(finalDist < 10) 
{
if(finalDist < 9) 
{
return vec2(0.3125, 0.25);} else {
return vec2(0.285156, 0.09375);
}} else {
if(finalDist < 11) 
{
return vec2(0, 0.851563);} else {
return vec2(0.921875, 0.273438);
}
}} else {
if(finalDist < 14) 
{
if(finalDist < 13) 
{
return vec2(0.351563, 0.652344);} else {
return vec2(0.167969, 0.738281);
}} else {
if(finalDist < 15) 
{
return vec2(0.195313, 0.203125);} else {
return vec2(0.90625, 0.808594);
}
}
}
}} else {
if(finalDist < 24) 
{
if(finalDist < 20) 
{
if(finalDist < 18) 
{
if(finalDist < 17) 
{
return vec2(0.203125, 0.0664063);} else {
return vec2(0.839844, 0.160156);
}} else {
if(finalDist < 19) 
{
return vec2(0.867188, 0.40625);} else {
return vec2(0.257813, 0.472656);
}
}} else {
if(finalDist < 22) 
{
if(finalDist < 21) 
{
return vec2(0.785156, 0.164063);} else {
return vec2(0.542969, 0.351563);
}} else {
if(finalDist < 23) 
{
return vec2(0.0664063, 0.863281);} else {
return vec2(0.597656, 0.15625);
}
}
}} else {
if(finalDist < 28) 
{
if(finalDist < 26) 
{
if(finalDist < 25) 
{
return vec2(0.0195313, 0.8125);} else {
return vec2(0.6875, 0.601563);
}} else {
if(finalDist < 27) 
{
return vec2(0.582031, 0.75);} else {
return vec2(0.765625, 0.0898438);
}
}} else {
if(finalDist < 30) 
{
if(finalDist < 29) 
{
return vec2(0.304688, 0.242188);} else {
return vec2(0.574219, 0.65625);
}} else {
if(finalDist < 31) 
{
return vec2(0.773438, 0.214844);} else {
return vec2(0.128906, 0.886719);
}
}
}
}
}} else {
if(finalDist < 48) 
{
if(finalDist < 40) 
{
if(finalDist < 36) 
{
if(finalDist < 34) 
{
if(finalDist < 33) 
{
return vec2(0.4375, 0.296875);} else {
return vec2(0.511719, 0.871094);
}} else {
if(finalDist < 35) 
{
return vec2(0.0390625, 0.308594);} else {
return vec2(0.539063, 0.632813);
}
}} else {
if(finalDist < 38) 
{
if(finalDist < 37) 
{
return vec2(0.863281, 0.933594);} else {
return vec2(0.0429688, 0.28125);
}} else {
if(finalDist < 39) 
{
return vec2(0.828125, 0.683594);} else {
return vec2(0.585938, 0.261719);
}
}
}} else {
if(finalDist < 44) 
{
if(finalDist < 42) 
{
if(finalDist < 41) 
{
return vec2(0.847656, 0.570313);} else {
return vec2(0.769531, 0.121094);
}} else {
if(finalDist < 43) 
{
return vec2(0.0859375, 0.410156);} else {
return vec2(0.933594, 0.910156);
}
}} else {
if(finalDist < 46) 
{
if(finalDist < 45) 
{
return vec2(0.0078125, 0.894531);} else {
return vec2(0.898438, 0.695313);
}} else {
if(finalDist < 47) 
{
return vec2(0.117188, 0.480469);} else {
return vec2(0.914063, 0.511719);
}
}
}
}} else {
if(finalDist < 56) 
{
if(finalDist < 52) 
{
if(finalDist < 50) 
{
if(finalDist < 49) 
{
return vec2(0.246094, 0.976563);} else {
return vec2(0.746094, 0.367188);
}} else {
if(finalDist < 51) 
{
return vec2(0.566406, 0.304688);} else {
return vec2(0.105469, 0.785156);
}
}} else {
if(finalDist < 54) 
{
if(finalDist < 53) 
{
return vec2(0.722656, 0.238281);} else {
return vec2(0.761719, 0.0234375);
}} else {
if(finalDist < 55) 
{
return vec2(0.382813, 0.832031);} else {
return vec2(0.28125, 0.0273438);
}
}
}} else {
if(finalDist < 60) 
{
if(finalDist < 58) 
{
if(finalDist < 57) 
{
return vec2(0.234375, 0.699219);} else {
return vec2(0.378906, 0.585938);
}} else {
if(finalDist < 59) 
{
return vec2(0.421875, 0.636719);} else {
return vec2(0.613281, 0.378906);
}
}} else {
if(finalDist < 62) 
{
if(finalDist < 61) 
{
return vec2(0.441406, 0.195313);} else {
return vec2(0.519531, 0.171875);
}} else {
if(finalDist < 63) 
{
return vec2(0.390625, 0.859375);} else {
return vec2(0.628906, 0.421875);
}
}
}
}
}
}} else {
if(finalDist < 96) 
{
if(finalDist < 80) 
{
if(finalDist < 72) 
{
if(finalDist < 68) 
{
if(finalDist < 66) 
{
if(finalDist < 65) 
{
return vec2(0.835938, 0.417969);} else {
return vec2(0.140625, 0.375);
}} else {
if(finalDist < 67) 
{
return vec2(0.96875, 0.84375);} else {
return vec2(0.136719, 0.257813);
}
}} else {
if(finalDist < 70) 
{
if(finalDist < 69) 
{
return vec2(0.335938, 0.90625);} else {
return vec2(0.65625, 0.664063);
}} else {
if(finalDist < 71) 
{
return vec2(0.273438, 0.539063);} else {
return vec2(0.59375, 0.824219);
}
}
}} else {
if(finalDist < 76) 
{
if(finalDist < 74) 
{
if(finalDist < 73) 
{
return vec2(0.917969, 0.800781);} else {
return vec2(0.832031, 0.136719);
}} else {
if(finalDist < 75) 
{
return vec2(0.144531, 0.0117188);} else {
return vec2(0.667969, 0.925781);
}
}} else {
if(finalDist < 78) 
{
if(finalDist < 77) 
{
return vec2(0.101563, 0.449219);} else {
return vec2(0.742188, 0.675781);
}} else {
if(finalDist < 79) 
{
return vec2(0.75, 0.0429688);} else {
return vec2(0.0820313, 0.246094);
}
}
}
}} else {
if(finalDist < 88) 
{
if(finalDist < 84) 
{
if(finalDist < 82) 
{
if(finalDist < 81) 
{
return vec2(0.179688, 0.914063);} else {
return vec2(0.664063, 0.0351563);
}} else {
if(finalDist < 83) 
{
return vec2(0.480469, 0.789063);} else {
return vec2(0.734375, 0.105469);
}
}} else {
if(finalDist < 86) 
{
if(finalDist < 85) 
{
return vec2(0.753906, 0.390625);} else {
return vec2(0.183594, 0.484375);
}} else {
if(finalDist < 87) 
{
return vec2(0.691406, 0.109375);} else {
return vec2(0.359375, 0.175781);
}
}
}} else {
if(finalDist < 92) 
{
if(finalDist < 90) 
{
if(finalDist < 89) 
{
return vec2(0.0625, 0.726563);} else {
return vec2(0.425781, 0.648438);
}} else {
if(finalDist < 91) 
{
return vec2(0.449219, 0.761719);} else {
return vec2(0.699219, 0.113281);
}
}} else {
if(finalDist < 94) 
{
if(finalDist < 93) 
{
return vec2(0.820313, 0.558594);} else {
return vec2(0.0976563, 0.71875);
}} else {
if(finalDist < 95) 
{
return vec2(0.609375, 0.523438);} else {
return vec2(0.476563, 0.671875);
}
}
}
}
}} else {
if(finalDist < 112) 
{
if(finalDist < 104) 
{
if(finalDist < 100) 
{
if(finalDist < 98) 
{
if(finalDist < 97) 
{
return vec2(0.878906, 0.773438);} else {
return vec2(0.191406, 0.269531);
}} else {
if(finalDist < 99) 
{
return vec2(0.472656, 0.667969);} else {
return vec2(0.0234375, 0.566406);
}
}} else {
if(finalDist < 102) 
{
if(finalDist < 101) 
{
return vec2(0.78125, 0.898438);} else {
return vec2(0.078125, 0.535156);
}} else {
if(finalDist < 103) 
{
return vec2(0.851563, 0.875);} else {
return vec2(0.925781, 0.292969);
}
}
}} else {
if(finalDist < 108) 
{
if(finalDist < 106) 
{
if(finalDist < 105) 
{
return vec2(0.796875, 0.613281);} else {
return vec2(0.355469, 0.148438);
}} else {
if(finalDist < 107) 
{
return vec2(0.957031, 0.222656);} else {
return vec2(0.046875, 0.730469);
}
}} else {
if(finalDist < 110) 
{
if(finalDist < 109) 
{
return vec2(0.394531, 0.714844);} else {
return vec2(0.484375, 0.015625);
}} else {
if(finalDist < 111) 
{
return vec2(0.816406, 0.78125);} else {
return vec2(0.0585938, 0.132813);
}
}
}
}} else {
if(finalDist < 120) 
{
if(finalDist < 116) 
{
if(finalDist < 114) 
{
if(finalDist < 113) 
{
return vec2(0.984375, 0.140625);} else {
return vec2(0.679688, 0.425781);
}} else {
if(finalDist < 115) 
{
return vec2(0.671875, 0.980469);} else {
return vec2(0.347656, 0.03125);
}
}} else {
if(finalDist < 118) 
{
if(finalDist < 117) 
{
return vec2(0.941406, 0.199219);} else {
return vec2(0.632813, 0.46875);
}} else {
if(finalDist < 119) 
{
return vec2(0.160156, 0.234375);} else {
return vec2(0.261719, 0.890625);
}
}
}} else {
if(finalDist < 124) 
{
if(finalDist < 122) 
{
if(finalDist < 121) 
{
return vec2(0.277344, 0.355469);} else {
return vec2(0.367188, 0.597656);
}} else {
if(finalDist < 123) 
{
return vec2(0.328125, 0.488281);} else {
return vec2(0.996094, 0.996094);
}
}} else {
if(finalDist < 126) 
{
if(finalDist < 125) 
{
return vec2(0.578125, 0.183594);} else {
return vec2(0.929688, 0.515625);
}} else {
if(finalDist < 127) 
{
return vec2(0.0117188, 0.988281);} else {
return vec2(0.527344, 0.503906);
}
}
}
}
}
}
}} else {
if(finalDist < 192) 
{
if(finalDist < 160) 
{
if(finalDist < 144) 
{
if(finalDist < 136) 
{
if(finalDist < 132) 
{
if(finalDist < 130) 
{
if(finalDist < 129) 
{
return vec2(0.210938, 0.835938);} else {
return vec2(0.714844, 0.3125);
}} else {
if(finalDist < 131) 
{
return vec2(0.164063, 0.492188);} else {
return vec2(0.25, 0.589844);
}
}} else {
if(finalDist < 134) 
{
if(finalDist < 133) 
{
return vec2(0.601563, 0.53125);} else {
return vec2(0.226563, 0.949219);
}} else {
if(finalDist < 135) 
{
return vec2(0.757813, 0.117188);} else {
return vec2(0.46875, 0.527344);
}
}
}} else {
if(finalDist < 140) 
{
if(finalDist < 138) 
{
if(finalDist < 137) 
{
return vec2(0.703125, 0.703125);} else {
return vec2(0.675781, 0.992188);
}} else {
if(finalDist < 139) 
{
return vec2(0.265625, 0.046875);} else {
return vec2(0.40625, 0.550781);
}
}} else {
if(finalDist < 142) 
{
if(finalDist < 141) 
{
return vec2(0.292969, 0.542969);} else {
return vec2(0.222656, 0.0390625);
}} else {
if(finalDist < 143) 
{
return vec2(0.617188, 0.429688);} else {
return vec2(0.34375, 0.359375);
}
}
}
}} else {
if(finalDist < 152) 
{
if(finalDist < 148) 
{
if(finalDist < 146) 
{
if(finalDist < 145) 
{
return vec2(0.433594, 0.0195313);} else {
return vec2(0.113281, 0.757813);
}} else {
if(finalDist < 147) 
{
return vec2(0.945313, 0.679688);} else {
return vec2(0.414063, 0.078125);
}
}} else {
if(finalDist < 150) 
{
if(finalDist < 149) 
{
return vec2(0.695313, 0.582031);} else {
return vec2(0.0703125, 0.691406);
}} else {
if(finalDist < 151) 
{
return vec2(0.648438, 0.460938);} else {
return vec2(0.015625, 0.125);
}
}
}} else {
if(finalDist < 156) 
{
if(finalDist < 154) 
{
if(finalDist < 153) 
{
return vec2(0.9375, 0.00390625);} else {
return vec2(0.1875, 0.644531);
}} else {
if(finalDist < 155) 
{
return vec2(0.824219, 0.285156);} else {
return vec2(0.546875, 0.6875);
}
}} else {
if(finalDist < 158) 
{
if(finalDist < 157) 
{
return vec2(0.972656, 0.128906);} else {
return vec2(0.53125, 0.9375);
}} else {
if(finalDist < 159) 
{
return vec2(0.371094, 0.753906);} else {
return vec2(0.882813, 0.382813);
}
}
}
}
}} else {
if(finalDist < 176) 
{
if(finalDist < 168) 
{
if(finalDist < 164) 
{
if(finalDist < 162) 
{
if(finalDist < 161) 
{
return vec2(0.21875, 0.457031);} else {
return vec2(0.492188, 0.855469);
}} else {
if(finalDist < 163) 
{
return vec2(0.789063, 0.339844);} else {
return vec2(0.152344, 0.1875);
}
}} else {
if(finalDist < 166) 
{
if(finalDist < 165) 
{
return vec2(0.683594, 0.960938);} else {
return vec2(0.621094, 0.347656);
}} else {
if(finalDist < 167) 
{
return vec2(0.644531, 0.839844);} else {
return vec2(0.992188, 0.605469);
}
}
}} else {
if(finalDist < 172) 
{
if(finalDist < 170) 
{
if(finalDist < 169) 
{
return vec2(0.535156, 0.945313);} else {
return vec2(0.15625, 0.394531);
}} else {
if(finalDist < 171) 
{
return vec2(0.792969, 0.371094);} else {
return vec2(0.121094, 0.984375);
}
}} else {
if(finalDist < 174) 
{
if(finalDist < 173) 
{
return vec2(0.605469, 0.496094);} else {
return vec2(0.0273438, 0.191406);
}} else {
if(finalDist < 175) 
{
return vec2(0.464844, 0.277344);} else {
return vec2(0.777344, 0.929688);
}
}
}
}} else {
if(finalDist < 184) 
{
if(finalDist < 180) 
{
if(finalDist < 178) 
{
if(finalDist < 177) 
{
return vec2(0.964844, 0.0976563);} else {
return vec2(0.515625, 0.34375);
}} else {
if(finalDist < 179) 
{
return vec2(0.730469, 0.621094);} else {
return vec2(0.09375, 0.902344);
}
}} else {
if(finalDist < 182) 
{
if(finalDist < 181) 
{
return vec2(0.988281, 0);} else {
return vec2(0.386719, 0.328125);
}} else {
if(finalDist < 183) 
{
return vec2(0.320313, 0.0625);} else {
return vec2(0.132813, 0.660156);
}
}
}} else {
if(finalDist < 188) 
{
if(finalDist < 186) 
{
if(finalDist < 185) 
{
return vec2(0.300781, 0.476563);} else {
return vec2(0.558594, 0.324219);
}} else {
if(finalDist < 187) 
{
return vec2(0.554688, 0.5625);} else {
return vec2(0.0507813, 0.101563);
}
}} else {
if(finalDist < 190) 
{
if(finalDist < 189) 
{
return vec2(0.625, 0.519531);} else {
return vec2(0.636719, 0.816406);
}} else {
if(finalDist < 191) 
{
return vec2(0.890625, 0.386719);} else {
return vec2(0.0351563, 0.578125);
}
}
}
}
}
}} else {
if(finalDist < 224) 
{
if(finalDist < 208) 
{
if(finalDist < 200) 
{
if(finalDist < 196) 
{
if(finalDist < 194) 
{
if(finalDist < 193) 
{
return vec2(0.375, 0.964844);} else {
return vec2(0.253906, 0.210938);
}} else {
if(finalDist < 195) 
{
return vec2(0.402344, 0.402344);} else {
return vec2(0.726563, 0.792969);
}
}} else {
if(finalDist < 198) 
{
if(finalDist < 197) 
{
return vec2(0.207031, 0.507813);} else {
return vec2(0.871094, 0.722656);
}} else {
if(finalDist < 199) 
{
return vec2(0.503906, 0.867188);} else {
return vec2(0.507813, 0.21875);
}
}
}} else {
if(finalDist < 204) 
{
if(finalDist < 202) 
{
if(finalDist < 201) 
{
return vec2(0.738281, 0.144531);} else {
return vec2(0.902344, 0.847656);
}} else {
if(finalDist < 203) 
{
return vec2(0.5, 0.957031);} else {
return vec2(0.238281, 0.253906);
}
}} else {
if(finalDist < 206) 
{
if(finalDist < 205) 
{
return vec2(0.8125, 0.179688);} else {
return vec2(0.0898438, 0.414063);
}} else {
if(finalDist < 207) 
{
return vec2(0.460938, 0.734375);} else {
return vec2(0.488281, 0.0703125);
}
}
}
}} else {
if(finalDist < 216) 
{
if(finalDist < 212) 
{
if(finalDist < 210) 
{
if(finalDist < 209) 
{
return vec2(0.707031, 0.828125);} else {
return vec2(0.976563, 0.554688);
}} else {
if(finalDist < 211) 
{
return vec2(0.0546875, 0.628906);} else {
return vec2(0.523438, 0.0820313);
}
}} else {
if(finalDist < 214) 
{
if(finalDist < 213) 
{
return vec2(0.148438, 0.335938);} else {
return vec2(0.589844, 0.363281);
}} else {
if(finalDist < 215) 
{
return vec2(0.0742188, 0.746094);} else {
return vec2(0.980469, 0.777344);
}
}
}} else {
if(finalDist < 220) 
{
if(finalDist < 218) 
{
if(finalDist < 217) 
{
return vec2(0.242188, 0.332031);} else {
return vec2(0.125, 0.625);
}} else {
if(finalDist < 219) 
{
return vec2(0.949219, 0.207031);} else {
return vec2(0.363281, 0.796875);
}
}} else {
if(finalDist < 222) 
{
if(finalDist < 221) 
{
return vec2(0.894531, 0.320313);} else {
return vec2(0.410156, 0.96875);
}} else {
if(finalDist < 223) 
{
return vec2(0.859375, 0.441406);} else {
return vec2(0.199219, 0.0859375);
}
}
}
}
}} else {
if(finalDist < 240) 
{
if(finalDist < 232) 
{
if(finalDist < 228) 
{
if(finalDist < 226) 
{
if(finalDist < 225) 
{
return vec2(0.289063, 0.433594);} else {
return vec2(0.84375, 0.0546875);
}} else {
if(finalDist < 227) 
{
return vec2(0.429688, 0.941406);} else {
return vec2(0.953125, 0.640625);
}
}} else {
if(finalDist < 230) 
{
if(finalDist < 229) 
{
return vec2(0.324219, 0.878906);} else {
return vec2(0.875, 0.230469);
}} else {
if(finalDist < 231) 
{
return vec2(0.269531, 0.453125);} else {
return vec2(0.445313, 0.917969);
}
}
}} else {
if(finalDist < 236) 
{
if(finalDist < 234) 
{
if(finalDist < 233) 
{
return vec2(0.910156, 0.0742188);} else {
return vec2(0.339844, 0.546875);
}} else {
if(finalDist < 235) 
{
return vec2(0.230469, 0.0507813);} else {
return vec2(0.214844, 0.574219);
}
}} else {
if(finalDist < 238) 
{
if(finalDist < 237) 
{
return vec2(0.804688, 0.710938);} else {
return vec2(0.171875, 0.167969);
}} else {
if(finalDist < 239) 
{
return vec2(0.109375, 0.882813);} else {
return vec2(0.550781, 0.742188);
}
}
}
}} else {
if(finalDist < 248) 
{
if(finalDist < 244) 
{
if(finalDist < 242) 
{
if(finalDist < 241) 
{
return vec2(0.453125, 0.4375);} else {
return vec2(0.00390625, 0.300781);
}} else {
if(finalDist < 243) 
{
return vec2(0.71875, 0.445313);} else {
return vec2(0.308594, 0.0078125);
}
}} else {
if(finalDist < 246) 
{
if(finalDist < 245) 
{
return vec2(0.570313, 0.921875);} else {
return vec2(0.855469, 0.152344);
}} else {
if(finalDist < 247) 
{
return vec2(0.03125, 0.226563);} else {
return vec2(0.5625, 0.289063);
}
}
}} else {
if(finalDist < 252) 
{
if(finalDist < 250) 
{
if(finalDist < 249) 
{
return vec2(0.316406, 0.765625);} else {
return vec2(0.886719, 0.59375);
}} else {
if(finalDist < 251) 
{
return vec2(0.710938, 0.617188);} else {
return vec2(0.496094, 0.820313);
}
}} else {
if(finalDist < 254) 
{
if(finalDist < 253) 
{
return vec2(0.296875, 0.0585938);} else {
return vec2(0.808594, 0.464844);
}} else {
if(finalDist < 255) 
{
return vec2(0.800781, 0.398438);} else {
return vec2(0.640625, 0.265625);
}
}
}
}
}
}
}
}
return vec2(0.0);
}

float randBlue(vec2 coord)
{
    int i = int(mod(coord.x, 16.0));
    int j = int(mod(coord.y, 16.0));
    int finalDist = j*16+i;

if(finalDist < 128) 
{
if(finalDist < 64) 
{
if(finalDist < 32) 
{
if(finalDist < 16) 
{
if(finalDist < 8) 
{
if(finalDist < 4) 
{
if(finalDist < 2) 
{
if(finalDist < 1) 
{
return 0.28125;} else {
return 0.136719;
}} else {
if(finalDist < 3) 
{
return 0.433594;} else {
return 0.03125;
}
}} else {
if(finalDist < 6) 
{
if(finalDist < 5) 
{
return 0.550781;} else {
return 0.15625;
}} else {
if(finalDist < 7) 
{
return 0.714844;} else {
return 0.222656;
}
}
}} else {
if(finalDist < 12) 
{
if(finalDist < 10) 
{
if(finalDist < 9) 
{
return 0.835938;} else {
return 0.488281;
}} else {
if(finalDist < 11) 
{
return 0.792969;} else {
return 0.390625;
}
}} else {
if(finalDist < 14) 
{
if(finalDist < 13) 
{
return 0.878906;} else {
return 0.65625;
}} else {
if(finalDist < 15) 
{
return 0.117188;} else {
return 0.542969;
}
}
}
}} else {
if(finalDist < 24) 
{
if(finalDist < 20) 
{
if(finalDist < 18) 
{
if(finalDist < 17) 
{
return 0.203125;} else {
return 0.511719;
}} else {
if(finalDist < 19) 
{
return 0.925781;} else {
return 0.296875;
}
}} else {
if(finalDist < 22) 
{
if(finalDist < 21) 
{
return 0.746094;} else {
return 0.480469;
}} else {
if(finalDist < 23) 
{
return 0.988281;} else {
return 0.382813;
}
}
}} else {
if(finalDist < 28) 
{
if(finalDist < 26) 
{
if(finalDist < 25) 
{
return 0.628906;} else {
return 0.300781;
}} else {
if(finalDist < 27) 
{
return 0.984375;} else {
return 0.0898438;
}
}} else {
if(finalDist < 30) 
{
if(finalDist < 29) 
{
return 0.1875;} else {
return 0.484375;
}} else {
if(finalDist < 31) 
{
return 0.960938;} else {
return 0.859375;
}
}
}
}
}} else {
if(finalDist < 48) 
{
if(finalDist < 40) 
{
if(finalDist < 36) 
{
if(finalDist < 34) 
{
if(finalDist < 33) 
{
return 0.675781;} else {
return 0.753906;
}} else {
if(finalDist < 35) 
{
return 0.101563;} else {
return 0.617188;
}
}} else {
if(finalDist < 38) 
{
if(finalDist < 37) 
{
return 0.882813;} else {
return 0.351563;
}} else {
if(finalDist < 39) 
{
return 0.0625;} else {
return 0.578125;
}
}
}} else {
if(finalDist < 44) 
{
if(finalDist < 42) 
{
if(finalDist < 41) 
{
return 0.875;} else {
return 0.152344;
}} else {
if(finalDist < 43) 
{
return 0.722656;} else {
return 0.472656;
}
}} else {
if(finalDist < 46) 
{
if(finalDist < 45) 
{
return 0.6875;} else {
return 0.289063;
}} else {
if(finalDist < 47) 
{
return 0.0078125;} else {
return 0.445313;
}
}
}
}} else {
if(finalDist < 56) 
{
if(finalDist < 52) 
{
if(finalDist < 50) 
{
if(finalDist < 49) 
{
return 0.332031;} else {
return 0.839844;
}} else {
if(finalDist < 51) 
{
return 0.527344;} else {
return 0.40625;
}
}} else {
if(finalDist < 54) 
{
if(finalDist < 53) 
{
return 0.121094;} else {
return 0.699219;
}} else {
if(finalDist < 55) 
{
return 0.21875;} else {
return 0.765625;
}
}
}} else {
if(finalDist < 60) 
{
if(finalDist < 58) 
{
if(finalDist < 57) 
{
return 0.0195313;} else {
return 0.234375;
}} else {
if(finalDist < 59) 
{
return 0.585938;} else {
return 0.261719;
}
}} else {
if(finalDist < 62) 
{
if(finalDist < 61) 
{
return 0.921875;} else {
return 0.8125;
}} else {
if(finalDist < 63) 
{
return 0.539063;} else {
return 0.132813;
}
}
}
}
}
}} else {
if(finalDist < 96) 
{
if(finalDist < 80) 
{
if(finalDist < 72) 
{
if(finalDist < 68) 
{
if(finalDist < 66) 
{
if(finalDist < 65) 
{
return 0.96875;} else {
return 0.0390625;
}} else {
if(finalDist < 67) 
{
return 0.207031;} else {
return 0.941406;
}
}} else {
if(finalDist < 70) 
{
if(finalDist < 69) 
{
return 0.285156;} else {
return 0.828125;
}} else {
if(finalDist < 71) 
{
return 0.652344;} else {
return 0.359375;
}
}
}} else {
if(finalDist < 76) 
{
if(finalDist < 74) 
{
if(finalDist < 73) 
{
return 0.523438;} else {
return 0.9375;
}} else {
if(finalDist < 75) 
{
return 0.785156;} else {
return 0.386719;
}
}} else {
if(finalDist < 78) 
{
if(finalDist < 77) 
{
return 0.0351563;} else {
return 0.726563;
}} else {
if(finalDist < 79) 
{
return 0.378906;} else {
return 0.644531;
}
}
}
}} else {
if(finalDist < 88) 
{
if(finalDist < 84) 
{
if(finalDist < 82) 
{
if(finalDist < 81) 
{
return 0.402344;} else {
return 0.71875;
}} else {
if(finalDist < 83) 
{
return 0.601563;} else {
return 0.742188;
}
}} else {
if(finalDist < 86) 
{
if(finalDist < 85) 
{
return 0.441406;} else {
return 0.046875;
}} else {
if(finalDist < 87) 
{
return 0.46875;} else {
return 0.160156;
}
}
}} else {
if(finalDist < 92) 
{
if(finalDist < 90) 
{
if(finalDist < 89) 
{
return 0.824219;} else {
return 0.292969;
}} else {
if(finalDist < 91) 
{
return 0.492188;} else {
return 0.125;
}
}} else {
if(finalDist < 94) 
{
if(finalDist < 93) 
{
return 0.613281;} else {
return 0.183594;
}} else {
if(finalDist < 95) 
{
return 0.910156;} else {
return 0.25;
}
}
}
}
}} else {
if(finalDist < 112) 
{
if(finalDist < 104) 
{
if(finalDist < 100) 
{
if(finalDist < 98) 
{
if(finalDist < 97) 
{
return 0.078125;} else {
return 0.871094;
}} else {
if(finalDist < 99) 
{
return 0.257813;} else {
return 0.535156;
}
}} else {
if(finalDist < 102) 
{
if(finalDist < 101) 
{
return 0.105469;} else {
return 0.972656;
}} else {
if(finalDist < 103) 
{
return 0.582031;} else {
return 0.914063;
}
}
}} else {
if(finalDist < 108) 
{
if(finalDist < 106) 
{
if(finalDist < 105) 
{
return 0.671875;} else {
return 0.0664063;
}} else {
if(finalDist < 107) 
{
return 0.730469;} else {
return 0.976563;
}
}} else {
if(finalDist < 110) 
{
if(finalDist < 109) 
{
return 0.308594;} else {
return 0.851563;
}} else {
if(finalDist < 111) 
{
return 0.453125;} else {
return 0.554688;
}
}
}
}} else {
if(finalDist < 120) 
{
if(finalDist < 116) 
{
if(finalDist < 114) 
{
if(finalDist < 113) 
{
return 0.789063;} else {
return 0.347656;
}} else {
if(finalDist < 115) 
{
return 0.113281;} else {
return 0.886719;
}
}} else {
if(finalDist < 118) 
{
if(finalDist < 117) 
{
return 0.398438;} else {
return 0.691406;
}} else {
if(finalDist < 119) 
{
return 0.34375;} else {
return 0.230469;
}
}
}} else {
if(finalDist < 124) 
{
if(finalDist < 122) 
{
if(finalDist < 121) 
{
return 0.425781;} else {
return 0.175781;
}} else {
if(finalDist < 123) 
{
return 0.625;} else {
return 0.410156;
}
}} else {
if(finalDist < 126) 
{
if(finalDist < 125) 
{
return 0.558594;} else {
return 0.0742188;
}} else {
if(finalDist < 127) 
{
return 0.710938;} else {
return 0.140625;
}
}
}
}
}
}
}} else {
if(finalDist < 192) 
{
if(finalDist < 160) 
{
if(finalDist < 144) 
{
if(finalDist < 136) 
{
if(finalDist < 132) 
{
if(finalDist < 130) 
{
if(finalDist < 129) 
{
return 0.621094;} else {
return 0.457031;
}} else {
if(finalDist < 131) 
{
return 0.667969;} else {
return 0.3125;
}
}} else {
if(finalDist < 134) 
{
if(finalDist < 133) 
{
return 0.78125;} else {
return 0.167969;
}} else {
if(finalDist < 135) 
{
return 0.847656;} else {
return 0.0117188;
}
}
}} else {
if(finalDist < 140) 
{
if(finalDist < 138) 
{
if(finalDist < 137) 
{
return 0.769531;} else {
return 0.570313;
}} else {
if(finalDist < 139) 
{
return 0.890625;} else {
return 0.00390625;
}
}} else {
if(finalDist < 142) 
{
if(finalDist < 141) 
{
return 0.808594;} else {
return 0.199219;
}} else {
if(finalDist < 143) 
{
return 0.507813;} else {
return 0.992188;
}
}
}
}} else {
if(finalDist < 152) 
{
if(finalDist < 148) 
{
if(finalDist < 146) 
{
if(finalDist < 145) 
{
return 0.546875;} else {
return 0.179688;
}} else {
if(finalDist < 147) 
{
return 0.902344;} else {
return 0.0507813;
}
}} else {
if(finalDist < 150) 
{
if(finalDist < 149) 
{
return 0.53125;} else {
return 0.269531;
}} else {
if(finalDist < 151) 
{
return 0.589844;} else {
return 0.949219;
}
}
}} else {
if(finalDist < 156) 
{
if(finalDist < 154) 
{
if(finalDist < 153) 
{
return 0.496094;} else {
return 0.273438;
}} else {
if(finalDist < 155) 
{
return 0.144531;} else {
return 0.339844;
}
}} else {
if(finalDist < 158) 
{
if(finalDist < 157) 
{
return 0.679688;} else {
return 0.375;
}} else {
if(finalDist < 159) 
{
return 0.863281;} else {
return 0.226563;
}
}
}
}
}} else {
if(finalDist < 176) 
{
if(finalDist < 168) 
{
if(finalDist < 164) 
{
if(finalDist < 162) 
{
if(finalDist < 161) 
{
return 0.683594;} else {
return 0.355469;
}} else {
if(finalDist < 163) 
{
return 0.734375;} else {
return 0.429688;
}
}} else {
if(finalDist < 166) 
{
if(finalDist < 165) 
{
return 0.996094;} else {
return 0.109375;
}} else {
if(finalDist < 167) 
{
return 0.738281;} else {
return 0.324219;
}
}
}} else {
if(finalDist < 172) 
{
if(finalDist < 170) 
{
if(finalDist < 169) 
{
return 0.09375;} else {
return 0.800781;
}} else {
if(finalDist < 171) 
{
return 0.957031;} else {
return 0.476563;
}
}} else {
if(finalDist < 174) 
{
if(finalDist < 173) 
{
return 0.246094;} else {
return 0.945313;
}} else {
if(finalDist < 175) 
{
return 0.4375;} else {
return 0.0546875;
}
}
}
}} else {
if(finalDist < 184) 
{
if(finalDist < 180) 
{
if(finalDist < 178) 
{
if(finalDist < 177) 
{
return 0.929688;} else {
return 0.015625;
}} else {
if(finalDist < 179) 
{
return 0.242188;} else {
return 0.820313;
}
}} else {
if(finalDist < 182) 
{
if(finalDist < 181) 
{
return 0.597656;} else {
return 0.195313;
}} else {
if(finalDist < 183) 
{
return 0.640625;} else {
return 0.414063;
}
}
}} else {
if(finalDist < 188) 
{
if(finalDist < 186) 
{
if(finalDist < 185) 
{
return 0.707031;} else {
return 0.371094;
}} else {
if(finalDist < 187) 
{
return 0.609375;} else {
return 0.757813;
}
}} else {
if(finalDist < 190) 
{
if(finalDist < 189) 
{
return 0.0585938;} else {
return 0.632813;
}} else {
if(finalDist < 191) 
{
return 0.316406;} else {
return 0.75;
}
}
}
}
}
}} else {
if(finalDist < 224) 
{
if(finalDist < 208) 
{
if(finalDist < 200) 
{
if(finalDist < 196) 
{
if(finalDist < 194) 
{
if(finalDist < 193) 
{
return 0.164063;} else {
return 0.464844;
}} else {
if(finalDist < 195) 
{
return 0.660156;} else {
return 0.894531;
}
}} else {
if(finalDist < 198) 
{
if(finalDist < 197) 
{
return 0.320313;} else {
return 0.460938;
}} else {
if(finalDist < 199) 
{
return 0.917969;} else {
return 0.855469;
}
}
}} else {
if(finalDist < 204) 
{
if(finalDist < 202) 
{
if(finalDist < 201) 
{
return 0.214844;} else {
return 0.0;
}} else {
if(finalDist < 203) 
{
return 0.171875;} else {
return 0.515625;
}
}} else {
if(finalDist < 206) 
{
if(finalDist < 205) 
{
return 0.898438;} else {
return 0.191406;
}} else {
if(finalDist < 207) 
{
return 0.796875;} else {
return 0.519531;
}
}
}
}} else {
if(finalDist < 216) 
{
if(finalDist < 212) 
{
if(finalDist < 210) 
{
if(finalDist < 209) 
{
return 0.867188;} else {
return 0.367188;
}} else {
if(finalDist < 211) 
{
return 0.566406;} else {
return 0.0703125;
}
}} else {
if(finalDist < 214) 
{
if(finalDist < 213) 
{
return 0.128906;} else {
return 0.777344;
}} else {
if(finalDist < 215) 
{
return 0.0273438;} else {
return 0.265625;
}
}
}} else {
if(finalDist < 220) 
{
if(finalDist < 218) 
{
if(finalDist < 217) 
{
return 0.5;} else {
return 0.773438;
}} else {
if(finalDist < 219) 
{
return 0.90625;} else {
return 0.304688;
}
}} else {
if(finalDist < 222) 
{
if(finalDist < 221) 
{
return 0.0976563;} else {
return 0.421875;
}} else {
if(finalDist < 223) 
{
return 0.5625;} else {
return 0.253906;
}
}
}
}
}} else {
if(finalDist < 240) 
{
if(finalDist < 232) 
{
if(finalDist < 228) 
{
if(finalDist < 226) 
{
if(finalDist < 225) 
{
return 0.0820313;} else {
return 0.980469;
}} else {
if(finalDist < 227) 
{
return 0.277344;} else {
return 0.703125;
}
}} else {
if(finalDist < 230) 
{
if(finalDist < 229) 
{
return 0.503906;} else {
return 0.328125;
}} else {
if(finalDist < 231) 
{
return 0.636719;} else {
return 0.574219;
}
}
}} else {
if(finalDist < 236) 
{
if(finalDist < 234) 
{
if(finalDist < 233) 
{
return 0.953125;} else {
return 0.363281;
}} else {
if(finalDist < 235) 
{
return 0.449219;} else {
return 0.664063;
}
}} else {
if(finalDist < 238) 
{
if(finalDist < 237) 
{
return 0.816406;} else {
return 0.964844;
}} else {
if(finalDist < 239) 
{
return 0.0234375;} else {
return 0.648438;
}
}
}
}} else {
if(finalDist < 248) 
{
if(finalDist < 244) 
{
if(finalDist < 242) 
{
if(finalDist < 241) 
{
return 0.804688;} else {
return 0.605469;
}} else {
if(finalDist < 243) 
{
return 0.84375;} else {
return 0.210938;
}
}} else {
if(finalDist < 246) 
{
if(finalDist < 245) 
{
return 0.832031;} else {
return 0.933594;
}} else {
if(finalDist < 247) 
{
return 0.417969;} else {
return 0.0859375;
}
}
}} else {
if(finalDist < 252) 
{
if(finalDist < 250) 
{
if(finalDist < 249) 
{
return 0.695313;} else {
return 0.148438;
}} else {
if(finalDist < 251) 
{
return 0.0429688;} else {
return 0.59375;
}
}} else {
if(finalDist < 254) 
{
if(finalDist < 253) 
{
return 0.238281;} else {
return 0.335938;
}} else {
if(finalDist < 255) 
{
return 0.761719;} else {
return 0.394531;
}
}
}
}
}
}
}
}    
    return 0.0;
}


#ifdef JM_USE_RETROREFLECTIVE_DIFFUSE_MODEL
vec3 integrate_GGX_and_retroreflective_diffuse(float roughness, float n_dot_v)
{
  vec3 normal = vec3(0.0f, 0.0f, 1.0f);

  vec3 view = vec3(sqrt(1.0f - n_dot_v * n_dot_v), 0, n_dot_v);
  float a = 0.0f; float b = 0.0f; float c = 0.0f;
 #ifdef JM_USE_RETROREFLECTIVE_DIFFUSE_MODEL
	CONST uint num_samples = 256u;//the diffuse needs a ton more samples - and the specular ones looks even better with more too!
#else
	CONST uint num_samples = 32u;//was 32
#endif	
  for(uint i=0u; i< num_samples; ++i)
  {
	vec2 uv = hammersley_2d(i, num_samples);
	
	vec3 half_dir = importance_sample_GGX(uv, roughness, normal);
	vec3 light = 2 * dot(view, half_dir) * half_dir - view;
	float n_dot_l = max(0.0f, light.z);
	// float n_dot_l = light.z;
	float n_dot_h = clamp(half_dir.z, 0.0f, 1.0f);
	// float n_dot_h = half_dir.z;
	float v_dot_h = clamp(dot(view, half_dir), 0.0f, 1.0f);
	// float v_dot_h = dot(view, half_dir);
	if( n_dot_l > 0.0f)
	// if( true )
	{
		
		float k = (roughness*roughness)/2;
		float G = G_Smith(k, n_dot_v, n_dot_l);
		// float G = G_smith(roughness, n_dot_v, n_dot_l);
	
		float G_vis = G * v_dot_h / (n_dot_h * n_dot_v);
		// G_vis = Vis_Smith(roughness, n_dot_v, n_dot_l);
		// float G_vis = G / (4.0f*n_dot_l*n_dot_v);
		float F_c = pow(1.0f - v_dot_h, 5);
		// float F0 = 0.5f; // reflectance at normal incidence
		// float F_c = F0 + (1-F0)*pow( 1.0f - v_dot_h, 5 );
		a += (1.0f - F_c) * G_vis;
		b += F_c * G_vis;
#ifdef JM_USE_RETROREFLECTIVE_DIFFUSE_MODEL
		// we can throw the retroreflective diffuse BRDF in here!
		float a2 = roughness*roughness;
		float g = saturate((1.0 / 18.0) * log2(2.0 / a2 - 1.0));
		float f0 = (v_dot_h + pow5(1.0 - v_dot_h));
		float fdv = (1.0 - 0.75 * pow5(1.0 - n_dot_v));
		float fdl = (1.0 - 0.75 * pow5(1.0 - n_dot_l));
	
		// Rough (f0) to smooth (fdv * fdv) response interpolation
		float fd = mix(f0, fdv * fdl, saturate(2.2 * g - 0.5));
		
		// Retro reflectivity contribution.
		float fb = ((34.5 * g - 59.0) * g + 24.5) * v_dot_h * exp2(-max(73.2 * g - 21.2, 8.9) * sqrt(n_dot_h));
		c += (fd + fb) * n_dot_l;
#endif		
	}
	
  }
  vec3 sum = vec3(a, b, c * PI) * (1.0 / num_samples);
//  sum.z *= (1.0 / dot(sum, vec3(1.0)));
  return sum;
}

void main()
{
  	OUT_Color = vec4(0);
	
/*	
	//We can do this smarter if we want to use it!
	vec2 blue_noise = good_blue_noise(IO_uv0 * 256.0);//Makes a nice dither rotation
	float blue_noise_rot = atan(blue_noise.y, blue_noise.x);//unpack with sincos()
*/
    OUT_Color.xyz = integrate_GGX_and_retroreflective_diffuse(IO_uv0.x, IO_uv0.y);
	OUT_Color.a = 1.0;//blue_noise_rot;
  	// OUT_Color = vec4(IO_uv0, 1, 1);
}
#else
vec2 integrate_GGX(float roughness, float n_dot_v)
{
  vec3 normal = vec3(0.0f, 0.0f, 1.0f);

  vec3 view = vec3(sqrt(1.0f - n_dot_v * n_dot_v), 0, n_dot_v);
  float a = 0.0f; float b = 0.0f;
  CONST uint num_samples = 32u;
  for(uint i=0u; i< num_samples; ++i)
  {
    vec2 uv = hammersley_2d(i, num_samples);

    vec3 half_dir = importance_sample_GGX(uv, roughness, normal);
    vec3 light = 2 * dot(view, half_dir) * half_dir - view;
    float n_dot_l = max(0.0f, light.z);
    // float n_dot_l = light.z;
    float n_dot_h = clamp(half_dir.z, 0.0f, 1.0f);
    // float n_dot_h = half_dir.z;
    float v_dot_h = clamp(dot(view, half_dir), 0.0f, 1.0f);
    // float v_dot_h = dot(view, half_dir);

    if( n_dot_l > 0.0f)
    // if( true )
    {
      float k = (roughness*roughness)/2;
      float G = G_Smith(k, n_dot_v, n_dot_l);
      // float G = G_smith(roughness, n_dot_v, n_dot_l);

      float G_vis = G * v_dot_h / (n_dot_h * n_dot_v);
      // G_vis = Vis_Smith(roughness, n_dot_v, n_dot_l);
      // float G_vis = G / (4.0f*n_dot_l*n_dot_v);
      float F_c = pow(1.0f - v_dot_h, 5);
      // float F0 = 0.5f; // reflectance at normal incidence
      // float F_c = F0 + (1-F0)*pow( 1.0f - v_dot_h, 5 );
      a += (1.0f - F_c) * G_vis;
      b += F_c * G_vis;
    }
  }
  return vec2(a, b) / num_samples;
}

void main()
{
  	OUT_Color = vec4(0);
    OUT_Color.xy = integrate_GGX(IO_uv0.x, IO_uv0.y);
  	// OUT_Color = vec4(IO_uv0, 1, 1);
}
	
#endif/************************************************************************
    Lighting things
************************************************************************/

#define DEFERRED_HACK_TO_linearRGB(val)	(val)
#define DEFERRED_HACK_TO_sRGB(val)		(val)

#include <common_light.h>
#include <../../extensions/X4FoundationShaderMod-main/shadergl/shaders/jm_includes/jm_lighting_functions.h>

int IrradianceLevel()
{
	return int(F_ibl_maxvalidlevel);
}

int IrradianceLevel(samplerCube filtered_env_map)
{
	return textureQueryLevels(filtered_env_map) - 1;
}

float smooth2rough(in float smoothness) {
	return saturate(1.01f - smoothness);
	return 0.0001f + (1-smoothness) * (1-smoothness);
}

// redirect reflection based on roughness
float3 get_lobe_dominant_dir(float3 N, float3 R, float roughness) {
	float smoothness = saturate(1 - roughness);
	float lerpFactor = smoothness * (sqrt(smoothness) + roughness);
	return lerp(N, R, lerpFactor);
}

// DFG term approx
float3 DFGAnalytic( float3 cspec, float gloss, float n_dot_v ) {
    float x = gloss;
    float y = n_dot_v;

    float b1 = -0.1688;
    float b2 = 1.895;
    float b3 = 0.9903;
    float b4 = -4.853;
    float b5 = 8.404;
    float b6 = -5.069;
    float bias = saturate( min( b1 * x + b2 * x * x, b3 + b4 * y + b5 * y * y + b6 * y * y * y ) );

    float d0 = 0.6045;
    float d1 = 1.699;
    float d2 = -0.5228;
    float d3 = -3.603;
    float d4 = 1.404;
    float d5 = 0.1939;
    float d6 = 2.661;
    float delta = saturate( d0 + d1 * x + d2 * y + d3 * x * x + d4 * x * y + d5 * y * y + d6 * x * x * x );
    float scale = delta - bias;

    bias *= saturate( 50.0 * cspec.y );
    return cspec * scale + bias;
}

// simple tonemapping
float A = 0.15;
float B = 0.50;
float C = 0.10;
float D = 0.20;
float E = 0.02;
float F = 0.30;
float W = 11.2;

// uncharted2/naughty dog tonemap
// (cmp. http://filmicgames.com/archives/75 https://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/)
float3 u2Tonemap(float3 x)
{
	return ((x*(A*x + C*B) + D*E) / (x*(A*x + B) + D*F)) - E / F;
}


/************************************************************************
    IBL + sampling
************************************************************************/
float G_Schlick_GGX(float k, float n_dot_v)
{
	return n_dot_v / (n_dot_v * (1.0f - k) + k);
} 
float G_Smith(float k, float n_dot_v, float n_dot_l)
{
	return G_Schlick_GGX(k, n_dot_v) * G_Schlick_GGX(k, n_dot_l);
}
float D_GGX(float a2, float n_dot_h)
{
	float d = (n_dot_h * a2 - n_dot_h) * n_dot_h + 1.0;
	return a2 / (PI * d * d);
}

float V_Smith(float a, float n_dot_v, float n_dot_l)
{
	return 0.5 / (n_dot_l * (n_dot_v * (1 - a) + a) + n_dot_v * (n_dot_l * (1 - a) + a));
}
/************************************************************************
    BRDF
************************************************************************/
vec3 EvalBRDF(	in vec3 cspec, 
				in vec3 cdiff, 
				in float roughness, 
				in vec3 l, 
				in vec3 v, 
				in vec3 n,
				in vec3 mask, 
				in float subsurface, 
				in float roughness_epidermal, 
				in vec3 csub,
				in vec3 nsub,
				in bool fullV)
{
	float n_dot_v_raw = dot(n, v);
#ifdef JM_USE_STRICTER_N_DOT_V
    CONST float e = 0.0001f;
	float n_dot_v = saturate(abs(n_dot_v_raw)) * (1.0 - e) + e;//the n and v are normalized, we shouldn't need the clamp
#else	
    CONST float e = 0.00000001f;
	float n_dot_v = saturate(abs(n_dot_v_raw)+e);
	// float n_dot_v = max(e, dot(n, v));
#endif
	vec3 h = normalize(v+l);
	float n_dot_l_raw = dot(n, l);
	float n_dot_l = saturate(n_dot_l_raw);
	float n_dot_h = saturate(dot(n, h));
	float l_dot_h = saturate(dot(l, h));//same as v_dot_h? TODO confirm
	float v_dot_h = saturate(dot(v, h));
/*	
	float a = roughness*roughness;
	// a = roughness; // test
	float a2 = a*a;
	float k = a/2;
	
	float d = (n_dot_h * a2 - n_dot_h) * n_dot_h +1;
	float D = (a2 / ( PI*d*d) );
	// float D = (a2 / max(e, PI*d*d) );
*/	
	float D = D_GGX(pow4(roughness), n_dot_h);//note if subdermal roughness, it's already in this term!
	//course_notes_moving_frostbite_to_pbr_v32
// 	float V = 0.5 * 1.0/( n_dot_l * ( n_dot_v * (1-a)+a) + n_dot_v * ( n_dot_l * (1-a)+a));

#ifdef JM_USE_LUMINANCE_FRESNEL
	vec3 F = schlick_f(cspec, v_dot_h);
#else
	float f = pow(1-v_dot_h, 5);
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	vec3 F = f + (1-f) * cspec;
#endif
	float f_diff = pow(1-n_dot_v, 5);
	// 	vec3 diff = f_diff + (1-f_diff) * cdiff;
	// energy conservation using reflectance luminance
	// vec3 albedo = cdiff * saturate( 1.0f - dot(LUM_ITU601, cspec));
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	D = mix(D, D_GGX(pow4(roughness_epidermal), n_dot_h), subsurface);
	roughness = mix(roughness, roughness_epidermal, subsurface);
	csub = sss_direct_approx(abs(dot(l, nsub)), csub, cdiff);
#endif	
	float a = pow2(roughness);
	float a2 = pow2(a);
	vec3 diff = vec3(0.0);
#ifdef JM_USE_RETROREFLECTIVE_DIFFUSE_MODEL
	cdiff *= chan_diff(a2, n_dot_v, n_dot_l, v_dot_h, n_dot_h, 1.0, cspec);
#else
	cdiff *= (1.0 / PI) * saturate(1.0f - dot(LUM_ITU601, cspec));
#endif
//	float cspec_epidermal = 0;
	// return vec3(v_dot_h);
	// return (cdiff/PI);
//	float V = 0.5 * 1.0 / max(e, n_dot_l * (n_dot_v * (1-a)+a) + n_dot_v * (n_dot_l * (1-a)+a));//happens with MSAA on mesh edges, there are other ways to catch it (e.g. early per-light if (n_dot_l <= 0) discard) but this seems the most universal at first glance? although it could result in more pronounced highlights at edges? TODO @Timon/Markus test

	float V = 0.25;
	if(fullV)
	{
		V = V_Smith(a, n_dot_v, n_dot_l);
	}
	float specular_aliasing_kill = saturate(n_dot_v_raw * 200.0 + 1.0);//the normals can point around the horizon, which makes a mess with the specular!
	mask *= vec3(JM_GLOBAL_DIFFUSE_INTENSITY, JM_GLOBAL_SPECULAR_INTENSITY, JM_GLOBAL_SUBSURFACE_INTENSITY);
	
	return cdiff * mask.x + (D * V * mask.y * specular_aliasing_kill) * F + csub * mask.z;
}
//overloads
vec3 EvalBRDF(in vec3 cspec, in vec3 cdiff, in float roughness, in vec3 l, in vec3 v, in vec3 n)
{
	return EvalBRDF(cspec, cdiff, roughness, l, v, n, vec3(vec2(1.0), 0.0), 0.0, 0.0, vec3(0.0), n, false);
}
vec3 EvalBRDF(in vec3 cspec, in vec3 cdiff, in float roughness, in vec3 l, in vec3 v, in vec3 n, in vec2 mask)
{
	return EvalBRDF(cspec, cdiff, roughness, l, v, n, vec3(mask, 0.0), 0.0, 0.0, vec3(0.0), n, false);
}

// simplified cook torrance
vec3 EvalBRDFSimple(in vec3 cspec, in vec3 cdiff, in float roughness, in vec3 l, in vec3 v, in vec3 n) {
	
	vec3 h = normalize(v+l);
	float n_dot_l = saturate(dot(n, l));
	float n_dot_h = saturate(dot(n, h));
	
	float a = roughness*roughness;
	float a2 = a*a;
	float k = a/2;
	
	float d = (n_dot_h * a2 - n_dot_h) * n_dot_h +1;
	float D = (a2 / ( PI*d*d) );
	float V = 0.25;
	vec3 F = cspec;
	return (cdiff/PI) + (D*V*F);
}
// simplified cook torrance returning specular color only
vec3 EvalBRDFSimpleSpec(in vec3 cspec, in float roughness, in vec3 l, in vec3 v, in vec3 n) {

	CONST vec3 h = normalize(v + l);
	CONST float n_dot_h = saturate(dot(n, h));

	//float a = roughness*roughness;
	CONST float a2 = roughness*roughness*roughness*roughness;
	

	CONST float d = (n_dot_h * a2 - n_dot_h) * n_dot_h + 1;
	CONST float D = (a2 / (PI*d*d));
	CONST float V = 0.25;
	CONST vec3 F = schlick_f(cspec, saturate(dot(h, v)));
	return (D*V*F);
}
/************************************************************************
    Area lights
************************************************************************/
// area local lights, modify light direction + energy
float EvalSphereLight(float radius, vec3 center, vec3 v, vec3 n, vec3 R, float roughness, out vec3 L) {

	float m = roughness*roughness;
	// m = roughness; // test, needed?
	float invdistance = 1 / sqrt(dot(center, center));
	
	// representative point method for area specular
	float3 centertoray = dot( center, R ) * R - center; // vector from sphere center to closest point on ray
	float3 pointsurface = center + centertoray * saturate( radius / sqrt( max(0.0001f, dot( centertoray, centertoray ) ) )); // closest point on sphere surface
	L = (pointsurface);
	// L = normalize(pointsurface);
	
	// sphere energy normalization
	float sphereangle = saturate( radius * invdistance );
	float spherenorm = m / saturate( m + 0.5 * sphereangle );
	// other spherenorm
	spherenorm = 1.0 / (1.0 + (1.0 / (PI * max(0.001f, m)))*sphereangle);
	return spherenorm;
	return spherenorm * spherenorm;
}

float EvalTubeLight(float radius, vec3 l0, vec3 l1, vec3 v, vec3 n, vec3 R, float roughness, out vec3 L) {
	float m = roughness*roughness;
	 m = roughness; // test
	float tube_length = length(l1 - l0);
	vec3 tubecenter = (l0+l1)/2;
	float invdistance = 1 / sqrt(dot(tubecenter, tubecenter));

	// closest point on line
	float3 L01 = l1 - l0; // tube line
	float a = pow( tube_length , 2);
	float b = dot( R, L01 );
	float t = saturate( dot( l0, b*R - L01 ) / (a - b*b) );
	vec3 linepoint = l0 + t * L01; // closest point on tube

	float tubenorm = m / saturate(m + 0.5 * saturate(tube_length * invdistance));

	// apply sphere approx
	return tubenorm * EvalSphereLight(radius, linepoint, v, n, R, roughness, L);
}

/************************************************************************
    Image based lighting
************************************************************************/

vec4 spec_first_sum_ibl(samplerCube filtered_env_map, float roughness, vec3 normal, vec3 view)
{
	vec3 R = reflect(-view, normal);

	// R = mix( R, get_lobe_dominant_dir(normal, R, rm),rm*rm);
	// R = get_lobe_dominant_dir(normal, R, rm);

	// sqrt to compensate for precision shift
	float sqrtrough = (roughness); //sqrt(roughness);
	//TODO @Timon/Florian/Markus that sqrt was important for correctness, we should look into un-fuck-up-ing it
	return textureLod(filtered_env_map, R, MaxSpecularLevel(filtered_env_map) * sqrtrough);
}

vec4 spec_first_sum_ibl(samplerCube filtered_env_map, float roughness, vec3 reflectdir)
{
	// sqrt to compensate for precision shift
	float sqrtrough = (roughness); //sqrt(roughness);
	//TODO @Timon/Florian/Markus that sqrt was important for correctness, we should look into un-fuck-up-ing it

	return textureLod(filtered_env_map, reflectdir, MaxSpecularLevel(filtered_env_map) * sqrtrough);
}

vec3 spec_brdf(vec3 first_sum, vec3 spec_color, float roughness, float n_dot_v)
{
	//float fslum = length(first_sum);
	//first_sum = pow(first_sum, vec3(3)) * 4;
	//first_sum = pow(first_sum, vec3(3))*2 ;
	//return first_sum;

	vec2 env_brdf = textureLod(T_preintegrated_GGX, vec2(roughness, n_dot_v), 0).xy;
	return first_sum * (spec_color * env_brdf.x + env_brdf.y);
}

vec4 spec_brdf_ibl4(samplerCube filtered_env_map, vec3 spec_color, float roughness, vec3 reflectdir, float n_dot_v)
{
	vec4 first_sum = spec_first_sum_ibl(filtered_env_map, roughness, reflectdir);
	return vec4(spec_brdf(first_sum.rgb, spec_color, roughness, n_dot_v), first_sum.a);
}

vec3 spec_brdf_ibl(samplerCube filtered_env_map, vec4 refl_override, vec3 amblight, vec3 spec_color, float roughness, vec3 normal, vec3 view)
{
	float n_dot_v = saturate(dot(normal, view));

	vec3 first_sum = mix(spec_first_sum_ibl(filtered_env_map, roughness, normal, view).rgb, refl_override.rgb, refl_override.a);
	first_sum += amblight;

	return spec_brdf(first_sum, spec_color, roughness, n_dot_v);
}

vec3 spec_brdf_ibl(vec4 refl_override, vec3 amblight, vec3 spec_color, float roughness, vec3 normal, vec3 view)
{
	return spec_brdf_ibl(T_ibl_envmap, refl_override, amblight, spec_color, roughness, normal, view);
}

vec3 simple_spec_brdf_ibl(samplerCube filtered_env_map, vec3 spec_color, float roughness, vec3 normal, vec3 view) {

	float n_dot_v = saturate(dot(normal, view));
	vec3 R = reflect(-view, normal);

	// sqrt to compensate for precision shift
	float sqrtrough = sqrt(roughness);
	vec3 first_sum = textureLod(filtered_env_map, R, MaxSpecularLevel(filtered_env_map) * sqrtrough).rgb;

	first_sum = DEFERRED_HACK_TO_linearRGB(first_sum);
	
	//return DFGAnalytic(spec_color, 1-roughness, n_dot_v);
	return first_sum * DFGAnalytic(spec_color, 1-roughness, n_dot_v);
}

vec3 get_irradiance(samplerCube filtered_env_map, in vec3 n) {
	vec3 irradiance = textureLod(filtered_env_map, n, IrradianceLevel(filtered_env_map)).rgb;
	irradiance = DEFERRED_HACK_TO_linearRGB(irradiance);
	return irradiance;
}

void get_colors(in vec3 albedo, in float metalness, out vec3 cspec, out vec3 cdiff) {
	#ifdef JM_DEBUG_GREY_WORLD
		albedo = vec3(1.0);
	#endif
    cdiff = albedo * (1.0-metalness);
    cspec = mix(vec3(0.04), albedo, metalness);
	cdiff = cdiff * saturate(1.0f - dot(LUM_ITU601, cspec)); // cheap luminance energy conservation
}

// simplified forward lighting, no ssao, no shadows
vec3 simple_light(in vec3 clight, in vec3 l, in vec3 n, in vec3 v, in vec3 albedo, in float metalness, in float roughness)
{
    vec3 cspec;
    vec3 cdiff;
/*
	//include is not included here, and simple_light is not used by Egosoft
	#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
		float Subsurface = 0.0;
		UnpackMetalSubsurface(metalness, Subsurface);
	#endif
*/	

   get_colors(albedo, metalness, cspec, cdiff);
	float n_dot_l = saturate(dot(n, l));
    
    vec3 result = vec3(0);
    result += EvalBRDF(cspec, cdiff, roughness, l, v, n) * clight * n_dot_l;

	vec3 wv = v * mat3(M_view);
	vec3 wn = n * mat3(M_view);
	wv = v;
	wn = n;

    vec3 spec_amb = simple_spec_brdf_ibl(T_ibl_envmap, cspec, roughness, wn, wv);
	vec3 diff_amb = cdiff * get_irradiance(T_ibl_envmap, wn);

	vec3 ambientlight = spec_amb + diff_amb;

    result += ambientlight;
	// result = cdiff;
	result.rgb = DEFERRED_HACK_TO_sRGB(result);
    return result;
}

float GetSSAO()
{
	if (B_ssao_enabled) {
		return RTResolveSoft(T_occlusionresolve_swap).r;
	}
	return 1.0;
}
#include <common.fh>
 

USE_TEXTURE_LIGHTING
//USE_SHADOW_MAP
DEF_LIGHT_AMBIENT(1)
DEF_LIGHT_DIR(1)
DEF_LIGHT_DIR(2)
DEF_LIGHT_DIR(3)


void main()
{

    // CONST mat4x3 inCOLORMATRIX_EYE = make_ColorMatrix(EyeBrightness, EyeContrast, EyeSaturation, EyeHue)
	CONST mat4x3 inCOLORMATRIX_EYE = make_ColorMatrix(U_eyeball_brightness_shift, U_eyeball_contrast_shift, U_eyeball_saturation_shift, U_eyeball_hue_shift);
 

	CONST half3 VertexToEye = normalize(IO_VertexToEye.xyz);	// V

	half4 ColorBaseDiffuse = half4(TO_linearRGB(S_diffuse_color.rgb), 0.0);
	half4 ColorBaseDiffuseSub = half4(1.0, 1.0, 1.0, 0.0);

	float SmoothnessVal = U_smoothness;
	float MetalnessVal = U_metallness;
	_IF(S_smooth_bool)
	{
		SmoothnessVal *= tex2D(S_smooth_map, IO_uv0).r;
	}

	_IF(S_metal_bool)
	{
		MetalnessVal *= tex2D(S_metal_map, IO_uv0).r;
	}

	_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
	{
		ColorBaseDiffuse = tex2D(S_diffuse_map, IO_uv0).rgba;	//Base Diffuse + alpha
		ColorBaseDiffuse.rgb = mul(inCOLORMATRIX_EYE, ColorBaseDiffuse.rgb).rgb * S_diffusestr;
	}
	CONST half3 diffnorm = ColorBaseDiffuse.rgb;
	
	
	INPUT_NTB_TWOSIDED()
	
	float3 Normal = vec3(0);
	STANDARD_NORMAL_DETAIL_MAP(Normal)
	
	
	// Shadow value, Ohoh we just have shadow calced for the main light so we only need to darken the light we have for the first global ? (does this always match?)
	float Shadow = 1.0f;
	_IF(B_shadow)
	{
		Shadow = GetShadow();
		// for now shadows only apply to solid geometry
		//		Shadow = saturate(Shadow + (1.0 - F_alphascale)); // TODO: Bug -> last 20% dont work correctly we have a offset 0.1->0.2 somewhere
	}

	vec3 ColorGlow = vec3(0.1f)* fresnel(VertexToEye, Normal, 3.0f) * ((1.0 + 2.0f*SmoothnessVal) / 3.0)*ColorBaseDiffuse.rgb;
	
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	float SubsurfaceVal = 0.9;
	ColorBaseDiffuse.rgb = bit_pack_albedo_normal(ColorBaseDiffuse.rgb, normalize(mix(Normal, IO_normal, SubsurfaceVal)), SubsurfaceVal);
	GENERAL_OUTPUT_SUBSURFACE(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SubsurfaceVal, SmoothnessVal, ColorGlow);
#else	
	GENERAL_OUTPUT(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SmoothnessVal, ColorGlow);
#endif		 
}
#define P1_SHADERS
#include <common.fh>
 

USE_TEXTURE_LIGHTING

DEF_LIGHT_AMBIENT(1)
DEF_LIGHT_DIR(1)
DEF_LIGHT_DIR(2)


void main()
{
	float SmoothnessVal = U_smoothness;
	float MetalnessVal = U_metallness;
	_IF(S_smooth_bool)
	{
		SmoothnessVal *= tex2D(S_smooth_map, IO_uv0).r;
	}

	_IF(S_metal_bool)
	{
		MetalnessVal *= tex2D(S_metal_map, IO_uv0).r;
	}

	half4 ColorBaseDiffuse = S_diffuse_color.rgba;
	_IF(S_diffuse_bool)
	{
		ColorBaseDiffuse.rgba = tex2D(S_diffuse_map, IO_uv0).rgba;
		if (S_diffuse_color.rgb != float3(1.0f, 1.0f, 1.0f))
		{
			ColorBaseDiffuse.rgba *= S_diffuse_color.rgba;
		}
	}


	//AlphaTest(ColorBaseDiffuse.a * F_alphascale);

	_IF(S_diffuse_detail_bool)
	{
		half4 DiffDetailv = tex2D(S_diffuse_detail_map, IO_uv0 * S_diffuse_detail_tiling).rgba * S_diffuse_detailstr;
		ColorBaseDiffuse.rgb = (ColorBaseDiffuse.rgb*DiffDetailv.rrr);
		SmoothnessVal = blendOverlay(SmoothnessVal, DiffDetailv.g);
		MetalnessVal = blendOverlay(MetalnessVal, DiffDetailv.b);
	}




	_IF(B_vertexdata0)
	{
		// NOTE: none blend areas need 128 grey!
		//ColorBaseDiffuse.rgb = blendOverlay(ColorBaseDiffuse.rgb, IO_colorRGB_specstrA.rgb);
		if (S_diffuse_color.rgb == float3(1.0f, 1.0f, 1.0f))
		{
			ColorBaseDiffuse.rgb = ColorBaseDiffuse.rgb* IO_colorRGB_specstrA.rgb;
		}
		//	SmoothnessVal *= IO_colorRGB_specstrA.a; //disabled, this causes some assets to loose smoothness!
		//TexSpecularStrPure = saturate(blendOverlay(TexSpecularStr.rgb,TO_linearRGB(IO_colorRGB_specstrA.rgb)));

	}
	CONST half3 diffnorm = ColorBaseDiffuse.rgb;

	_IF(S_diffuse_paint_bool) // after VertexColors
	{
		// blend in the paint layer
		CONST half4 ColorPaint = S_diffuse_paintstr * tex2D(S_diffuse_paint_map, IO_uv_paint).rgba;
		// we want to keep the black areas in the diffusemap so dont blend if luminance is low.
		ColorBaseDiffuse.rgb = blendAlpha(ColorBaseDiffuse.rgb, ColorPaint.rgb, ColorPaint.a);// * saturate(3.0 * luminance(ColorBaseDiffuse.rgb)));
																							  // reduce the specular on locations where we add paint.
																							  //test deactivated
		ColorBaseDiffuse.a = saturate(ColorBaseDiffuse.a+ColorPaint.a);
		CONST half specstrmod = lerp(1.0, 0.15, saturate(2.0 * ColorPaint.a));
		//	TexSpecularStr.rgb *= specstr;
		SmoothnessVal *= specstrmod;
		MetalnessVal *= specstrmod;
	}


	half3 ColorGlow = S_color_glow_color.rgb;
	_IF(S_color_glow_bool)
	{
		half4 val = S_color_glowstr * tex2D(S_color_glow_map, IO_uv0) * U_mat_dynamicglow;
		ColorGlow = val.rgb;
		ColorGlow *= 1 + val.a * (10 - 1);		//boost multiplier 1-10x (TODO @Timon @Markus decide range)
	}

	// apply the additional detail/structure layers	
	_IF(B_vertexdata1)
	{
		_IF(S_color_dirt_bool)
		{
			// blend in age layer, vertex need to be GREY on none apply areas
			CONST half4 ColorDirt = tex2D(S_color_dirt_map, IO_uv0 * S_color_dirt_tiling).rgba;
			CONST half3 ColorBaseDirt = blendMultiply(ColorBaseDiffuse.rgb, ColorDirt.rgb);
			CONST float dirtFactor = IO_damage_detail_age.b*S_color_dirtstr;
			ColorBaseDiffuse.rgb = blendAlpha(ColorBaseDiffuse.rgb, ColorBaseDirt.rgb, dirtFactor);
			ColorBaseDiffuse.a = saturate(ColorBaseDiffuse.a+ColorDirt.a* dirtFactor);
			//MetalnessVal = blendMultiply(MetalnessVal, min((ColorDirt.a* IO_damage_detail_age.b*S_color_dirtstr),1.0f));
			SmoothnessVal -= blendMultiply(SmoothnessVal, (1.0f - ColorDirt.a)*dirtFactor);
		}
	}
	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	Combining 2 normal maps
	Artists wanted detail normal maps
	Blending 2 normal maps just flattens both
	Want to get results as if blending 2 heightmaps
	Warp 2nd normal map
	using normals from the 1st normal map:
	float3x3 nBasis = float3x3(
	float3 (n1.z, n1.x,-n1.y),
	float3 (n1.x, n1.z,-n1.y),
	float3 (n1.x, n1.y, n1.z ));
	n = normalize (n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	INPUT_NTB_TWOSIDED()
	
	float3 Normal = vec3(0);
	STANDARD_NORMAL_DETAIL_MAP(Normal)
	
	
	float backfaceFactor = 1.0f;
	if (gl_FrontFacing) {
		backfaceFactor = (0.8f - min(pow(ColorBaseDiffuse.a, 0.40f), 0.80f));
	}
	CONST half3 VertexToEye = normalize(IO_VertexToEye.xyz).xyz;

	float specShadow = 1.0f;
	float envShadow = 1.0f;
	_IF(B_shadow)
	{
		float n_dot_l = max(0.0f, dot(V_direction1.xyz, Normal.xyz));
		specShadow = GetShadow(n_dot_l);
		envShadow = (specShadow + 0.50f) / 1.50f; // Boost shadow values for envmap influence due to it being more like an ambient effect.
	}

	float Roughness = smooth2rough(SmoothnessVal);
	half3 ColorEnvi = S_environmentstr * global_envmap_resolve_glass(Normal, VertexToEye, Roughness, envShadow).rgb;

	//float fresnel(CONST float3 V, CONST float3 N, CONST half Power, CONST half Str, CONST half minRange)
/*	float fresnel_fac = fresnel(VertexToEye, Normal, 2.0, 1.0, 0.20);
	ColorEnvi.rgb *= vec3(fresnel_fac);
	*/

	//change the reflectivity based on light direction
	//also change the fresnel based on light direction??

	float ndl = max(0.0f, dot((V_direction1.xyz), Normal.xyz));
	//float ndl = max(0.0f, dot(Normal.xyz, normalize(V_direction1.xyz)));
	//ColorEnvi.rgb *= vec3(max(0.025, (0.5+ndl)/1.5));
	ColorEnvi.rgb = ColorEnvi.rgb*(1.0-U_env_dir_influence) + ColorEnvi.rgb*vec3(max(0.025, (U_dir_min + ndl) / (1.0-U_dir_min)))*U_env_dir_influence;
	//float fresnel_fac = fresnel(VertexToEye, Normal, (0.50+(1.0-ndl))/1.5, 1.0, 0.00);
	float fresnel_fac = fresnel(VertexToEye, Normal, U_fresnel_power, 1.0, U_fresnel_min);
	
	ColorEnvi.rgb = ColorEnvi.rgb*(1.0-U_fresnel_influence)+ColorEnvi.rgb*vec3(fresnel_fac)* U_fresnel_influence;
	
/*	if (luminance(ColorEnvi.rgb) > 0.051) {
		ColorEnvi.rgb *= max(0.0,1.0- luminance(ColorEnvi.rgb)*4.0);// normalize(ColorEnvi.rgb);
	}*/

	
//	OUT_Color.a = 0.8f;
//	OUT_Color.rgb = ColorEnvi;	return;
// 	OUT_Color.rgb = abs(GetFragWorld() / 5000);		return;
// 	OUT_Color.rgb = abs(inverse(M_envmapprobe_world[0]) * vec4(GetFragWorld(), 1)).xyz;		return;

	_IF(S_envi_light_bool)
	{
		ColorEnvi.rgb += envShadow * S_envi_lightstr * texture(S_envi_light_map, reflect(-VertexToEye, Normal)).rgb;
	}
	if (gl_FrontFacing)
	{
		ColorEnvi.rgb *= backfaceFactor;
	}

	//------------------------------
	
	OBJECTRENDERMODE_SOLID()

	CONST float light_radius = V_deferred_lightparams.x * 10; // dbg scale

	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	vec3 Albedo = ColorBaseDiffuse.rgb;
	float Metalness = MetalnessVal;



	float3 ldir =  normalize(V_direction1.xyz);
	float3 lcolor = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale;// todo: slightly refactor the following
	
	//float3 lcolor = normalize(V_lightcolor1.rgb * F_globallightscale);// todo: slightly refactor the following
	
	float direct_occlusion = saturate(dot(ldir, Normal));
	float direct_occlusion2 = saturate(dot(-ldir, Normal));
//	vec3 view_pos;
//	RetrieveZBufferViewPos(view_pos);

	//vec3 v = normalize(-view_pos);
	vec3 v = normalize(VertexToEye);
	vec3 R = reflect(v, Normal);

	
	vec3 L;
	vec3 L2;
	vec3 E_sph = direct_occlusion * lcolor * EvalSphereLight(light_radius, ldir * 1000, v, Normal, R, Roughness, L);// +simple_light(lcolor, ldir, Normal.xyz, v, Albedo, Metalness, Roughness);
	vec3 E_sph2 = direct_occlusion2 * lcolor * EvalSphereLight(light_radius, -ldir * 1000, v, Normal, R, Roughness, L2);// +simple_light(lcolor, ldir, Normal.xyz, v, Albedo, Metalness, Roughness);
	//E_sph *= PI; // diffuse normalization
	L = normalize(L);
	L2 = normalize(L2);
	vec3 light_accum = ColorBaseDiffuse.rgb;// -ColorBaseDiffuse.rgb;// vec3(0);


	get_colors(Albedo, Metalness, cspec, cdiff);
	if (gl_FrontFacing)
	{
		cspec *= backfaceFactor;
	}

	//light_accum += ColorBaseDiffuse.rgb*(ColorBaseDiffuse.a) + EvalBRDF(cspec, cdiff, Roughness, L, v, Normal, vec2(ColorBaseDiffuse.a, 1)) *E_sph*ColorBaseDiffuse.a +ColorEnvi.rgb; // specular
	light_accum += specShadow * EvalBRDF(cspec, cdiff, Roughness, L, v, Normal, vec2(ColorBaseDiffuse.a, 1)) * E_sph * ColorBaseDiffuse.a;  // specular
	light_accum += specShadow * EvalBRDF(cspec, cdiff, Roughness, L2, v, Normal, vec2(ColorBaseDiffuse.a, 1)) * E_sph2 * ColorBaseDiffuse.a; // specular 2
	light_accum += ColorEnvi.rgb;
	//light_accum += ColorBaseDiffuse.rgb*(ColorBaseDiffuse.a) + EvalBRDF(cspec*ColorBaseDiffuse.a, cdiff*ColorBaseDiffuse.a, Roughness, L, v, Normal, vec2(ColorBaseDiffuse.a, 1)) *E_sph +ColorEnvi.rgb; // specular

	float t = dot(ldir, -VertexToEye) * U_backlitfactor;
	float cutoff = 0.95f;
	if (t > cutoff )
	{
		float vt = pow((t - cutoff) / (1.0f - cutoff), 2.0f);
		vec3 newCol = lerp(ColorBaseDiffuse.rgb * 0.0, ColorBaseDiffuse.rgb * 10.0, vt);
		light_accum += newCol;//*max( length(newCol.xyz) ,1.0);
		ColorBaseDiffuse.a += min(vt*4.0f*ColorBaseDiffuse.a,0.1f);
		ColorBaseDiffuse.a = saturate(ColorBaseDiffuse.a);
	}
	
	
	OUT_Color = float4(light_accum.xyz, saturate(ColorBaseDiffuse.a + min( length(light_accum.xyz) ,0.1)));// + saturate(1.0f - pow(dot(Normal, VertexToEye), 0.1f))*0.25f));
	//OUT_Color = float4(ColorBaseDiffuse.rgb, 1);
	//OUT_Color = float4(light_accum.xyz, ColorBaseDiffuse.a);
	//OUT_Color = float4(light_accum.xyz, saturate((ColorBaseDiffuse.a + length(light_accum.xyz)*0.25f) + saturate(1.0f - pow(dot(Normal, VertexToEye), 0.1f))*0.25f));
	//float a = saturate(1.0f - pow(dot(Normal, VertexToEye), 0.02f));
	//OUT_Color = float4(a,a,a,1);
	//OUT_Color = float4(E_sph.xyz,1.0f);
	//OUT_Color = float4(1, 0, 0, 1);
}

#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
//#define SPEC_BOOST 2.0
//#define DIFF_BOOST 1.0
//#define SPEC_POWER 1.0 // 15.0

// instance data
in vec3 IO_lightcolor;
in float IO_Intensity;
in vec3 IO_RadiusSizeXY;
in float IO_spotatten;
in float IO_SpecIntensity;
in float IO_Range;

in vec3 IO_Apex;
in vec3 IO_Direction;
in vec3 IO_right;
in vec3 IO_up;

in vec3 IO_view_center;

// currently unused
// in mat4 IO_areaaxis;


//float3 projectOnPlane(float3 p, float3 pc, float3 pn)
//{
//	float distance = dot(pn, p-pc);
//	return p - distance*pn;
//}
//
//int sideOfPlane(float3 p, float3 pc, float3 pn)
//{
//	if (dot(p-pc,pn)>=0.0) return 1; else return 0;
//}
//
//float isInBox (float3 p, float3 Apex, float3 Direction, float3 right, float3 up, float3 RangeSizeXY)
//{
//	if (sideOfPlane(p,Apex,Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x,-Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+right*RangeSizeXY.y*0.5f,-right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-right*RangeSizeXY.y*0.5f,right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+up*RangeSizeXY.z*0.5f,-up) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-up*RangeSizeXY.z*0.5f,up) == 0) return 0;
//
//	return 1;
//}


#ifdef LPASS_AREA_PLANE
#if 1
vec3 planeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;

	// vec3 planeNormal = IO_Direction;
	float t = dot( L, IO_Direction ) / dot( dir, IO_Direction );
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2( dot(r,IO_right), dot(r,IO_up) );

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if( !onSurface ) {
		vec3 bestP = L;
		float bestDot = 0.0;

		for( int i=0; i<4; ++i ) { // todo: simplify/vectorize?

			// axis and size
			vec3 ld = i>1 ? IO_right : IO_up;
			vec2 sz = i>1 ? lsize.xy : lsize.yx;

			// vector to edge center
			vec3 l0 = L + sz.y * (i>1 ? IO_up : IO_right) * ((i%2)!=0 ? -1.0 : 1.0);
			// vec3 l0 = L + IO_areaaxis[i].xyz;
				
			float dirL0 = dot(dir,l0);
			float dirld = dot(dir,ld);
			float l0ld = dot(l0,ld);
			float t = (l0ld*dirL0 - dot(l0,l0)*dirld) / (l0ld*dirld - dot(ld,ld)*dirL0); // magic
			t = clamp( t, -sz.x, sz.x );
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot( normalize(P), dir );
			if( dp > bestDot ) {
				bestP = P;
				bestDot = dp;
			}
		}
		return bestP;
		// L = bestP;
	}
	else {
		return p0;
		// L = p0;
	}
}
#else
// potentially slightly faster version
vec3 planeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float t = dot(L, IO_Direction) / dot(dir, IO_Direction);
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2(dot(r, IO_right), dot(r, IO_up));

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if (!onSurface) {
		vec3 bestP = L;
		float bestDot = 0.0;

		vec3 lda[4] = vec3[](IO_up, IO_up, IO_right, IO_right);
		vec2 sza[4] = vec2[](lsize.yx, lsize.yx, lsize.xy, lsize.xy);

		for (int i = 0; i<4; ++i) { // todo: simplify/vectorize?

			vec3 ld = lda[i];
			vec2 sz = sza[i];

			// vector to edge center
			vec3 l0 = L + IO_areaaxis[i].xyz;

			float dirL0 = dot(dir, l0);
			float dirld = dot(dir, ld);
			float l0ld = dot(l0, ld);
			float t = (l0ld*dirL0 - dot(l0, l0)*dirld) / (l0ld*dirld - dot(ld, ld)*dirL0);
			t = clamp(t, -sz.x, sz.x);
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot(normalize(P), dir);
			if (dp > bestDot) {
				bestP = P;
				bestDot = dp;
			}
		}

		return bestP;
	}
	else {
		return p0;
	}
}
#endif
#endif

#ifdef LPASS_AREA_TUBE
vec3 tubeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float tubeLength = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_RadiusSizeXY.y : IO_RadiusSizeXY.z;
	vec3 tubeDir = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_right : IO_up;

	float dirL0 = dot(dir, L);
	float dirLd = dot(dir, tubeDir);
	float l0ld = dot(L, tubeDir);
	float t = (l0ld*dirL0 - dot(L, L)*dirLd) / (l0ld*dirLd - dot(tubeDir, tubeDir)*dirL0);
	t = clamp(t, -tubeLength, tubeLength);
	vec3 P = L + t*tubeDir;
	return P;
}
#endif

#ifndef LPASS_AREA_POINT
vec3 sphereRPM(in vec3 dir, in vec3 L, float lradius) {
	//closest point on sphere to ray
	vec3 closestPoint = dot(L, dir) * dir;
	vec3 centerToRay = closestPoint - L;
	float t = lradius / sqrt( dot(centerToRay, centerToRay) );
	// L = L + centerToRay * saturate(t);
	return L + centerToRay * saturate(t);
}
#endif

float getPhysicalAtt(in vec3 lraw) {
	// CONST float invSqScale = 1.0/5.0; // better color behavior over large distances
	CONST float invSqScale = 1.0; // no scaling
	// return 1.0 / ( 1 + dot(lraw, lraw)); // "inverse square" attenuation
	float dst = max(0.0f, length(lraw) - IO_RadiusSizeXY.x) * invSqScale;
	//float dstFromSurfaceSq = max(0.0f, dot(invSqScale*lraw, invSqScale*lraw));
	//float dstFromSurfaceSq = dot(invSqScale*lraw, invSqScale*lraw);
	//dstFromSurfaceSq = 
	return 1.0 / (1 + dst*dst); // "inverse square" attenuation
	//return 1.0 / (1 + dstFromSurfaceSq); // "inverse square" attenuation
}

// unused
// float getFillAtt(in vec3 lraw) {
// 	float cutoff = F_arealightcutoff; // 5%
// 	float atten_factor = sqrt(1.0/cutoff -1);
// 	vec3 t = (lraw/(IO_Range/2))*atten_factor;

// 	vec3 tt = lraw/(IO_Range/2);
// 	// return 1-dot(tt, tt);

// 	float scale_dst2 = dot(t, t);
// 	return saturate(1.0/(1+scale_dst2)-cutoff) * 1.0/(1.0-cutoff);
// }

void main()
{
	#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES
		float level = dot(LUM_ITU601, IO_lightcolor.rgb);
		vec3 lightcolor = vec3(level, 0.0, level * 0.5);
	#else	
		vec3 lightcolor = IO_lightcolor.rgb;
	#endif
	
	OUT_Color = vec4(0);
	
	#if 1
	
		vec3 view_pos; // needed
		RetrieveZBufferViewPos(view_pos);
	
		// light stuff
		CONST vec3 tolight = IO_view_center - view_pos;
		vec3 L = tolight; // L vector, gets modified
		float distance = sqrt(dot(tolight,tolight));
		float invDistance = 1.0 / distance;
		// vec3 direction = tolight * invDistance; // light direction
		// mainly readability
		float lradius = IO_RadiusSizeXY.x;
		vec2 lsize = IO_RadiusSizeXY.yz;
	
		if (length(tolight) >  IO_RadiusSizeXY.x+ length(IO_RadiusSizeXY.yz) + IO_Range*2.0f) {
			LPASS_SHAPE_EARLY_DISCARD()
			discard;
		}
		
		// attenuation
		// plane RPM (just clamped) for diffuse + attenuation
		float atten = 1.0f;
		vec3 ldiff = tolight;
		vec3 lraw = tolight; // from patch to closest point on ray/plane
		#if defined(LPASS_AREA_TUBE) || defined(LPASS_AREA_PLANE)
	// 	if( lsize.x + lsize.y > 0.0 )
		{
			vec3 toSource = ldiff;
			vec2 uv = vec2( dot(-toSource,IO_right), dot(-toSource,IO_up) );
			uv = clamp( uv, -lsize.xy, lsize.xy );
			toSource += uv.x*IO_right + uv.y*IO_up;
			lraw = toSource;
			// distance_atten = 1.0 / ( 1 + 0.01*dot(toSource, toSource));
		}
		#endif
		ldiff = normalize(lraw);
		float dstFromSurface = max(0.0f, length(lraw) - lradius);
		float dstNorm = (IO_Range);// / 2.0;
		float linattenA = saturate(1.0 - dstFromSurface/ dstNorm);
	
		atten *= getPhysicalAtt(lraw) * linattenA;
		
		// spot attenuation, derived from single angle
		float sp0 = saturate(IO_spotatten)*0.99;
	
		float diratten = 1;
		if(sp0 > 0)
		{
			diratten = 0.5*dot(-ldiff, IO_Direction)+0.5; // 0-1
			diratten = (diratten-sp0)/(1-sp0); // remap
			diratten = saturate(diratten);
			diratten *= diratten;
		}
		atten *= diratten;
	
		
	
		float sizeMin = min(lsize.x, lsize.y);
		float sizeMax = max(lsize.x, lsize.y);
		float sizeSum = lsize.x + lsize.y;
		CONST float threshold = 0.001f;
	
		// accumulation
		float diffuse_occlusion = 1.0f;
		vec4 finalColor = vec4(0);
		if (atten <= 0) {
			LPASS_SHAPE_EARLY_DISCARD()
			discard;
		}
		{
			vec3 Normal;
			RI_GBUFFER_NORMAL0(Normal);
			
			vec3 v = normalize(-view_pos);
			vec3 dir = reflect(-v, Normal);
		/*
		#define USE_TUBELIGHTMATH
		#ifdef USE_TUBELIGHTMATH
				if (sizeMin > threshold) {
					L = planeRPM(dir, L);
					// L = planeRPMb(dir, L);
				}
				else if (sizeMax > threshold) {
					L = tubeRPM(dir, L);
				}
		#else
				if (sizeSum > threshold) {
					L = planeRPM(dir, L);
				}
		#endif
				if (lradius > 0.0) {
					L = sphereRPM(dir, L, lradius);
				}
		*/
		#ifdef LPASS_AREA_PLANE
		// 		if (sizeMin > threshold) {
					L = planeRPM(dir, L);
					// L = planeRPMb(dir, L);
		// 		}
				if (lradius > 0.0) {
					L = sphereRPM(dir, L, lradius);
				}
				#endif
				#ifdef LPASS_AREA_TUBE
		// 		if (sizeMax > threshold) {
					L = tubeRPM(dir, L);
		// 		}
				if (lradius > 0.0) {
					L = sphereRPM(dir, L, lradius);
				}
				#endif
				#ifdef LPASS_AREA_SPHERE
					L = sphereRPM(dir, L, lradius);
				#endif
				vec3 Lnorm = normalize(L);
				
				// wrt to plane RPM
				float n_dot_l = saturate(dot(Lnorm, Normal));
		//		if (n_dot_l <= 0) {
		//			discard;
		//		}
				
				vec3 Albedo;
				float Metalness;
				float Smoothness;
				RI_GBUFFER(Normal, Albedo, Metalness, Smoothness);
		
				float Roughness = smooth2rough(Smoothness);//was Smoothness*Smoothness - changed for consistency
				#ifndef JM_ROUGHNESS_REMAP
					Roughness = max(Roughness, 0.05f); // avoid nans after squared divisions
				#endif	
				vec3 cspec = vec3(0);
				vec3 cdiff = vec3(0);
				#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
					vec3 csub = vec3(0);
					vec3 SubsurfaceNormal = Normal;
					float Subsurface = 0;
					float RoughnessEpidermal = 0.5;
					float SubsurfaceMask = 0;
					get_colors(	Albedo, 
								Metalness, 
								Roughness, 
								cspec, 
								cdiff, 
								csub, 
								SubsurfaceNormal,
								Subsurface, 
								RoughnessEpidermal, 
								SubsurfaceMask);
				#else
					
					get_colors(Albedo, Metalness, cspec, cdiff);
				#endif
		
		
				float diffndotl = saturate(dot(Normal, ldiff));
		
				// float a = max(Roughness*Roughness, 0.0001f);
				float a = Roughness*Roughness;
				float a2 = a*a;
				float norm = 1.0 / (PI * a2); // factor used for spec mod
		
				// AO used to attenuate diffuse component
				
				if (B_ssao_enabled) {
					float ambient_occlusion = GetSSAO();
					// weight strength over distance
					float ssao_weight = 0.5*(linattenA*linattenA);
					diffuse_occlusion = saturate(ambient_occlusion);
				}
				else /**/{//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
					//looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
					diffuse_occlusion = 1.0f;
				}
		
				#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
					float n_dot_l_sss = sss_wrap_dot(ldiff, SubsurfaceNormal, Subsurface) * ambient_occlusion; //since we can't shadow we approximate with this instead
					//finalColor.rgb += saturate(dot(Normal, ldiff)) * diffuse_occlusion * INVPI * lightcolor;
					vec3 h = normalize(ldiff + v);
					finalColor.rgb += (cdiff * lightcolor) * (chan_diff(a2, dot(v, Normal), diffndotl, saturate(dot(v, h)), saturate(dot(Normal, h)), 1.0, cspec) * diffuse_occlusion * diffndotl) * JM_GLOBAL_DIFFUSE_INTENSITY;
				#else	
					// diffuse contribution
					vec3 Idiff = lightcolor * diffndotl * diffuse_occlusion;
					finalColor.rgb += Idiff * cdiff/PI ;
				#endif
		
				// energy convservation using spec D mod
				float sizeGuess = lsize.x + lsize.y + lradius;
				float solidAngleGuess = saturate( sizeGuess * invDistance );
				float specatten = 1.0 / ( 1.0 + norm * solidAngleGuess );
				
				// horizon mod
				float horizon = 1.0 - n_dot_l;
				horizon *= horizon;
				horizon *= horizon;
				specatten = specatten - specatten * horizon;
				
				// specular contribution
			//	vec3 Ispec = IO_SpecIntensity * lightcolor * specatten * n_dot_l;
				// vec3 Ispec = IO_SpecIntensity * IO_Intensity * IO_lightcolor.rgb * specatten * diffndotl;
			//	finalColor.rgb += Ispec * EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec2(0,1));
				#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
					finalColor.rgb += EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec3(0.0, specatten * n_dot_l * IO_SpecIntensity, 0.0), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal, false) * lightcolor;
					#ifdef JM_SUBSURFACE_SQUARED_NDX
						float n_dot_l_abs = pow2(dot(ldiff, SubsurfaceNormal));
					#else
						float n_dot_l_abs = abs(dot(ldiff, SubsurfaceNormal));
					#endif
					finalColor.rgb += sss_direct_approx(n_dot_l_abs * diffuse_occlusion, csub, cdiff) * n_dot_l_sss * JM_GLOBAL_SUBSURFACE_INTENSITY;
				#else
					// specular contribution
					// vec3 Ispec = IO_SpecIntensity * IO_Intensity * IO_lightcolor.rgb * specatten * diffndotl;
					vec3 Ispec = IO_SpecIntensity * lightcolor * specatten * n_dot_l;
					finalColor.rgb += Ispec * EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec2(0,1));
				#endif						
			}
			finalColor.rgb *= atten;
		
		/*	if (B_render_arealightshape) {
				// draw influence outline
				if(abs(linattenA - 0.01) < 0.01 || abs(sqrt(diratten) - 0.01) < 0.01)
					finalColor.rgb = IO_lightcolor.rgb;
				if(linattenA < 0.01 || sqrt(diratten) < 0.01) {
						finalColor.rgb = vec3(0,1,0);
					if(sizeMin > threshold) { // its a plane
						finalColor.rgb = vec3(1,0,0);
					} 
					else if (sizeMax > threshold) { // a tube
						finalColor.rgb = vec3(1,1,0);
					}
				}
			}*/
		
			finalColor.rgb = clamp(finalColor.rgb, 0, 10); // safety
			finalColor.rgb = clamp(finalColor.rgb, 0, 2); // reduce flares
			finalColor.rgb *= diffuse_occlusion;
			
			OUT_Color.rgb = finalColor.rgb;
			OUT_Color.a = 0;
			
			LPASS_SHAPE_FINAL_ATTEN(atten)
		#ifdef LPASS_COUNT
			OUT_Color *= FLOAT_SMALL_NUMBER;
		
			if (IO_Intensity == 0.0) {
				discard ;
			}
			OUT_Color.rgb += 1.0f / LPASS_COUNT;
		#endif
	#else
		OUT_Color.rgb = vec3(4.0, 0.0, 2.0);
		OUT_Color.a = 1.0;	
	#endif
	
}
#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
//#define SPEC_BOOST 2.0
//#define DIFF_BOOST 1.0
//#define SPEC_POWER 1.0 // 15.0

// instance data
in vec3 IO_lightcolor;
in float IO_Intensity;
in vec3 IO_RadiusSizeXY;
in float IO_spotatten;
in float IO_SpecIntensity;
in float IO_Range;

in vec3 IO_Apex;
in vec3 IO_Direction;
in vec3 IO_right;
in vec3 IO_up;

in vec3 IO_view_center;

// currently unused
// in mat4 IO_areaaxis;


//float3 projectOnPlane(float3 p, float3 pc, float3 pn)
//{
//	float distance = dot(pn, p-pc);
//	return p - distance*pn;
//}
//
//int sideOfPlane(float3 p, float3 pc, float3 pn)
//{
//	if (dot(p-pc,pn)>=0.0) return 1; else return 0;
//}
//
//float isInBox (float3 p, float3 Apex, float3 Direction, float3 right, float3 up, float3 RangeSizeXY)
//{
//	if (sideOfPlane(p,Apex,Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x,-Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+right*RangeSizeXY.y*0.5f,-right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-right*RangeSizeXY.y*0.5f,right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+up*RangeSizeXY.z*0.5f,-up) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-up*RangeSizeXY.z*0.5f,up) == 0) return 0;
//
//	return 1;
//}

vec3 planeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;

	// vec3 planeNormal = IO_Direction;
	float t = dot( L, IO_Direction ) / dot( dir, IO_Direction );
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2( dot(r,IO_right), dot(r,IO_up) );

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if( !onSurface ) {
		vec3 bestP = L;
		float bestDot = 0.0;

		for( int i=0; i<4; ++i ) { // todo: simplify/vectorize?

			// axis and size
			vec3 ld = i>1 ? IO_right : IO_up;
			vec2 sz = i>1 ? lsize.xy : lsize.yx;

			// vector to edge center
			vec3 l0 = L + sz.y * (i>1 ? IO_up : IO_right) * ((i%2)!=0 ? -1.0 : 1.0);
			// vec3 l0 = L + IO_areaaxis[i].xyz;
				
			float dirL0 = dot(dir,l0);
			float dirld = dot(dir,ld);
			float l0ld = dot(l0,ld);
			float t = (l0ld*dirL0 - dot(l0,l0)*dirld) / (l0ld*dirld - dot(ld,ld)*dirL0); // magic
			t = clamp( t, -sz.x, sz.x );
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot( normalize(P), dir );
			if( dp > bestDot ) {
				bestP = P;
				bestDot = dp;
			}
		}
		return bestP;
		// L = bestP;
	}
	else {
		return p0;
		// L = p0;
	}
}

// potentially slightly faster version
#if 0
vec3 planeRPMb(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float t = dot(L, IO_Direction) / dot(dir, IO_Direction);
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2(dot(r, IO_right), dot(r, IO_up));

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if (!onSurface) {
		vec3 bestP = L;
		float bestDot = 0.0;

		vec3 lda[4] = vec3[](IO_up, IO_up, IO_right, IO_right);
		vec2 sza[4] = vec2[](lsize.yx, lsize.yx, lsize.xy, lsize.xy);

		for (int i = 0; i<4; ++i) { // todo: simplify/vectorize?

			vec3 ld = lda[i];
			vec2 sz = sza[i];

			// vector to edge center
			vec3 l0 = L + IO_areaaxis[i].xyz;

			float dirL0 = dot(dir, l0);
			float dirld = dot(dir, ld);
			float l0ld = dot(l0, ld);
			float t = (l0ld*dirL0 - dot(l0, l0)*dirld) / (l0ld*dirld - dot(ld, ld)*dirL0);
			t = clamp(t, -sz.x, sz.x);
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot(normalize(P), dir);
			if (dp > bestDot) {
				bestP = P;
				bestDot = dp;
			}
		}

		return bestP;
	}
	else {
		return p0;
	}
}
#endif

vec3 tubeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float tubeLength = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_RadiusSizeXY.y : IO_RadiusSizeXY.z;
	vec3 tubeDir = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_right : IO_up;

	float dirL0 = dot(dir, L);
	float dirLd = dot(dir, tubeDir);
	float l0ld = dot(L, tubeDir);
	float t = (l0ld*dirL0 - dot(L, L)*dirLd) / (l0ld*dirLd - dot(tubeDir, tubeDir)*dirL0);
	t = clamp(t, -tubeLength, tubeLength);
	vec3 P = L + t*tubeDir;
	return P;
}

vec3 sphereRPM(in vec3 dir, in vec3 L, float lradius) {
	//closest point on sphere to ray
	vec3 closestPoint = dot(L, dir) * dir;
	vec3 centerToRay = closestPoint - L;
	float t = lradius / sqrt( dot(centerToRay, centerToRay) );
	// L = L + centerToRay * saturate(t);
	return L + centerToRay * saturate(t);
}

float getPhysicalAtt(in vec3 lraw) {
	// CONST float invSqScale = 1.0/5.0; // better color behavior over large distances
	CONST float invSqScale = 1.0; // no scaling
	// return 1.0 / ( 1 + dot(lraw, lraw)); // "inverse square" attenuation
	float dst = max(0.0f, length(lraw) - IO_RadiusSizeXY.x) * invSqScale;
	//float dstFromSurfaceSq = max(0.0f, dot(invSqScale*lraw, invSqScale*lraw));
	//float dstFromSurfaceSq = dot(invSqScale*lraw, invSqScale*lraw);
	//dstFromSurfaceSq = 
	return 1.0 / (1 + dst*dst); // "inverse square" attenuation
	//return 1.0 / (1 + dstFromSurfaceSq); // "inverse square" attenuation
}

// unused
// float getFillAtt(in vec3 lraw) {
// 	float cutoff = F_arealightcutoff; // 5%
// 	float atten_factor = sqrt(1.0/cutoff -1);
// 	vec3 t = (lraw/(IO_Range/2))*atten_factor;

// 	vec3 tt = lraw/(IO_Range/2);
// 	// return 1-dot(tt, tt);

// 	float scale_dst2 = dot(t, t);
// 	return saturate(1.0/(1+scale_dst2)-cutoff) * 1.0/(1.0-cutoff);
// }

void main()
{
	#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES
		float level = dot(LUM_ITU601, IO_lightcolor.rgb);
		vec3 lightcolor = vec3(level, level * 0.5, 0.0);
	#else	
		vec3 lightcolor = IO_lightcolor.rgb;
	#endif
	
	OUT_Color = vec4(0);
	#if 1
		vec3 view_pos; // needed
		RetrieveZBufferViewPos(view_pos);
	
		// light stuff
		CONST vec3 tolight = IO_view_center - view_pos;
		vec3 L = tolight; // L vector, gets modified
		float distance = sqrt(dot(tolight,tolight));
		float invDistance = 1.0 / distance;
		// vec3 direction = tolight * invDistance; // light direction
		// mainly readability
		float lradius = IO_RadiusSizeXY.x;
		vec2 lsize = IO_RadiusSizeXY.yz;
	
		if (length(tolight) >  IO_RadiusSizeXY.x+ length(IO_RadiusSizeXY.yz) + IO_Range*2.0f)
			discard;
		
		// attenuation
		// plane RPM (just clamped) for diffuse + attenuation
		float atten = 1.0f;
		vec3 ldiff = tolight;
		vec3 lraw = tolight; // from patch to closest point on ray/plane
		if( lsize.x + lsize.y > 0.0 )
		{
			vec3 toSource = ldiff;
			vec2 uv = vec2( dot(-toSource,IO_right), dot(-toSource,IO_up) );
			uv = clamp( uv, -lsize.xy, lsize.xy );
			toSource += uv.x*IO_right + uv.y*IO_up;
			lraw = toSource;
			// distance_atten = 1.0 / ( 1 + 0.01*dot(toSource, toSource));
		}
		ldiff = normalize(lraw);
		float dstFromSurface = max(0.0f, length(lraw) - lradius);
		float dstNorm = (IO_Range);// / 2.0;
		float linattenA = saturate(1.0 - dstFromSurface/ dstNorm);
	
		atten *= getPhysicalAtt(lraw) * linattenA;
		
		// spot attenuation, derived from single angle
		float sp0 = saturate(IO_spotatten)*0.99;
	
		float diratten = 1;
		if(sp0 > 0)
		{
			diratten = 0.5*dot(-ldiff, IO_Direction)+0.5; // 0-1
			diratten = (diratten-sp0)/(1-sp0); // remap
			diratten = saturate(diratten);
			diratten *= diratten;
		}
		atten *= diratten;
	
		
		#ifdef JM_USE_DISCARD_AREALIGHT_MORE
			if(atten < 0)
			{
				discard;
			}
		#endif
	
		float sizeMin = min(lsize.x, lsize.y);
		float sizeMax = max(lsize.x, lsize.y);
		float sizeSum = lsize.x + lsize.y;
		CONST float threshold = 0.001f;
	
		// accumulation
		float diffuse_occlusion = 1.0f;
		vec4 finalColor = vec4(0);
		
		vec3 Normal;
		RI_GBUFFER_NORMAL0(Normal);
		
		float Metalness;
		float Smoothness;
		RI_GBUFFER_METAL_SMOOTH(Metalness, Smoothness);
		
		float diffndotl = saturate(dot(Normal, ldiff));
			
		float SubsurfaceMask = 0;
		#ifdef JM_USE_DISCARD_AREALIGHT_MORE
			#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING	
				SubsurfaceMask = max(0.0, ceil(0.5 - Metalness));
				if (diffndotl + SubsurfaceMask <= 0.0)
			#else
				if (diffndotl <= 0.0)
			#endif
			{
			//	LPASS_SHAPE_EARLY_DISCARD()
				discard;
			}
		#endif
		
		#ifndef JM_USE_DISCARD_AREALIGHT_MORE
			if(atten > 0)
			{
		#endif
	
		vec3 Albedo;
		RI_GBUFFER_BASECOLOR(Albedo);
		
		float Roughness = smooth2rough(Smoothness);//was Smoothness*Smoothness - changed for consistency
		#ifndef JM_ROUGHNESS_REMAP
			Roughness = max(Roughness, 0.05f); // avoid nans after squared divisions
		#endif	
	
		vec3 cspec = vec3(0);
		vec3 cdiff = vec3(0);
		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
			vec3 csub = vec3(0);
			vec3 SubsurfaceNormal = Normal;
			float Subsurface = 0;
			float RoughnessEpidermal = 0.5;
			get_colors(	Albedo, 
						Metalness, 
						Roughness, 
						cspec, 
						cdiff, 
						csub, 
						SubsurfaceNormal,
						Subsurface, 
						RoughnessEpidermal, 
						SubsurfaceMask);
		#else
			
			get_colors(Albedo, Metalness, cspec, cdiff);
		#endif
	
		// float a = max(Roughness*Roughness, 0.0001f);
		float a = Roughness*Roughness;
		float a2 = a*a;
		float norm = 1.0 / (PI * a2); // factor used for spec mod
	
		// AO used to attenuate diffuse component
		
		if (B_ssao_enabled) {
			float ambient_occlusion = GetSSAO();
			// weight strength over distance
			float ssao_weight = 0.5*(linattenA*linattenA);
			diffuse_occlusion = saturate(ambient_occlusion);
		}
		else /**/{//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
			//looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
			diffuse_occlusion = 1.0f;
		}
	
		vec3 v = normalize(-view_pos);
		
		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
			float n_dot_l_sss = sss_wrap_dot(ldiff, SubsurfaceNormal, Subsurface); //since we can't shadow we approximate with this instead
			//finalColor.rgb += saturate(dot(Normal, ldiff)) * diffuse_occlusion * INVPI * lightcolor;
			vec3 h = normalize(ldiff + v);
			finalColor.rgb += (cdiff * lightcolor) * (chan_diff(a2, dot(v, Normal), diffndotl, saturate(dot(v, h)), saturate(dot(Normal, h)), 1.0, cspec) * diffuse_occlusion * saturate(dot(SubsurfaceNormal, ldiff))) * JM_GLOBAL_DIFFUSE_INTENSITY;
		#else	
			// diffuse contribution
			vec3 Idiff = lightcolor * diffndotl * diffuse_occlusion;
			finalColor.rgb += Idiff * cdiff/PI ;
		#endif
		
		vec3 dir = reflect(-v, Normal);
	#define USE_TUBELIGHTMATH
		#ifdef USE_TUBELIGHTMATH
			if (sizeMin > threshold) {
				L = planeRPM(dir, L);
				// L = planeRPMb(dir, L);
			}
			else if (sizeMax > threshold) {
				L = tubeRPM(dir, L);
			}
		#else
			if (sizeSum > threshold) {
				L = planeRPM(dir, L);
			}
		#endif
			if (lradius > 0.0) {
				L = sphereRPM(dir, L, lradius);
			}
	
			// energy convservation using spec D mod
			float sizeGuess = lsize.x + lsize.y + lradius;
			float solidAngleGuess = saturate(sizeGuess * invDistance);
			float specatten = 1.0 / (1.0 + norm * solidAngleGuess);
			vec3 Lnorm = normalize(L);
	
			// wrt to plane RPM
			float n_dot_l = saturate(dot(Lnorm, Normal));
	
			// horizon mod
			float horizon = 1.0 - n_dot_l;
			horizon *= horizon;
			horizon *= horizon;
			specatten = specatten - specatten * horizon;
			#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
				finalColor.rgb += EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec3(0.0, specatten * n_dot_l * IO_SpecIntensity, 0.0), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal, false) * lightcolor;
				finalColor.rgb += sss_direct_approx(abs(dot(ldiff, SubsurfaceNormal)) * diffuse_occlusion, csub, cdiff) * n_dot_l_sss * JM_GLOBAL_SUBSURFACE_INTENSITY;
			#else
				// specular contribution
				// vec3 Ispec = IO_SpecIntensity * IO_Intensity * IO_lightcolor.rgb * specatten * diffndotl;
				vec3 Ispec = IO_SpecIntensity * lightcolor * specatten * n_dot_l;
				finalColor.rgb += Ispec * EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec2(0,1));
			#endif
	//		finalColor.rgb = IO_SpecIntensity * lightcolor * n_dot_l * EvalBRDFSimpleSpec(cspec, Roughness, Lnorm, v, Normal);
		// finalColor.rgb = vec3(n_dot_l);
		#ifndef JM_USE_DISCARD_AREALIGHT_MORE	
			}
		#endif
		finalColor.rgb *= atten;
	
	/*	if (B_render_arealightshape) {
			// draw influence outline
			if(abs(linattenA - 0.01) < 0.01 || abs(sqrt(diratten) - 0.01) < 0.01)
				finalColor.rgb = IO_lightcolor.rgb;
			if(linattenA < 0.01 || sqrt(diratten) < 0.01) {
					finalColor.rgb = vec3(0,1,0);
				if(sizeMin > threshold) { // its a plane
					finalColor.rgb = vec3(1,0,0);
				} 
				else if (sizeMax > threshold) { // a tube
					finalColor.rgb = vec3(1,1,0);
				}
			}
		}*/
	
		finalColor.rgb = clamp(finalColor.rgb, 0, 10); // safety
		finalColor.rgb = clamp(finalColor.rgb, 0, 2); // reduce flares
		finalColor.rgb *= diffuse_occlusion;
		
		OUT_Color.rgb = finalColor.rgb;
		OUT_Color.a = 0;
		
		#ifdef LPASS_COUNT
			OUT_Color *= FLOAT_SMALL_NUMBER;
			OUT_Color.rgb += 1.0f / LPASS_COUNT;
		#endif
	#else
		OUT_Color.rgb = vec3(10.0, 5.0, 0.0);
		OUT_Color.a = 1.0;	
	#endif
}
#define P1_SHADERS
#include <common.fh>


//TODO
// wenn radius > 0.5*length, gibt es artefakte an den stirnflchen! 

// HACK TO BOOS LOCAL SPEC!
#define SPEC_BOOST 2.0
#define DIFF_BOOST 1.0
#define SPEC_POWER 1.0 // 15.0

in float IO_radius;
in float IO_SpecularIntensity;
in vec3 IO_l1;
in vec3 IO_l2;
in vec3 IO_center;
in vec4 IO_worldviewpos;
in vec3 IO_lightcolor;
in float IO_Intensity;

void main()
{
	#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES
		float level = dot(LUM_ITU601, IO_lightcolor.rgb);
		vec3 lightcolor = vec3(0.0, 0.0, level);
	#else	
		vec3 lightcolor = IO_lightcolor.rgb;
	#endif	
	OUT_Color = vec4(0);	
	#if 1	
		CONST half2 LightPower = half2(SPEC_POWER, 6.2); // We need power from light here
	
		vec3 view_pos;
		RetrieveZBufferViewPos(view_pos);
	
		// Calculate the frustum ray using the view-space position.
		CONST float3 PositionWV = (IO_worldviewpos.xyz / IO_worldviewpos.z) * view_pos.z; // scale back to z = 1.0 and scale to stored Z
		
		float Ldist = length(IO_l2 - IO_l1);
		Ldist *=Ldist;
		float t = dot(IO_l1 - PositionWV, IO_l2 - IO_l1) / Ldist;
		t = saturate(-t);
		float3 Lx = IO_l1 + (t * (IO_l2 - IO_l1));
		
		// Start normal light calculations
		CONST float3 L = Lx.xyz - PositionWV.xyz; // build L with light center and reconstructed Z pos
		
		CONST float LightDistance = length(L);
	
		if (LightDistance > length(IO_l2 - IO_l1) + IO_radius) {
			LPASS_SHAPE_EARLY_DISCARD()
			discard;
		}
	
		CONST half DistanceNorm2 = IO_radius*0.9/LightDistance;
		CONST half PSquareDistanceAtt = saturate( 1.0 - 1.0/ pow(DistanceNorm2,2.0));
	
		if (PSquareDistanceAtt <= 0) {
			LPASS_SHAPE_EARLY_DISCARD()
			discard;
		}
		
		vec3 Normal;
		RI_GBUFFER_NORMAL0(Normal);
		
		float Metalness;
		float Smoothness;
		RI_GBUFFER_METAL_SMOOTH(Metalness, Smoothness);
		
		vec3 l = normalize(L);
		float n_dot_l = saturate(dot(Normal, l));
		float SubsurfaceMask = 0;
		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING	
			SubsurfaceMask = max(0.0, ceil(0.5 - Metalness));
			if (n_dot_l + SubsurfaceMask <= 0.0){
		#else
			if (n_dot_l <= 0.0)	{
		#endif
			LPASS_SHAPE_EARLY_DISCARD()
			discard;
		}
	
		
		vec4 finalColor = vec4(0);
		vec3 l0 = IO_l1 - view_pos;
		vec3 l1 = IO_l2 - view_pos;
		vec3 n = (Normal);
		vec3 v = normalize(-view_pos.xyz);
		
		vec3 Albedo;
		RI_GBUFFER_BASECOLOR(Albedo);
		
		float Roughness = smooth2rough(Smoothness);
	
		vec3 cspec = vec3(0);
		vec3 cdiff = vec3(0);
		vec3 csub = vec3(0);
		vec3 SubsurfaceNormal = Normal;
		float Subsurface = 0;
		float RoughnessEpidermal = 0.5;
		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
			get_colors(	Albedo, 
						Metalness, 
						Roughness, 
						cspec, 
						cdiff, 
						csub, 
						SubsurfaceNormal,
						Subsurface, 
						RoughnessEpidermal, 
						SubsurfaceMask);
		#else
			get_colors(Albedo, Metalness, cspec, cdiff);
		#endif
		/*	
		#ifndef LOCALSPEC
			cspec = cspec * 0.0f;
		#endif
		*/
		

		float diffuse_occlusion = 1.0f;
		if (B_ssao_enabled) {
			float ambient_occlusion = GetSSAO();
			diffuse_occlusion = saturate(ambient_occlusion);
		}
		/*	
		#ifdef LOCALSPEC
			finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, normalize(L), v, n, vec2(1, IO_SpecularIntensity)) * clight * n_dot_l;
		#else 
			finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, normalize(L), v, n, vec2(1, 0)) * clight * n_dot_l;
		#endif
		*/
		#ifdef LOCALSPEC
//			finalColor.rgb += EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec3(0.0, specatten * n_dot_l * IO_SpecIntensity, 0.0), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal, false) * lightcolor;
			//Jon Note, this light type are the most common culprits for strange artefacts on characters' faces, so how about we just disable the specular part in those cases?
			finalColor.rgb += EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec3(n_dot_l, n_dot_l * IO_SpecularIntensity, sss_wrap_dot(l, SubsurfaceNormal, Subsurface) * SubsurfaceMask), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal,  true) * lightcolor;
			
		#else
			finalColor.rgb += EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec3(n_dot_l, 0.0, sss_wrap_dot(l, SubsurfaceNormal, Subsurface) * SubsurfaceMask), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal, false) * lightcolor;
		#endif

		float atten = PSquareDistanceAtt;
		finalColor.rgb *= atten;
		
		finalColor.rgb = DEFERRED_HACK_TO_sRGB(finalColor.rgb);
		
		OUT_Color.rgb = finalColor.rgb * diffuse_occlusion;
		OUT_Color.a = 0;
			
		#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES_REACH
			OUT_Color.rgb = lightcolor;
		#endif
			LPASS_SHAPE_FINAL_ATTEN(atten)
		#ifdef LPASS_COUNT
			OUT_Color *= FLOAT_SMALL_NUMBER;
		
			if (IO_Intensity == 0.0) {
				discard ;
			}
			OUT_Color.rgb += 1.0f / LPASS_COUNT;
		#endif
	#else
		OUT_Color.rgb = vec3(0.0, 0.0, 1);
		OUT_Color.a = 1.0;
	#endif
}
#define P1_SHADERS
#include <common.fh>

in float IO_radius;
in vec3 IO_center;
in vec4 IO_worldviewpos;

#ifdef LPASS_BLEND_DEBUG
in vec4 IO_lightcolor;
#endif

void main()
{
	
	OUT_Color = vec4(0);
	OUT_Color.a = 1;
	#if 1 // debug disable everything and output flat color - just to find one in the world!
		
		vec3 view_pos;
		RetrieveZBufferViewPos(view_pos);
	
		if (view_pos.z > BGDIST) {
		//	OUT_Color.r = 1;	return;
			discard;
		}
	
		vec4 finalColor = vec4(0);
	
		vec3 wn;
		vec3 Albedo;
		float Metalness;
		float Smoothness;
		RI_GBUFFER_RAW(wn, Albedo, Metalness, Smoothness);
		float Roughness = smooth2rough(Smoothness);
	
		vec3 cspec = vec3(0);
		vec3 cdiff = vec3(0);
		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
			vec3 csub = vec3(0);
			vec3 SubsurfaceNormal = wn;
			float Subsurface = 0;
			float SubsurfaceMask = 0;
			float RoughnessEpidermal = 0.5;
			get_colors(	Albedo, 
						Metalness, 
						Roughness, 
						cspec, 
						cdiff, 
						csub, 
						SubsurfaceNormal,
						Subsurface, 
						RoughnessEpidermal, 
						SubsurfaceMask);
		#else
			get_colors(Albedo, Metalness, cspec, cdiff);
		#endif
	
		float ambient_occlusion = GetSSAO();//TODO @Timon/Florian maybe it'd just be better to go back to the traditional subtract later in the frame...
	
		// PositionWS: vector from camera to pixel in world-space
	// 	vec3 PositionWS = view_pos * mat3(M_view);
	// 	PositionWS += V_cameraposition.xyz;
		vec3 PositionWS = view2world(view_pos);
		float3 PositionLS = EnvMapMulMatrix(M_envmapprobe_world, PositionWS);
	// 	DebugStore(PositionLS); 	return;
	
		float blend = EnvMapFading(PositionLS);
		// apply lod fade-out
		blend *= U_fade_lod;
		// wv: direction from from pixel to camera in world-space
		vec3 wv = normalize(-view_pos) * mat3(M_view);
		float v_dot_n = saturate(dot(wv, wn));
		// smaller cone at edges to highlight fresnel
		
		//Jon Note, this is not a good idea, the energy intensity that you think you're simulating should already be covered in the fresnel term.
		#ifdef JM_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE
			float ambRoughness = Roughness;
		#else
			// smaller cone at edges to highlight fresnel
			float ambRoughness = mix(Roughness*0.3, Roughness, pow(v_dot_n, 1.0/3.0));
			//ambRoughness = Roughness; // deactivated, effect too strong
		#endif	
	
		float ssr_mask = 1;
		if (U_pass) {
			//Jon comment, I've seen worse :P
			ssr_mask -= SSR_GetHit(RTResolveSoft(T_ssr).a); // this seems like the least stupid way to get proper diffuse envmap probes while keeping specular SSR?:/
		}
		if(ssr_mask <= 0)
		{
			discard;
		}
		{
			vec3 R = reflect(-wv, wn);
			R = EnvMapAdjust(PositionWS, R);
			#ifdef JM_USE_RETROREFLECTIVE_DIFFUSE_MODEL
				#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
					if(GetViewPos().x > 0.0)
					{
						finalColor += combined_ambient_probe_brdf(S_input_rt, cspec, cdiff, csub, wn, SubsurfaceNormal, R, wv, ambRoughness, RoughnessEpidermal, SubsurfaceMask, Subsurface, saturate(ssr_mask));
					}
					else
					{	
						float n_dot_v = saturate(dot(wn, wv));
						vec4 spec_amb = spec_brdf_ibl4(S_input_rt, cspec, ambRoughness, R, n_dot_v);
						spec_amb.rgb *= saturate(ssr_mask);//ssr takes priority over envmap probe specular, however the diffuse and alpha shouldn't be affected so that globallight can accurately mix everything together
						vec3 diff_amb = cdiff * get_irradiance(S_input_rt, wn);
				
						finalColor.rgb = (spec_amb.rgb + diff_amb) * ambient_occlusion;
						finalColor.a = spec_amb.a;
						finalColor.a = saturate(finalColor.a);	
					}
				#else
					finalColor += combined_ambient_probe_brdf(S_input_rt, cspec, cdiff, csub, wn, SubsurfaceNormal, R, wv, ambRoughness, RoughnessEpidermal, SubsurfaceMask, Subsurface, saturate(ssr_mask));
				#endif
			#else
				
				float n_dot_v = saturate(dot(wn, wv));
				vec4 spec_amb = spec_brdf_ibl4(S_input_rt, cspec, ambRoughness, R, n_dot_v);
				spec_amb.rgb *= saturate(ssr_mask);//ssr takes priority over envmap probe specular, however the diffuse and alpha shouldn't be affected so that globallight can accurately mix everything together
				vec3 diff_amb = cdiff * get_irradiance(S_input_rt, wn);
		
				finalColor.rgb = (spec_amb.rgb + diff_amb) * ambient_occlusion;
				finalColor.a = spec_amb.a;
				finalColor.a = saturate(finalColor.a);
				
			#endif
		}
		
		#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES_REACH
			OUT_Color.rgb = finalColor.rgb * vec3(4.0, 2.0, 0.0);
		#endif
		#ifdef LPASS_BLEND_DEBUG
			OUT_Color.rgb = IO_lightcolor.rgb;
			OUT_Color.a = 1;
			OUT_Color *= saturate(ssr_mask);	//arguable whether we want to know how ssr behaves?
		#else
			OUT_Color.rgb = finalColor.rgb;
			OUT_Color.a = finalColor.a;
		#endif
		
		OUT_Color *= blend;
	#else	
		OUT_Color.rgb = vec3(4.0, 2.0, 0.0);
	#endif	
}
#define P1_SHADERS
#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
#define SPEC_BOOST 2.0
#define DIFF_BOOST 1.0
#define SPEC_POWER 1.0 // 15.0

in float IO_Intensity;
in vec3 IO_worldview_center;
in float IO_radius;
in float IO_SpecularIntensity;

in vec4 IO_worldviewpos;
in vec3 IO_lightcolor;

void main()
{
	#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES
		float level = dot(LUM_ITU601, IO_lightcolor.rgb);
		vec3 lightcolor = vec3(0.0, level, 0.0);
	#else	
		vec3 lightcolor = IO_lightcolor.rgb;
	#endif

	OUT_Color = vec4(0);
	
	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos);
	
	float3 L = IO_worldview_center - view_pos; // build L with light center and reconstructed Z pos
//	OUT_Color = vec4(IO_worldview_center.xyz/5000, 1);
	
 	float LightDistance = length(L);
//	OUT_Color = half4(LightDistance/IO_radius, 0, 0, 1);

	if (LightDistance > IO_radius) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}

	vec3 l = normalize(L);
	
	vec3 Normal;
	RI_GBUFFER_NORMAL0(Normal);
	
	float Metalness;
	float Smoothness;
	RI_GBUFFER_METAL_SMOOTH(Metalness, Smoothness);
	
	float n_dot_l = saturate(dot(l, Normal));
	float SubsurfaceMask = 0;
	#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING	
		SubsurfaceMask = max(0.0, ceil(0.5 - Metalness));
		if (n_dot_l + SubsurfaceMask <= 0.0)
	#else
		if (n_dot_l <= 0.0)
	#endif
	{
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}

	vec3 Albedo;
	RI_GBUFFER_BASECOLOR(Albedo);
	
	float Roughness = smooth2rough(Smoothness);
	
	vec3 v = normalize(-view_pos);
	
	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	vec3 csub = vec3(0);
	vec3 SubsurfaceNormal = Normal;
	float Subsurface = 0;
	float RoughnessEpidermal = 0.5;
	
	#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
		get_colors(	Albedo, 
					Metalness, 
					Roughness, 
					cspec, 
					cdiff, 
					csub, 
					SubsurfaceNormal,
					Subsurface, 
					RoughnessEpidermal, 
					SubsurfaceMask);
	#else
		get_colors(Albedo, Metalness, cspec, cdiff);
	#endif

	#ifndef LOCALSPEC
		cspec *= 0.0f;
	#endif
	float n_dot_l_sss = sss_wrap_dot(l, SubsurfaceNormal, Subsurface);

	float radius = IO_radius*0.9;
	float a = pow(saturate(1.0f-pow(LightDistance/radius,4.0f)), 2.0f);
	float b = 1.0/pow(LightDistance, 2.0f) + 1.0f;
	float PSquareDistanceAtt = saturate(a/b);
	
	float4 finalColor;

//	finalColor.rgb = n_dot_l * lightcolor;

	float diffuse_occlusion = 1.0f;// AO used to attenuate diffuse component
	if (B_ssao_enabled) {
		float ambient_occlusion = GetSSAO();
		diffuse_occlusion = saturate(ambient_occlusion);
	}
	else {//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
		  //looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
		diffuse_occlusion = 1.0f;
	}	

	//TODO @Timon this is all so wrong, but historical reasons... 
#ifdef LOCALSPEC
	finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec3(n_dot_l, IO_SpecularIntensity * n_dot_l, n_dot_l_sss * SubsurfaceMask), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal, true) * lightcolor;
#else
	finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec3(n_dot_l, 0, n_dot_l_sss), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal, false) * lightcolor;
#endif

	float atten = PSquareDistanceAtt;
	finalColor.rgb *= atten;
	finalColor.a = 1;
	
	finalColor = DEFERRED_HACK_TO_sRGB(finalColor);
	


	OUT_Color.rgb = finalColor.rgb * diffuse_occlusion;
	OUT_Color.a = 0;

	LPASS_SHAPE_FINAL_ATTEN(atten)

#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES_REACH
	OUT_Color.rgb = lightcolor;
#endif
#ifdef LPASS_COUNT
	OUT_Color *= FLOAT_SMALL_NUMBER;

	if (IO_Intensity == 0.0) {
		discard ;
	}
	OUT_Color.rgb += 1.0f / LPASS_COUNT;
#endif
}
#define P1_SHADERS
#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
#define SPEC_BOOST 2.0
#define DIFF_BOOST 1.0
#define SPEC_POWER 1.0 // 15.0

//gl_Position				// Pos						: POSITION;
in vec3 IO_lightcolor;		// LightColor / TEXCOORD1
in vec3 IO_direction;		// Direction				: TEXCOORD2;
in vec3 IO_apex;			// Apex	: TEXCOORD3;
in vec3 IO_range_radius_index;	// Range_Radius				: TEXCOORD4;
in float IO_SpecularIntensity;
in float IO_Intensity;

/*
float getPhysicalAtt(in vec3 lraw) {
	// CONST float invSqScale = 1.0/5.0; // better color behavior over large distances
	CONST float invSqScale = 1.0; // no scaling
								  // return 1.0 / ( 1 + dot(lraw, lraw)); // "inverse square" attenuation
	float dst = max(0.0f, length(lraw) - IO_range_radius_index.x) * invSqScale;
	//float dstFromSurfaceSq = max(0.0f, dot(invSqScale*lraw, invSqScale*lraw));
	//float dstFromSurfaceSq = dot(invSqScale*lraw, invSqScale*lraw);
	//dstFromSurfaceSq = 
	return 1.0 / (1 + dst*dst); // "inverse square" attenuation
								//return 1.0 / (1 + dstFromSurfaceSq); // "inverse square" attenuation
}
*/
void main()
{
	#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES
		float level = dot(LUM_ITU601, IO_lightcolor.rgb);
		vec3 lightcolor = vec3(level, 0.0, level);
	#else	
		vec3 lightcolor = IO_lightcolor.rgb;
	#endif	
	
	OUT_Color = vec4(0);
	
	float index = IO_range_radius_index.z;
	
	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos);
	
	// Calculate the frustum ray using the view-space position.
	CONST float3 PositionWV = (IO_worldview_pos.xyz / IO_worldview_pos.z) * view_pos.z; // scale back to z = 1.0 and scale to stored Z

	CONST float3 d = PositionWV - IO_apex;
	CONST float LightDistance = length(d);

	if (LightDistance > IO_range_radius_index.x) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	
	CONST float LinearDistanceAtt = pow(smoothstep(0.9f* IO_range_radius_index.x, 0.0f, LightDistance), 2.0f);// square falloff

	CONST half DistanceNorm2 = IO_range_radius_index.x / LightDistance;
	//CONST half PSquareDistanceAtt = saturate( 1.0 - 1.0/ pow(DistanceNorm2,2.0));

	float a = pow(saturate(1.0f - pow(LightDistance / IO_range_radius_index.x, 4.0f)), 2.0f);
	float b = 1.0 / pow(LightDistance, 2.0f) + 1.0f; //1.0f / pow(LightDistance, 2.0f) + 1.0f;
	float PSquareDistanceAtt = a / b;

	PSquareDistanceAtt = max(0.0f, (1.0f - 1.0f / ((pow(IO_range_radius_index.x / LightDistance, 0.20f)))) *(pow(IO_range_radius_index.x / LightDistance, 1.40f)));

	CONST float RadialDistance = length(cross(PositionWV - IO_apex, PositionWV - (IO_apex + IO_direction*10000.0f))) / length((IO_apex + IO_direction*10000.0f) - IO_apex);
	CONST float3 proj = float3(dot(IO_apex - PositionWV, (IO_direction*10000.0f) / length(IO_direction*10000.0f)));
	CONST float maxradialDist = sqrt(pow(LightDistance, 2.0) - pow(length(proj), 2.0));
	CONST float lightToSurfaceAngle = degrees(acos(dot(normalize(d), IO_direction)));
	//float RadialDistanceAtt = pow(smoothstep(IO_range_radius_index.y*0.95f,IO_range_radius_index.y*0.75f,lightToSurfaceAngle),1.0f/2.0f); //version restricted to fallof only on the outer cone!
	float RadialDistanceAtt = pow(smoothstep(IO_range_radius_index.y*0.95f, 0.0f, lightToSurfaceAngle), 1.0f / 2.0f);

	if (index > 1.0) {
		RadialDistanceAtt *= tex2D(S_diffuse_map, float2(1.0f - RadialDistanceAtt, 0.03125f + (index - 1.0f)*0.0625f)).r;
	}
	if (RadialDistanceAtt <= 0) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	
	vec3 Normal;
	RI_GBUFFER_NORMAL0(Normal);
	float Metalness;
	float Smoothness;
	RI_GBUFFER_METAL_SMOOTH(Metalness, Smoothness);
	
	float3 L = d.xyz - Normal * LightDistance * 0.5f;
	
	vec3 l;// = normalize(IO_apex - view_pos);
	l = normalize(-L);
	float n_dot_l = saturate(dot(Normal, l));
	#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING	
		float SubsurfaceMask = max(0.0, ceil(0.5 - Metalness));
		if (n_dot_l + SubsurfaceMask <= 0.0)	{
	#else
		if (n_dot_l <= 0.0)	{
	#endif
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	vec3 v = normalize(-view_pos);
	
	vec3 Albedo;
	RI_GBUFFER_BASECOLOR(Albedo);
	
	float Roughness = smooth2rough(Smoothness);

	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	vec3 csub = vec3(0);
	vec3 SubsurfaceNormal = Normal;
	float Subsurface = 0;
	float RoughnessEpidermal = 0.5;
		get_colors(	Albedo, 
					Metalness, 
					Roughness, 
					cspec, 
					cdiff, 
					csub, 
					SubsurfaceNormal,
					Subsurface, 
					RoughnessEpidermal, 
					SubsurfaceMask);
	#else
		get_colors(Albedo, Metalness, cspec, cdiff);
	#endif

	float n_dot_l_sss = sss_wrap_dot(l, SubsurfaceNormal, Subsurface);

//	vec3 clight = lightcolor;
	float diffuse_occlusion = 1.0f;
	if (B_ssao_enabled) {
		float ambient_occlusion = GetSSAO();
		diffuse_occlusion = saturate(ambient_occlusion);
	}
	else {//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
		  //looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
		diffuse_occlusion = 1.0f;
	}
	float3 light;
//	#if 0
//		#ifdef LOCALSPEC
//			light = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec2(1, IO_SpecularIntensity)) * lightcolor * n_dot_l;
//		#else
//			light = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec2(1, 0)) * lightcolor * n_dot_l;
//		#endif
//	#else
//		#ifdef LOCALSPEC
			light = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec3(n_dot_l, 0.0, n_dot_l_sss * SubsurfaceMask), Subsurface, RoughnessEpidermal, csub, SubsurfaceNormal, diffuse_occlusion, false) * lightcolor;
//		#else
//			light = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec3(n_dot_l, 0, n_dot_l * SubsurfaceMask), Subsurface, RoughnessEpidermal, csub, false) * lightcolor;
//		#endif
//	#endif
	
	float4 finalColor;
	finalColor.rgb = light;

	vec3 Ispec = lightcolor * (IO_SpecularIntensity * n_dot_l);

	finalColor.rgb += EvalBRDFSimpleSpec(cspec, Roughness, l, v, Normal) * Ispec;

	float atten = RadialDistanceAtt*PSquareDistanceAtt;
	finalColor.rgb *= atten;
	finalColor.a = 1;



	finalColor = DEFERRED_HACK_TO_sRGB(finalColor);
	finalColor.rgb = clamp(finalColor.rgb, 0, 2) * diffuse_occlusion; // reduce flares

	OUT_Color.rgb = finalColor.rgb;
	OUT_Color.a = 0;
	
	LPASS_SHAPE_FINAL_ATTEN(atten)
#ifdef JM_DEBUG_DEBUG_LIGHT_TYPES_REACH
	OUT_Color.rgb = lightcolor;
#endif
#ifdef LPASS_COUNT
	OUT_Color *= FLOAT_SMALL_NUMBER;

	if (IO_Intensity == 0.0) {
		discard ;
	}
	OUT_Color.rgb += 1.0f / LPASS_COUNT;
#endif
}
#include <common.fh>


// Lighting
USE_TEXTURE_LIGHTING
//USE_SHADOW_MAP
DEF_LIGHT_AMBIENT(1)
DEF_LIGHT_DIR(1)
DEF_LIGHT_DIR(2)
DEF_LIGHT_DIR(3)

void main()
{
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	float SubsurfaceVal = 0.5;//
#endif	
	
	CONST mat3x3 inCOLORMATRIX_BASE = mat3x3(make_ColorMatrix(U_base_brightness_shift, U_base_contrast_shift, U_base_saturation_shift, U_base_hue_shift));
	CONST mat3x3 inCOLORMATRIX_PAINT = mat3x3(make_ColorMatrix(U_paint_brightness_shift, U_paint_contrast_shift, U_paint_saturation_shift, U_paint_hue_shift));
	
	CONST half3 VertexToEye = normalize(IO_VertexToEye.xyz);	// V

	half4 ColorBaseDiffuse = half4(TO_linearRGB(S_diffuse_color.rgb), 0.0);
	half4 ColorBaseDiffuseSub = half4(1.0,1.0,1.0,0.0);

	float SmoothnessVal = U_smoothness;
	float MetalnessVal = U_metallness;
	_IF(S_smooth_bool)
	{
		SmoothnessVal *= tex2D(S_smooth_map, IO_uv0).r;
	}
	
	_IF(S_metal_bool)
	{
		MetalnessVal *= tex2D(S_metal_map, IO_uv0).r;
	}
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING	
	MetalnessVal = max(0.0, MetalnessVal * 2.0 - 1.5);//clean that mess up int he textuyres later
	SubsurfaceVal *= (1.0 - min(1.0, MetalnessVal * 256));
#endif	

	
	INPUT_NTB_TWOSIDED()
	
	float3 Normal = vec3(0);
	STANDARD_NORMAL_MAP(Normal)
	

	_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
	{
		ColorBaseDiffuse			= tex2D(S_diffuse_map, IO_uv0).rgba;	//Base Diffuse + alpha
		ColorBaseDiffuse.rgb		= blendAlpha(ColorBaseDiffuse.rgb, mul(ColorBaseDiffuse.rgb, inCOLORMATRIX_BASE), ColorBaseDiffuse.a);
	}
#ifdef JM_ENABLE_SUBSURFACE_BIAS_BLUR_TRICK
	vec3 wv = GetFragViewDir();// * mat3(M_view);
	float SubsurfaceBlur = pow2(dot(wv, normalize(mix(IO_normal, Normal, SubsurfaceVal))) * 0.5 + 0.5) * 3.0;	
	_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
	{
		//poor mans view dependant subsurface scattering aproximation, brighter spots == less  absorption == more seethrough.
		//we could improve with faint parallax
		SubsurfaceBlur				*= 1.0 - exp(-dot(ColorBaseDiffuse.rgb, vec3(0.2126, 0.7152, 0.0722)) * SubsurfaceVal) * 2.0;
		
		vec4 ColorBaseSSS			= texture(S_diffuse_map, IO_uv0, SubsurfaceBlur).rgba;	//Base Diffuse + alpha
		ColorBaseDiffuse.rgb		= mix(ColorBaseDiffuse.rgb, blendAlpha(ColorBaseSSS.rgb, mul(ColorBaseSSS.rgb, inCOLORMATRIX_BASE), ColorBaseSSS.a), SubsurfaceVal);	
	}
#endif	
	
	CONST half3 diffnorm = ColorBaseDiffuse.rgb;

	//--------------------------------------------------------------------------------------
	// apply the paint layer
	//--------------------------------------------------------------------------------------
	//alpha blend paint layer with diffuse base color
	_IF(S_diffuse_paint_bool)
	{
		half4 ColorPaint		= S_diffuse_paintstr * tex2D(S_diffuse_paint_map, IO_uv0).rgba;
		ColorPaint.rgb 			= mul(ColorPaint.rgb, inCOLORMATRIX_PAINT);	//apply Paint matrix
		// PROBLEM: we have to apply it to both layers since we do seperate lighting, result is a bit oversaturated!
		ColorBaseDiffuse.rgb	= blendAlpha(ColorBaseDiffuse.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
		ColorBaseDiffuseSub.rgb	= blendAlpha(ColorBaseDiffuseSub.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
	}
	
	
	// Shadow value, Ohoh we just have shadow calced for the main light so we only need to darken the light we have for the first global ? (does this always match?)
	float Shadow = 1.0f;
	_IF(B_shadow)
	{
		Shadow = GetShadow();
		// for now shadows only apply to solid geometry
//		Shadow = saturate(Shadow + (1.0 - F_alphascale)); // TODO: Bug -> last 20% dont work correctly we have a offset 0.1->0.2 somewhere
	}
		
//--------------------------------------------------------------------------------------
//				normals
//--------------------------------------------------------------------------------------	
	//TODO @timon verify inversion
// 	Normal.xyz *= sign(-in_vFace); //why we have to inverse it for max?
	

	// DEFERRED_HACK
	// Normal.xyz = mat3(M_view) * Normal.xyz; // view space normal
	// float smoothness = SmoothnessVal;
	// smoothness = 0.55;
	// GENERAL_OUTPUT(Normal.xyz, ColorBaseDiffuse.rgb, vec3(0), MetalnessVal, smoothness);

	vec3 ColorGlow = vec3(0.0f);
	float GlowStr = 0.0f;
	float cc = 0.0f;
	//SmoothnessVal = 0.6f;
	//MetalnessVal = 0.0f;
	// DEFERRED_OUTPUT(Normal.xyz, vec3(0, 0, -1), cc, ColorBaseDiffuse.rgb, ColorGlow, GlowStr, MetalnessVal, SmoothnessVal);
//	GENERAL_OUTPUT(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SmoothnessVal, ColorGlow);
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	ColorBaseDiffuse.rgb = bit_pack_albedo_normal(ColorBaseDiffuse.rgb, normalize(IO_normal), SubsurfaceVal);
	GENERAL_OUTPUT_SUBSURFACE(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SubsurfaceVal, SmoothnessVal, ColorGlow);
#else	
	GENERAL_OUTPUT(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SmoothnessVal, ColorGlow);
#endif		   
	//OUT_Color = ColorBaseDiffuse.rgba;
	//OUT_Color = half4(RimLight,RimLight,RimLight, 1.0f);
}
#include <common.fh>


// Lighting
USE_TEXTURE_LIGHTING
//USE_SHADOW_MAP
DEF_LIGHT_AMBIENT(1)
DEF_LIGHT_DIR(1)
DEF_LIGHT_DIR(2)
DEF_LIGHT_DIR(3)

void main()
{
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	float SubsurfaceVal = 0.5;//
#endif	
	CONST mat3x3 inCOLORMATRIX_BASE = mat3x3(make_ColorMatrix(U_base_brightness_shift, U_base_contrast_shift, U_base_saturation_shift, U_base_hue_shift));
	CONST mat3x3 inCOLORMATRIX_PAINT = mat3x3(make_ColorMatrix(U_paint_brightness_shift, U_paint_contrast_shift, U_paint_saturation_shift, U_paint_hue_shift));
	
	CONST half3 VertexToEye = normalize(IO_VertexToEye.xyz);	// V

	half4 ColorBaseDiffuse = half4(TO_linearRGB(S_diffuse_color.rgb), 0.0);
	half4 ColorBaseDiffuseSub = half4(1.0,1.0,1.0,0.0);

	float SmoothnessVal = U_smoothness;
	float MetalnessVal = U_metallness;
	_IF(S_smooth_bool)
	{
		SmoothnessVal *= tex2D(S_smooth_map, IO_uv0).r;
	}
	
	_IF(S_metal_bool)
	{
		MetalnessVal *= tex2D(S_metal_map, IO_uv0).r;
	}
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING	
	MetalnessVal = max(0.0, MetalnessVal * 2.0 - 1.75);//clean that mess up int he textuyres later
	SubsurfaceVal *= (1.0 - min(1.0, MetalnessVal * 256));
#endif	
	float max = U_ethnicity_european + U_ethnicity_african + U_ethnicity_asian;
	float3 E = float3(U_ethnicity_european / max, U_ethnicity_african / max, U_ethnicity_asian / max);


	INPUT_NTB_TWOSIDED()
	
	float3 Normal = vec3(0);
	//STANDARD_NORMAL_MAP(Normal)


	Normal = IO_normal;			
#ifdef JM_ENABLE_FULL_ANGLE_CORRECTED_CHARACTER_NORMAL_COMPOSITING		
		//unreal derives these automatically in every single "Normal" sampler node, this should really not be a problem to do proper per texture
		vec3 texnorm 		= NormalReZ(vec3(TEXTURE_NORMAL_XY(normal,  IO_uv0) * E.x, 0.0));
		vec3 texnorm2 		= NormalReZ(vec3(TEXTURE_NORMAL_XY(normal2, IO_uv0) * E.y, 0.0));
		vec3 texnorm3 		= NormalReZ(vec3(TEXTURE_NORMAL_XY(normal3, IO_uv0) * E.z, 0.0));
		vec3 NormalAge_pp 	= NormalReZ(vec3(TEXTURE_NORMAL_XY(normal4, IO_uv0) * U_age, 0.0));
	
		// maximum detail preserving quality angle blend
		Normal = CalcWorldNormal(blend_reoriented_normals(blend_reoriented_normals(texnorm, texnorm2), blend_reoriented_normals(texnorm3, NormalAge_pp)));
#else	
		vec3 texnorm = TEXTURE_NORMAL(normal, IO_uv0);
		vec2 texnorm2 = TEXTURE_NORMAL_XY(normal2, IO_uv0);
		vec2 texnorm3 = TEXTURE_NORMAL_XY(normal3, IO_uv0);
	
		half3 NormalAge_pp = TEXTURE_NORMAL(normal4, IO_uv0).xyz;
	
		
		texnorm.xy = texnorm.xy * E.x + texnorm2 * E.y + texnorm3 * E.z + NormalAge_pp.xy * U_age;
		
		texnorm = normalize(texnorm);
		
		Normal = CalcWorldNormal(texnorm);			
#endif	

		_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
		{
			//ColorBaseDiffuse			= tex2D(S_diffuse_map, IO_uv0).rgba;	//Base Diffuse + alpha
			
			ColorBaseDiffuse = tex2D(S_diffuse_map, IO_uv0).rgba * E.x + tex2D(S_diffuse2_map, IO_uv0).rgba * E.y + tex2D(S_diffuse3_map, IO_uv0).rgba * E.z;
			ColorBaseDiffuse.rgb = ColorBaseDiffuse.rgb * (1.0 - U_age) + ColorBaseDiffuse.rgb*tex2D(S_diffuse4_map, IO_uv0).rgb * U_age;
			
			ColorBaseDiffuse.rgb		= blendAlpha(ColorBaseDiffuse.rgb, mul(ColorBaseDiffuse.rgb, inCOLORMATRIX_BASE), ColorBaseDiffuse.a);
		}
		
#ifdef JM_ENABLE_SUBSURFACE_BIAS_BLUR_TRICK
		vec3 wv = GetFragViewDir();// * mat3(M_view);
		float SubsurfaceBlur = pow2(dot(wv, normalize(mix(IO_normal, Normal, SubsurfaceVal))) * 0.5 + 0.5) * 3.0;	
		_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
		{
			//poor mans view dependant subsurface scattering aproximation, brighter spots == less  absorption == more seethrough.
			//we could improve with faint parallax
			SubsurfaceBlur				*= (1.0 - exp(-dot(ColorBaseDiffuse.rgb, vec3(0.2126, 0.7152, 0.0722)) * SubsurfaceVal)) * 3.0;
			ColorBaseDiffuse			= texture(S_diffuse_map, IO_uv0, SubsurfaceBlur).rgba*E.x + texture(S_diffuse2_map, IO_uv0, SubsurfaceBlur).rgba*E.y+ texture(S_diffuse3_map, IO_uv0, SubsurfaceBlur).rgba*E.z;
			ColorBaseDiffuse.rgb		= ColorBaseDiffuse.rgb*(1.0 - U_age) + ColorBaseDiffuse.rgb*texture(S_diffuse4_map, IO_uv0, SubsurfaceBlur).rgb*U_age;		
			ColorBaseDiffuse.rgb		= blendAlpha(ColorBaseDiffuse.rgb, mul(ColorBaseDiffuse.rgb, inCOLORMATRIX_BASE), ColorBaseDiffuse.a);
		}
			
#endif	
	CONST half3 diffnorm = ColorBaseDiffuse.rgb;

	//--------------------------------------------------------------------------------------
	// apply the paint layer
	//--------------------------------------------------------------------------------------
	//alpha blend paint layer with diffuse base color
	_IF(S_diffuse_paint_bool)
	{
		half4 ColorPaint		= S_diffuse_paintstr * tex2D(S_diffuse_paint_map, IO_uv0).rgba;
		ColorPaint.rgb 			= mul(ColorPaint.rgb, inCOLORMATRIX_PAINT);	//apply Paint matrix
		// PROBLEM: we have to apply it to both layers since we do seperate lighting, result is a bit oversaturated!
		ColorBaseDiffuse.rgb	= blendAlpha(ColorBaseDiffuse.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
		ColorBaseDiffuseSub.rgb	= blendAlpha(ColorBaseDiffuseSub.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
	}
	
	
	// Shadow value, Ohoh we just have shadow calced for the main light so we only need to darken the light we have for the first global ? (does this always match?)
	float Shadow = 1.0f;
	_IF(B_shadow)
	{
		Shadow = GetShadow();
		// for now shadows only apply to solid geometry
//		Shadow = saturate(Shadow + (1.0 - F_alphascale)); // TODO: Bug -> last 20% dont work correctly we have a offset 0.1->0.2 somewhere
	}
		
//--------------------------------------------------------------------------------------
//				normals
//--------------------------------------------------------------------------------------	
	//TODO @timon verify inversion
// 	Normal.xyz *= sign(-in_vFace); //why we have to inverse it for max?
	
	vec3 ColorGlow = vec3(0.0f);
/*	half RimLight = fresnel(VertexToEye, Normal, U_fresnel_power/2) * ((1.0 + 2.0f*SmoothnessVal) / 3.0);  // apply occl to mask out hair/ear/sheek fresnel
	//half3 FresnelColor_Lin = TO_linearRGB(U_fresnel_color.rgb) * U_fresnel_strength*0.20;
	half3 FresnelColor_Lin = U_fresnel_color.rgb * U_fresnel_strength*0.05;

	ColorGlow += fresnel(VertexToEye, Normal, U_face_rim_power*2)*ColorBaseDiffuse.rgb*U_face_rim_strength*4.0;
	ColorGlow += (RimLight * FresnelColor_Lin.rrr);
	ColorGlow *= (Shadow + 1.0f) / 2.0f;
	ColorGlow = vec3(0.0f);*/
	
	// DEFERRED_HACK
	// Normal.xyz = mat3(M_view) * Normal.xyz; // view space normal
	// float smoothness = SmoothnessVal;
	// smoothness = 0.55;
	// GENERAL_OUTPUT(Normal.xyz, ColorBaseDiffuse.rgb, vec3(0), MetalnessVal, smoothness);

	//vec3 ColorGlow = vec3(0.0f);
	float GlowStr = 0.0f;
	float cc = 0.0f;
	//SmoothnessVal = 0.6f;
	//MetalnessVal = 0.0f;
	// GENERAL_OUTPUT(Normal.xyz, vec3(0, 0, -1), cc, ColorBaseDiffuse.rgb, ColorGlow, GlowStr, MetalnessVal, SmoothnessVal);


#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	ColorBaseDiffuse.rgb = bit_pack_albedo_normal(ColorBaseDiffuse.rgb, normalize(IO_normal), SubsurfaceVal);
	GENERAL_OUTPUT_SUBSURFACE(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SubsurfaceVal, SmoothnessVal, ColorGlow);
#else	
	GENERAL_OUTPUT(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SmoothnessVal, ColorGlow);
#endif	 	   
	//OUT_Color = ColorBaseDiffuse.rgba;
	//OUT_Color = half4(RimLight,RimLight,RimLight, 1.0f);
}
#include <common.fh>


// Lighting
USE_TEXTURE_LIGHTING
//USE_SHADOW_MAP
DEF_LIGHT_AMBIENT(1)
DEF_LIGHT_DIR(1)
DEF_LIGHT_DIR(2)
DEF_LIGHT_DIR(3)

float PHI = 1.61803398874989484820459;  //  = Golden Ratio   

float gold_noise(in vec2 xy, in float seed) {
	return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);
}

void main()
{
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	float SubsurfaceVal = 0.95;	
#endif	
	float hue = U_base_hue_shift;
	float contrast = U_base_contrast_shift;
	float seed = float(U_seed);

	float offsethue = sin((1.0 / (U_shiftduration + 0.00001f)) * 3.14 * F_time) * U_shiftscale;
	hue = mod(hue + offsethue, 360.0);
	contrast = 1.0;

	if (U_randomhue > 0)
	{
		const vec2 subseed = vec2(1, 0);
		//float offsethue = sin(mod(F_time, (U_shiftduration * 3.14))))*U_shiftscale;
		offsethue = sin((1.0/(U_shiftduration+0.00001f))*3.14*F_time)* U_shiftscale;
		hue = mod(lerp(U_shiftscale+0.1, 359.9f-U_shiftscale, gold_noise(subseed, seed)) + offsethue,360.0);
		contrast = lerp(0.8f, 1.2f, gold_noise(subseed, seed));
	}
	CONST mat3x3 inCOLORMATRIX_BASE = mat3x3(make_ColorMatrix(U_base_brightness_shift, contrast, U_base_saturation_shift, hue));
	CONST mat3x3 inCOLORMATRIX_PAINT = mat3x3(make_ColorMatrix(U_paint_brightness_shift, U_paint_contrast_shift, U_paint_saturation_shift, U_paint_hue_shift));
	
	CONST half3 VertexToEye = normalize(IO_VertexToEye.xyz);	// V

	half4 ColorBaseDiffuse = half4(TO_linearRGB(S_diffuse_color.rgb), 0.0);
	half4 ColorBaseDiffuseSub = half4(1.0,1.0,1.0,0.0);

	float SmoothnessVal = U_smoothness;
	float MetalnessVal = U_metallness;
	_IF(S_smooth_bool)
	{
		SmoothnessVal *= tex2D(S_smooth_map, IO_uv0).r;
	}
	
	_IF(S_metal_bool)
	{
		MetalnessVal *= tex2D(S_metal_map, IO_uv0).r;
	}
	#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING	
		MetalnessVal = max(0.0, MetalnessVal * 2.0 - 1.75);//clean that mess up int he textuyres later
		SubsurfaceVal *= (1.0 - min(1.0, MetalnessVal * 256));
	#endif	


	_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
	{
		ColorBaseDiffuse			= tex2D(S_diffuse_map, IO_uv0).rgba;	//Base Diffuse + alpha
		ColorBaseDiffuse.rgb		= saturate(blendAlpha(ColorBaseDiffuse.rgb, mul(ColorBaseDiffuse.rgb, inCOLORMATRIX_BASE), ColorBaseDiffuse.a));
	}
	INPUT_NTB_TWOSIDED()
	
	float3 Normal = vec3(0);
	STANDARD_NORMAL_MAP(Normal)
	#ifdef JM_ENABLE_SUBSURFACE_BIAS_BLUR_TRICK
		vec3 wv = GetFragViewDir();// * mat3(M_view);
		float SubsurfaceBlur = pow2(dot(wv, normalize(mix(IO_normal, Normal, SubsurfaceVal))) * 0.5 + 0.5) * 3.0;	
		_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
		{
			//poor mans view dependant subsurface scattering aproximation, brighter spots == less  absorption == more seethrough.
			//we could improve with faint parallax
			SubsurfaceBlur				*= (1.0 - exp(-dot(ColorBaseDiffuse.rgb, vec3(0.2126, 0.7152, 0.0722)) * SubsurfaceVal)) * 3.0;
			ColorBaseDiffuse			= texture(S_diffuse_map, IO_uv0, SubsurfaceBlur).rgba;	//Base Diffuse + alpha
			ColorBaseDiffuse.rgb		= saturate(blendAlpha(ColorBaseDiffuse.rgb, mul(ColorBaseDiffuse.rgb, inCOLORMATRIX_BASE), ColorBaseDiffuse.a));
		}		
	#endif	
	CONST half3 diffnorm = ColorBaseDiffuse.rgb;

	half3 ColorGlow = S_color_glow_color.rgb * U_mat_dynamicglow;;
	_IF(S_color_glow_bool)
	{
		
		half4 val = S_color_glowstr * tex2D(S_color_glow_map, IO_uv0);
		ColorGlow = val.rgb;
		CONST mat3x3 inCOLORMATRIX_GLOW = mat3x3(make_ColorMatrix(1.0, 1.0, 1.0, U_glow_hue_shift));
		ColorGlow.rgb = saturate(mul(ColorGlow.rgb, inCOLORMATRIX_GLOW));	//apply Paint matrix

		ColorGlow *= 1 + val.a * (10 - 1);		//boost multiplier 1-10x (TODO @Timon @Markus decide range)
		ColorGlow *= lerp(0.8, 1.0, (1.0 + sin((1.0 / U_shiftduration) * 3.14 * F_time)) / 2.0);
		ColorGlow *= U_mat_dynamicglow;
	}
/*	
	#ifdef JM_BORON_SUBSURFACE_GLOW
		float GlowMask = max(0.0, 1.0 - dot(LUM_ITU601, ColorGlow));
		for(int i = 1; i < 4; i++)
		{
			half4 val = S_color_glowstr * texture(S_color_glow_map, IO_uv0, i);
			half3 ColorGlowLoop = val.rgb;
			CONST mat3x3 inCOLORMATRIX_GLOW = mat3x3(make_ColorMatrix(1.0, 1.0, 1.0, U_glow_hue_shift));
			ColorGlowLoop.rgb = saturate(mul(ColorGlowLoop.rgb, inCOLORMATRIX_GLOW));	//apply Paint matrix
	
			ColorGlowLoop *= 1 + val.a * (10 - 1);		//boost multiplier 1-10x (TODO @Timon @Markus decide range)
			ColorGlowLoop *= lerp(0.8, 1.0, (1.0 + sin((1.0 / U_shiftduration) * 3.14 * F_time)) / 2.0);
			ColorGlowLoop *= U_mat_dynamicglow * ColorBaseDiffuse.rgb;
			ColorGlow += ColorBaseDiffuse.rgb * ColorGlowLoop * GlowMask * 20.0;
		}
	#endif
*/
	//--------------------------------------------------------------------------------------
	// apply the paint layer
	//--------------------------------------------------------------------------------------
	//alpha blend paint layer with diffuse base color
	_IF(S_diffuse_paint_bool)
	{
		half4 ColorPaint		= S_diffuse_paintstr * tex2D(S_diffuse_paint_map, IO_uv0).rgba;
		ColorPaint.rgb 			= mul(ColorPaint.rgb, inCOLORMATRIX_PAINT);	//apply Paint matrix
		// PROBLEM: we have to apply it to both layers since we do seperate lighting, result is a bit oversaturated!
		ColorBaseDiffuse.rgb	= blendAlpha(ColorBaseDiffuse.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
		ColorBaseDiffuseSub.rgb	= blendAlpha(ColorBaseDiffuseSub.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
	}
	
	
	
	// Shadow value, Ohoh we just have shadow calced for the main light so we only need to darken the light we have for the first global ? (does this always match?)
	float Shadow = 1.0f;
	_IF(B_shadow)
	{
		Shadow = GetShadow();
		// for now shadows only apply to solid geometry
//		Shadow = saturate(Shadow + (1.0 - F_alphascale)); // TODO: Bug -> last 20% dont work correctly we have a offset 0.1->0.2 somewhere
	}
		
//--------------------------------------------------------------------------------------
//				normals
//--------------------------------------------------------------------------------------	
	//TODO @timon verify inversion
// 	Normal.xyz *= sign(-in_vFace); //why we have to inverse it for max?
	

	// DEFERRED_HACK
	// Normal.xyz = mat3(M_view) * Normal.xyz; // view space normal
	// float smoothness = SmoothnessVal;
	// smoothness = 0.55;
	// GENERAL_OUTPUT(Normal.xyz, ColorBaseDiffuse.rgb, vec3(0), MetalnessVal, smoothness);

	//vec3 ColorGlow = vec3(0.0f);
	float GlowStr = 0.0f;
	float cc = 0.0f;
	//SmoothnessVal = 0.6f;
	//MetalnessVal = 0.0f;
	// DEFERRED_OUTPUT(Normal.xyz, vec3(0, 0, -1), cc, ColorBaseDiffuse.rgb, ColorGlow, GlowStr, MetalnessVal, SmoothnessVal);
//	if(SubsurfaceVal > 0)
//		ColorBaseDiffuse.rgb = vec3(0.0, 0.5, 0.0);
#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
	ColorBaseDiffuse.rgb = bit_pack_albedo_normal(ColorBaseDiffuse.rgb, normalize(IO_normal), SubsurfaceVal);
	GENERAL_OUTPUT_SUBSURFACE(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SubsurfaceVal, SmoothnessVal, ColorGlow);
#else	
	GENERAL_OUTPUT(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SmoothnessVal, ColorGlow );
#endif		   
	//OUT_Color = ColorBaseDiffuse.rgba;
	//OUT_Color = half4(RimLight,RimLight,RimLight, 1.0f);
}
#include <common.fh>


#define kernelSize 32
#define noiseSize 4

CONST float3 noise[] = float3[](
	float3(-0.0347764, -0.999395, 0),
	float3(0.827435, 0.561562, 0),
	float3(0.808026, -0.589147, 0),
	float3(-0.372927, -0.92786, 0),
	float3(0.394819, 0.918759, 0),
	float3(0.997709, 0.0676573, 0),
	float3(0.78889, 0.614535, 0),
	float3(0.584352, 0.8115, 0),
	float3(0.438643, 0.898661, 0),
	float3(-0.00520357, 0.999986, 0),
	float3(-0.587648, -0.809116, 0),
	float3(-0.950485, 0.31077, 0),
	float3(0.742757, -0.669561, 0),
	float3(0.785835, -0.618436, 0),
	float3(-0.873283, 0.487214, 0),
	float3(0.811581, -0.58424, 0)
	);
/*
//Kernel 64 Samples
CONST float3 Kernel[] = float3[](
	float3(0.00553397, -0.00138349, 0.00255414),
	float3(-0.00427619, -0.00147455, 0.00431305),
	float3(-0.00315949, 0.0025276, 0.00476355),
	float3(-0.00342681, -0.00221927, 0.00473226),
	float3(0.00398588, -0.00312407, 0.0036627),
	float3(0.00689553, -0.00719534, 0.00754511),
	float3(-0.00488669, 0.0108593, 0.00380076),
	float3(0.0155269, -0.00637002, 0.00836065),
	float3(0.0117596, 0.0220493, 0.000734976),
	float3(0.00117166, 0.00527247, 0.0244096),
	float3(0.00919276, -0.0247642, 0.0166971),
	float3(-0.00677409, 0.0297307, 0.0218276),
	float3(-0.024869, 0.0296515, 0.0204054),
	float3(-0.034275, -0.00524617, 0.0360237),
	float3(-0.0431596, 0.0141099, 0.0331997),
	float3(0.0336005, -0.0495165, 0.0180381),
	float3(-0.0417474, 0.0622272, 0.00315075),
	float3(0.0107147, -0.0455375, 0.0664311),
	float3(-0.057395, -0.0542064, 0.0505623),
	float3(-0.064513, -0.064513, 0.0409409),
	float3(0.08231, 0.0224482, 0.0733307),
	float3(0.0606342, -0.035207, 0.0958412),
	float3(0.10537, -0.0470651, 0.0625193),
	float3(-0.0916899, 0.082455, 0.0738796),
	float3(-0.00227587, 0.139966, 0.0694142),
	float3(0.160261, 0.0526405, 0.00467916),
	float3(0.0421965, 0.0226053, 0.174814),
	float3(-0.1128, 0.0596097, 0.145815),
	float3(-0.00803284, 0.172706, 0.11246),
	float3(0.141539, 0.111035, 0.124457),
	float3(-0.04648, 0.123947, 0.197188),
	float3(-0.0773175, 0.181579, 0.153464),
	float3(0.208167, 0.0169136, 0.169136),
	float3(-0.13774, -0.168013, 0.178608),
	float3(-0.267164, -0.133582, 0.0279127),
	float3(0.246377, 0.171038, 0.107917),
	float3(-0.10071, 0.289924, 0.140384),
	float3(-0.0466947, 0.286005, 0.207208),
	float3(-0.245406, -0.256782, 0.120265),
	float3(0.0923541, 0.247898, 0.291644),
	float3(-0.0641562, 0.340028, 0.224547),
	float3(-0.217869, 0.275834, 0.24985),
	float3(0.389356, -0.223735, 0.0290565),
	float3(0.326067, -0.316661, 0.137952),
	float3(0.485133, 0.0911903, 0.0109428),
	float3(-0.0580089, -0.400261, 0.32485),
	float3(0.29161, -0.161615, 0.421605),
	float3(0.264961, 0.463681, 0.17664),
	float3(0.494022, -0.316681, 0.0285012),
	float3(-0.337298, 0.0224865, 0.510765),
	float3(0.489663, -0.100246, 0.385561),
	float3(-0.134755, -0.373946, 0.522177),
	float3(0.232828, -0.633811, 0.129349),
	float3(0.275142, 0.449938, 0.479071),
	float3(-0.453339, -0.0701595, 0.577467),
	float3(0.532448, -0.0536022, 0.543169),
	float3(0.734755, 0.0103487, 0.300111),
	float3(-0.354065, -0.228042, 0.70213),
	float3(-0.532494, -0.514744, 0.41712),
	float3(0.212251, -0.616344, 0.58369),
	float3(0.790812, 0.325629, 0.299785),
	float3(0.44054, 0.565866, 0.603843),
	float3(-0.602414, -0.243079, 0.71867),
	float3(0.672058, -0.62473, 0.397555)
	);
*/
//Kernel 32 Samples
CONST float3 Kernel[] = float3[](
	float3(-0.000338665, -0.00222014, 0.00583256),
	float3(0.000747583, -0.00399795, 0.00474553),
	float3(-0.00112216, -0.0124458, 0.000306043),
	float3(0.0126174, -0.0120953, 0.00678729),
	float3(-0.0141535, -0.0198148, 0.00566138),
	float3(-0.00856573, 0.0175394, 0.0320195),
	float3(0.0395274, 0.00790549, 0.0295818),
	float3(0.046976, 0.02205, 0.0348325),
	float3(0.0590314, 0.0060545, 0.0554996),
	float3(0.0471025, 0.0841494, 0.0264621),
	float3(0.0478339, -0.0661887, 0.0862122),
	float3(0.0537673, -0.0701312, 0.113379),
	float3(-0.0990694, -0.088979, 0.103656),
	float3(-0.0629529, 0.140595, 0.117512),
	float3(-0.0284788, 0.199352, 0.0854365),
	float3(0.190873, 0.116021, 0.112278),
	float3(-0.215463, -0.0882209, 0.15778),
	float3(-0.0225137, 0.317443, 0.018011),
	float3(-0.0593876, 0.23755, 0.25876),
	float3(0.27374, 0.171668, 0.225024),
	float3(-0.251198, 0.348252, 0.0399633),
	float3(0.08359, -0.465715, 0.041795),
	float3(0.346686, 0.28446, 0.260755),
	float3(0.28503, -0.256239, 0.41171),
	float3(0.463272, 0.286629, 0.279963),
	float3(-0.373131, 0.539849, 0.0),
	float3(-0.614384, -0.272085, 0.236977),
	float3(-0.557678, 0.213777, 0.474026),
	float3(-0.16247, 0.597075, 0.536149),
	float3(-0.695881, 0.457973, 0.267647),
	float3(0.686225, -0.251616, 0.587104),
	float3(0.343937, -0.927587, 0.145913)
);

float rnd(vec2 x)
{
	int n = int(x.x * 40.0 + x.y * 6400.0);
	n = (n << 13) ^ n;
	return 1.0 - float((n * (n * n * 15731 + 789221) + \
		1376312589) & 0x7fffffff) / 1073741824.0;
}

float random(in float min, in float max)
{
	return lerp(min,max, rnd(gl_FragCoord.xy*F_time)); //
}
/*
void CreateKernel(out float3 kernel[kernelSize])
{
	for (int i = 0; i < kernelSize; ++i) {
		kernel[i] = vec3(
			random(-1.0f, 1.0f),
			random(-1.0f, 1.0f),
			random(0.0f, 1.0f));
			kernel[i] = normalize(kernel[i]);

			//accelerating interpolation function for scale 
			float scale = float(i) / float(kernelSize);
			scale = lerp(0.1f, 1.0f, scale * scale);
			kernel[i] *= scale;
	}
}
*/
/*
void CreateNoiseTex(out float3 noise[noiseSize*noiseSize])
{
	for (int i = 0; i < noiseSize*noiseSize; ++i) {
		noise[i] = vec3(
			random(-1.0f, 1.0f),
			random(-1.0f, 1.0f),
			0.0f
		);
		noise[i] = normalize(noise[i]);
	}
}*/

#define DEPTH_SCALE 0.001
float3 GetPosition(in float2 inVPos, out float3 normal)
{
	float2 screenuv = inVPos / V_viewportpixelsize.xy;

	RetrieveGBufferNormal(normal.xyz, screenuv);
	vec3 p;
	RetrieveZBufferViewPos(p, screenuv);
	p *= DEPTH_SCALE;
	return p;
}

void main()
{	
	
	float2 inVPos = gl_FragCoord.xy;

	/*float3 Kernel[kernelSize];
	CreateKernel(Kernel);
	float3 noise[noiseSize*noiseSize];
	CreateNoiseTex(noise);
	*/

	//get View Space Position & Normal
	float3 normal;
	CONST float3 origin = GetPosition(inVPos, normal);
	if (origin.z > U_ssao_clipfar*DEPTH_SCALE) {
		OUT_Color.r = 1;
		return;
	}
	//create Random Rotation around Normal
	//int nc = ((int)(gl_FragCoord.x / V_viewportpixelsize.x) % 4) * 4 + (gl_FragCoord.y / V_viewportpixelsize.y) % 4;
	//int nc = (int(gl_FragCoord.x / V_viewportpixelsize.x) % 4) * 4 + int(gl_FragCoord.y / V_viewportpixelsize.y) % 4;
	int nc = (int(gl_FragCoord.x) % 4)  + (int(gl_FragCoord.y) % 4) * 4;
	vec3 rvec = noise[nc]; // texture(uTexRandom, vTexcoord * uNoiseScale).xyz * 2.0 - 1.0;
	vec3 tangent = normalize(rvec - normal * dot(rvec, normal));
	vec3 bitangent = cross(normal, tangent);
	mat3 tbn = mat3(tangent, bitangent, normal);
	
	//params
	//float uRadius = (1.0f / V_viewportpixelsize.x);//0.025f;
	float uRadius = (U_ssao_sampleradius / V_viewportpixelsize.x)*0.0125f;//0.025f;
	uRadius *= max(origin.z/(5.0f*DEPTH_SCALE),1.0f);
	//do the actual occluseion checks
	float occlusion = 0.0;
	for (int i = 0; i < kernelSize; ++i) {
		// get sample position:
		vec3 newsample = tbn * Kernel[i];
		newsample = newsample * uRadius + origin;

		// project sample position:
		vec3 offset = clip2uv(Project(newsample));

		if (abs(length(offset.xy - inVPos / V_viewportpixelsize.xy)) <= length(1.0f / V_viewportpixelsize.xy)) { // TODO optimize check
			continue; // ignore if we're sampling within the same pixel
		}
		// get sample depth:
		vec3 p2;
		RetrieveZBufferViewPos(p2, offset.xy); /// V_viewportpixelsize.xy
		p2 *= DEPTH_SCALE;
		CONST float sampleDepth = p2.z;// texture(uTexLinearDepth, offset.xy).r;

		CONST float temp = abs(origin.z - sampleDepth);
		CONST float d = temp * U_ssao_scale;
		CONST float3 v = normalize(p2-origin);
		// range check & accumulate:
		CONST float rangeCheck = 1.0f;
		if (temp >= 1.5f * uRadius) {
			// if the occluding surface is "too far in front of or behind where we would expect it", ignore it since it is likely not actually occluding e.g. it is a character running 3m front of us with a station wall 200m away
			rangeCheck = 0.0f;
		}
		rangeCheck *= saturate(dot(normal, v) - U_ssao_bias); // scale depending on sample-normal incidence
		rangeCheck *= 1.0f / (1.0f + d);
		occlusion += (sampleDepth <= newsample.z ? 1.0f : 0.0f) * rangeCheck;
	}

	occlusion = 1.0 - (occlusion / kernelSize)*U_ssao_intensity;

	OUT_Color.r = pow(occlusion,2);// pow(occlusion, 4);//saturate(ao);
}


#include <common.fh>

const int baselvl = 1;

float ambRoughness;

uint ray_axis;
uint ray_other;
float ray_ofact;
float ray_ooff;
float ray_zfact;
float ray_zoff;

// float ray_dfact;	//ray distance for each step

int starti;

float i2lvl(int i)
{
	float sm = saturate(1.0f - ambRoughness);
// 	float dist = ray_dfact * abs(i - starti);
	float dist = abs(i - starti);
// 	float dist = abs(i - starti);
	dist = saturate(dist / (sm * 2000.0f));
// 	dist = pow2(dist);
// 	dist = sqrt(dist);
// 	dist = 0.0f;
	float f = 0;
	f += dist;
	f += 0.2f * ambRoughness;
	f = saturate(f);
	return f * U_size;
}

float getz(int i, int lvl)
{
	ivec2 pix;
	pix[ray_axis] = i;
	pix[ray_other] = int(i * ray_ofact + ray_ooff);
	
	float z = texelFetch(T_maindepth_mips, pix >> lvl, lvl - baselvl).x;
	return z;
}

uint getflags(int i, int lvl)
{
	ivec2 pix;
	pix[ray_axis] = i;
	pix[ray_other] = int(i * ray_ofact + ray_ooff);
	
	uint flags = texelFetch(T_flags, pix >> lvl, lvl).r;
	return flags;
}

vec2 getuv(int i)
{
	vec2 pix;
	pix[ray_axis] = i;
	pix[ray_other] = int(i * ray_ofact + ray_ooff);
	return pix / (V_viewportpixelsize.xy * 2);
}

vec4 TAA_color = vec4(0);
float TAA_mix = 1.0f;
void TAA_OUT(vec3 col, vec2 hit_dist)
{
// 	OUT_Color = col;	return;
// 	OUT_Color = vec4(col, SSR_Encode(hit_dist));	return;
	vec2 ohd = SSR_Decode(TAA_color.a);
	ohd.y = hit_dist.y;//TODO @Timon distance broken by interpolated fetch so ignore
	OUT_Color.rgb = mix(TAA_color.rgb, col.rgb, TAA_mix);
	OUT_Color.a = SSR_Encode(mix(ohd, hit_dist, TAA_mix));
}

void TAA_OUT()
{
	TAA_OUT(vec3(0), vec2(0));
}

void main()
{
	OUT_Color = vec4(0);
// 	OUT_Color.rgb = textureLod(T_maincolor_last, GetFragUV(), 0).rgb;	return;
	vec2 pix_uv = GetFragUV() ;
/*	
	pix_uv *= vec2(1.0, 2.0);
	if(uv.y > 1)
	{
		AA_OUT();
		return;		
	}
*/	
	vec2 pix_ss = uv2clip(pix_uv);
	
	vec2 vpsize = V_viewportpixelsize.xy * 2;	//we're rendering at half-res but we want the full-res to be tha basis
	
	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos, pix_uv);
	if (view_pos.z > BGDIST) {
// 		OUT_Color.r = 1;
		return;
	}
// 	OUT_Color.rgb = view_pos;	OUT_Color.a = 1;	return;
// 	TAA_OUT(vec4(view_pos, 1));	return;
	
	#if 1
	{
		vec4 reproj;
	//	reproj = vec4(uv2clip(pix_uv), gl_FragCoord.z, 1);
		if (IsStationary(GetFlags(pix_uv))) {
			reproj.xy = pix_uv;
			TAA_mix = 0.3;
		}
		else {
			reproj = vec4(Project(view_pos), 1);
			reproj = M_texturematrix0 * reproj;
			reproj /= reproj.w;
			reproj.xy = clip2uv(reproj.xy);
			vec2 dist = abs(reproj.xy - pix_uv);
			TAA_mix = 0.1 + 0.7 * ( smoothstep(0, 8.0 / V_viewportpixelsize.x, dist.x + dist.y));
		}
		if (U_pass != 0) {
			TAA_color = textureLod(S_input_rt, reproj.xy, 0);//TODO @Timon interpolated fetch effectively breaks distance info
			if (any(isnan(TAA_color)) || any(isinf(TAA_color))) {
				TAA_color = vec4(0);
			}
		}
		else {
			TAA_mix = 1;
			TAA_color = vec4(0);
		}
// 		TAA_mix = 0.1;
// 		OUT_Color = vec4(vec3(TAA_mix), 0);		return;
		//TODO @Timon don't TAA for stationary objects
	}
	#endif
	
	float constfade = 1;
	vec3 normal;
	float smoothness;
	RETRIEVE_GBUFFER_UV_NORMAL0_SMOOTH(pix_uv, normal, smoothness);
	
	if (any(isnan(normal))) {
		TAA_OUT();
		return;
	}
	else if (any(isinf(normal))) {
		TAA_OUT();
		return;
	}
	
// 	OUT_Color.rgb = normal;		return;
	
	vec3 ray = reflect(normalize(view_pos), normal);
// 	OUT_Color.rgb = ray;		return;
	if (ray.z < -0.4) {//rays facing camera are unlikely to hit something sensible
// 		OUT_Color.g = 1;
		//TODO @Timon many cases where this is too much:/
// 		return;
	}
	if (ray.z < -0.2) {
		constfade = smoothstep(-0.4, -0.2, ray.z);
	}
	float Roughness = smooth2rough(smoothness);
	float ambRoughness = 0;
	float v_dot_n = saturate(dot(view_pos, normal));
	// smaller cone at edges to highlight fresnel
	#ifdef JM_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE
		#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
		if(pix_uv.x > 0.5)
		{	
		#endif
			#ifdef JM_SSR_ANGLES_SHARPEN_POW5
				ambRoughness = Roughness;			
			#else
				ambRoughness = Roughness * (v_dot_n * 0.5 + 0.5);
			#endif
		#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN	
		}
		else
		{
			ambRoughness = mix(Roughness*0.75, Roughness, pow(v_dot_n, 1.0/3.0));
		}
		#endif
	#else
		ambRoughness = mix(Roughness*0.75, Roughness, pow(v_dot_n, 1.0/3.0));
	#endif
	
// 	if (Roughness >= 0.5) //don't bother for really rough surfaces since it'll have very little impact
// 		return;
	
	{
		vec2 pos;
		{
			switch(int(U_offset + pix_ss.x + pix_ss.y) % 8) {
			case 0:		pos[0] = 0.5000f;	pos[1] = 0.3333f;	break;	//halton
			case 1:		pos[0] = 0.2500f;	pos[1] = 0.6667f;	break;
			case 2:		pos[0] = 0.7500f;	pos[1] = 0.1111f;	break;
			case 3:		pos[0] = 0.1250f;	pos[1] = 0.4444f;	break;
			case 4:		pos[0] = 0.6250f;	pos[1] = 0.7778f;	break;
			case 5:		pos[0] = 0.3750f;	pos[1] = 0.2222f;	break;
			case 6:		pos[0] = 0.8750f;	pos[1] = 0.5555f;	break;
			case 7:		pos[0] = 0.0625f;	pos[1] = 0.8889f;	break;
			}
			pos *= vec2(2);
			pos -= vec2(1);
		}
		float scale = 0.01f + 0.2f * (ambRoughness);
		scale *= 0.05f;
		scale *= saturate(1.0f - TAA_mix);
		view_pos.xy += pos * scale;
	}
	vec3 view0_cs = Project(view_pos);
	vec3 view1_cs = Project(view_pos + ray);
	vec3 view0_uv = vec3(clip2uv(view0_cs.xy), view0_cs.z);
	vec3 view1_uv = vec3(clip2uv(view1_cs.xy), view1_cs.z);
// 	vec3 view0_pix = vec3(view0_uv.xy * vpsize.xy, view0_uv.z);
	vec3 view0_pix = vec3(gl_FragCoord.xy * 2, view0_uv.z);
	vec3 view1_pix = vec3(view1_uv.xy * vpsize.xy, view1_uv.z);
// 	vec3 ray_cs = view1_cs - view0_cs;
// 	vec3 ray_uv = view1_uv - view0_uv;
	vec3 ray_pix = view1_pix - view0_pix;
// 	ray_uv.xy = clip2uv(view1_cs.xy) - clip2uv(view0_cs.xy);
// 	vec3 ray_uv = clip2uv(ray_cs);
// 	ray_pix = normalize(ray_pix);
	
// 	OUT_Color.rg = abs(view0_pix.xy - gl_FragCoord.xy * 2);
// 	OUT_Color.rg *= 1000;
// 	OUT_Color.rgb = ray_cs;
// 	OUT_Color.rgb = ray_pix;
// 	return;
	{
		if (abs(ray_pix.y) >= abs(ray_pix.x)) {
			ray_axis = 1;
			ray_other = 0;
		}
		else {
			ray_axis = 0;
			ray_other = 1;
		}
		
// 		ray_dfact = length(ray) / abs(ray_pix[ray_axis]);
		ray_pix /= vec3(abs(ray_pix[ray_axis]));
// 		OUT_Color.rgb = ray_pix; 	return;
		
		ray_ofact = ray_pix[ray_other] / ray_pix[ray_axis];
		ray_ooff = view0_pix[ray_other] - ray_ofact * view0_pix[ray_axis];
		
		ray_zfact = ray_pix[2] / ray_pix[ray_axis];
		ray_zoff = view0_pix[2] - ray_zfact * view0_pix[ray_axis];
		
// 		ray_dfact = length(ray) / abs(ray_pix[ray_axis]);
		//TODO @Timon ray_dfact is clearly 1, for it to really make sense it'd have to be above the first divide, but arguably it looks better this way since you always get a certain amount of it as a percentage of the screensize (except it's steps, so resolution dependent TODO @Timon at least fix that)
	}
/*	if (abs(ray_pix[ray_axis]) < 0.999) {
		OUT_Color.rb = vec2(1);
		return;
	}/**/
	
	starti = int(view0_pix[ray_axis]);
	int i = starti;
	int dir = int(1.1 * ray_pix[ray_axis]);	//often the ray is just barely below 1
	if (IsComplex(getflags(i, 1))) {
		TAA_OUT();
		return;
	}
/*	{
		OUT_Color.rgba = vec4(0);
// 		OUT_Color[ray_axis] = float(abs(dir)) / 2;
		OUT_Color[ray_axis] = abs(ray_ofact);
		if (OUT_Color[ray_axis] > 1) {
			OUT_Color.b = 1;
		}
		return;
	}/**/
	
	int lvl = baselvl;
	
	uint a = 0;
	uint end = 400;
	
	i += dir << lvl;	//otherwise insta-hit when right cheek is against the wall
	uint abort = 0;
	for (; a < end; ++a) {
		int mask = (1 << lvl) - 1;
		int pi = i;
		i += 1 * (dir << lvl);
		int minlvl = baselvl;
// 		minlvl = 4;
// 		minlvl = max(minlvl, int(i2lvl(i)));
		
		float walk_z_near;
		float walk_z_far;
		vec3 walk_pix = vec3(0.0);
		walk_pix[ray_axis] = i;
		walk_pix[ray_other] = i * ray_ofact + ray_ooff;
		{
			int inext = i;
			int iprev = pi;
			if (dir > 0) {
				inext |= mask;
				iprev &= ~mask;
			}
			else {
				inext &= ~mask;
				iprev |= mask;
			}
			if (dir * ray_zfact <= 0) {
				walk_z_far = inext * ray_zfact + ray_zoff;
				walk_z_near = iprev * ray_zfact + ray_zoff;
			}
			else {
				walk_z_near = inext * ray_zfact + ray_zoff;
				walk_z_far = iprev * ray_zfact + ray_zoff;
			}
		}
		float hit_z = texelFetch(T_maindepth_mips, ivec2(walk_pix.xy) >> (lvl - 0), lvl - baselvl).x;
		if (hit_z - walk_z_far >= 0) {
// 			minlvl = clamp(minlvl, baselvl, 4);
			if (lvl <= minlvl)
			{
				if (hit_z < BGZ) {
					TAA_OUT();
					return;//don't reflect background the envmap will do it better
				}
				uint flags = 0;
				flags = getflags(i, lvl);
				if (!IsComplexDepth(flags)) {
					bool reproject = true;
					if ((flags & FLAG_STATIONARY) != 0) {
						reproject = false;
					}
					float threshold = 0;
					float slope_fact = 0;
					{
						float zn = getz(i + (dir << lvl), lvl);
						float zp = getz(i - 2 * (dir << lvl), lvl);
						
						float sn = zn - hit_z;
						float sp = hit_z - zp;
						
						if (abs(sp - sn) < 0.06 * hit_z)
						{
							threshold = abs(sp);
						}/**/
					}/**/
					if (hit_z - walk_z_near <= threshold)
					{
						{
							vec3 n;
							RetrieveGBufferNormal(n, getuv(i));
							if (dot(ray, n) >= 0) {
								TAA_OUT();
								return;
							}
						}
						vec4 reproj;
						if (reproject) {
							reproj = vec4(uv2clip(walk_pix.xy / (vpsize.xy)), hit_z, 1);
							reproj = M_texturematrix0 * reproj;
							reproj /= reproj.w;
							reproj.xy = clip2uv(reproj.xy);
						}
						else {
							reproj.xy = walk_pix.xy / (vpsize.xy);
						}
						float reslvl = 0;
// 						reslvl = minlvl;
// 						reslvl = i2lvl(i);
// 						reslvl = min(reslvl, 6);
						
						float fade = 1;
						{
							int outi = i + 40 * (dir << lvl);
							vec2 out_pix;
							out_pix[ray_axis] = outi;
							out_pix[ray_other] = outi * ray_ofact + ray_ooff;
							
							vec2 tmp = uv2clip(out_pix.xy / vpsize.xy);
							tmp = abs(tmp);
							tmp = 1 - saturate(tmp);
							
							fade = tmp.x * tmp.y;
							fade = smoothstep(0.0, 0.1, fade);
	// 						OUT_Color.rgb = vec3(fade);			return;
						}
	// 					OUT_Color.rg = reproj.xy;
	// 					OUT_Color.b = TO_linearRGB(slope_fact) * 1000000;
	// 					OUT_Color.b = TO_linearRGB(ray_dfact * abs(i - starti) / 1000.0f);
	// 					OUT_Color.b = TO_linearRGB(reslvl / U_size);
						vec3 outcol;
						outcol = textureLod(T_maincolor_last, reproj.xy, reslvl).rgb;
						outcol = min(outcol, vec3(2.0f));	//limit extremely bright reflections a bit
						
						if (any(isnan(outcol)) || any(isinf(outcol))/**/) {//TODO @Timon remove
							TAA_OUT();
							return;
						}
						TAA_OUT(outcol, vec2(fade, float(abs(i - starti)) / 1000));
						return;
					}
 #if defined(QUALITY_MEDIUM) || defined(QUALITY_HIGH)
					if (++abort > 32)	//this will not break if only a few pixels are blocking (it's mostly to handle the damn rail guards around docks:/)	//TODO @Timon maybe use higher mips as heuristic?
 #endif
					{
						TAA_OUT();
						return;
					}
				}
// 				OUT_Color.g = 1;
// 				return;
			}
			else
			{
				i -= dir << lvl;
				--lvl;
			}
		}
		else {
			if (i <= 0 || i >= vpsize[ray_axis] - 1) {
// 				OUT_Color.b = 1;
				TAA_OUT();
				return;
			}
			if (lvl < 6) {
				++lvl;
			}
		}
	}
	TAA_OUT();
}
#include <blur_common.h>

float TexelSize;

uint getflags(vec2 uv, int dir)
{
	uint flags = 0;
// 	flags |= textureLod(T_flags, uv, 2).r;
	flags |= textureLod(T_flags, uv, 1).r;
	vec2 off = vec2(0);
	off[BLUR_AXIS] = (dir * 1) / V_viewportpixelsize[BLUR_AXIS];
	flags |= textureLod(T_flags, uv + off, 1).r;
	/**/
	return flags;
}

void main()
{
	
/*	{
		uint flags = textureLod(T_flags, IO_uv0, 0).r;
		// uint flags = texelFetch(T_flags, ivec2(gl_FragCoord.xy), 2).r;
	
		OUT_Color = vec4(0);
		if (IsComplex(flags))
			OUT_Color.r = 1;
		if ((flags & FLAG_BACKGROUND) != 0)
			OUT_Color.g = 1;
		return;
	}/**/
	if ((textureLod(T_flags, IO_uv0, 1).r & FLAG_BACKGROUND) != 0) {
		OUT_Color = vec4(0);
		return;
	}
//	vec2 uv = IO_uv0 * vec2(1.0, 0.5);
	
	//TODO @Timon great "optimization" (a.k.a. removing stupid) potential here...
	TexelSize = /*g_BlurWidth*/1 / V_viewportpixelsize[BLUR_AXIS];
	int mid = _TAPSIZE2 / 2;
	
	float roughness;
	{
		float s;
		RETRIEVE_GBUFFER_UV_SMOOTH(IO_uv0, s);
		roughness = smooth2rough(s);
	}
	vec4 first = RTResolve(S_input_rt, IO_uv0);
	float hit, dist;
	SSR_GetHitDist(first.a, hit, dist);
	
	if (hit >= 0.7) //apply contact hardening only on fairly certain hits
	{
		dist += (0.3 * roughness); // make sure it never goes overly smooth for rough surfaces
		dist = saturate(dist);
		roughness *= (dist);
	}
	
	int width = 1 + int(smoothstep(0, 1, roughness) * 30);
	// width = 5;
	vec3 col = first.rgb;
	float wsum = 1.0f;
	
#define GETLINE(ss)			\
	{			\
		uint edge = 0;			\
		vec3 csum = vec3(0);			\
		for (int i = 1; i < width; ++i) {			\
			float fac = float(width - i) / float(2 * width);	\
			vec2 off = vec2(0);			\
			off[BLUR_AXIS] = TexelSize * (0.2 + 2.0 * float(i));	/*TODO @Timon improve interpolated sampling*/		\
			vec2 uv = IO_uv0 ss off;			\
			if (IsComplex(getflags(uv, ss 1)))			\
				break;			\
			if (edge < 1) {			\
				vec4 pix = textureLod(S_input_rt, uv, 0);			\
				csum += pix.rgb * fac;			\
				float h, d;		\
				SSR_GetHitDist(pix.a, h, d);			\
				hit += h * fac;		\
				dist += d * fac;	\
				wsum += fac;	\
			}			\
		}			\
		col += csum;			\
	}
	
	GETLINE(-)
	GETLINE(+)
	col /= wsum;
	hit /= wsum;
	dist /= wsum;

	OUT_Color.rgb = col.rgb;
	OUT_Color.a = SSR_Encode(hit, dist);
}

