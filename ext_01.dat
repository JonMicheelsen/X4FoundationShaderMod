/////////////////////////// JON MOD UTIL FUNCTIONS //////////////////////
//Included in the start of gbuffer_access.h, that is included most anywhere
//safeguard for double includes. #pragma once is not always safe to use, so let's do it manually
#ifndef _JM_ENCOATING_FUNCTIONS_
	void PackMetalSubsurface(inout float Metal, in float Subsurface)
	{
		#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
			if(GetFragUV().x > 0.5)
			{		
		#endif
				//Metal and Subsurface are natureally mutually exclusice, so we can pack both in metal
			//	Subsurface *= (1.0 - saturate(Metal * 256.0 - 4.0));//DDS compression could mess worst case 4 rbg scale steps, so makes sure to nix very low metal!
				const float dds_bias = -4.0/256.0;
				const float dds_boost = 1.0 / dds_bias;
				Metal = saturate(Metal * dds_boost + dds_bias);
				Metal = (Metal * 0.5) + (0.5 - Subsurface * 0.5);
		#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
			}
		#endif

	}
	void PackMetal(inout float Metal)
	{
		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
			//Metal and Subsurface are natureally mutually exclusice, so we can pack both in metal
			#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
				if(GetFragUV().x > 0.5)
			#endif
				Metal = (Metal * 0.5) + 0.5;		
		#endif
	}

	void UnpackMetalSubsurface(inout float Metal, inout float Subsurface)
	{
		#ifdef JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
			#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
				if(GetFragUV().x > 0.5)
				{		
			#endif
				//Metal and Subsurface are natureally mutually exclusice, so we can pack both in metal
				Subsurface = saturate(1.0 - Metal * 2.0);
				Metal = saturate(Metal * 2.0 - 1.0);
			#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
				}
			#endif
		#endif
	}
	void MetalStrict(inout float Metal)
	{
		#ifdef JM_ENFORCE_STRICT_METALLIC
			#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
				if(GetFragUV().x > 0.5)
				{		
					Metal = smoothstep(0.25, 0.75, Metal);
				}
				else
				{
					Metal = Metal;
				}
			#else
				Metal = smoothstep(0.25, 0.75, Metal);
			#endif
		#endif
	}
	void RoughnessRemapSmoothVersion(inout float Smooth)
	{
		#ifdef JM_ROUGHNESS_REMAP
			#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
				if(GetFragUV().x > 0.5)
				{		
					Smooth = 1.0 - pow2((1.0 - Smooth) * (1.0 - JM_ROUGHNESS_REMAP_PRE_SQUARE_RANGE) + JM_ROUGHNESS_REMAP_PRE_SQUARE_RANGE);
				}
				else
				{
					Smooth = Smooth;
				}
			#else
				Smooth = 1.0 - pow2((1.0 - Smooth) * (1.0 - JM_ROUGHNESS_REMAP_PRE_SQUARE_RANGE) + JM_ROUGHNESS_REMAP_PRE_SQUARE_RANGE);
			#endif
		#endif
	}
	void get_subdermal_roughness(	inout vec3 cspec, 
									inout float roughness, 
									out float roughness_epidermal, 
									in float subsurface_mask)
	{
		roughness_epidermal = clamp(roughness + JM_SUBSURFACE_EPIDERMAL_ROUGHNESS, 0.04, 1.0);
	//	cspec *= ((1.0 - subsurface_mask) + subsurface_mask);
		roughness = clamp(roughness + JM_SUBSURFACE_SUBDERMAL_ROUGHNESS * subsurface_mask, 0.04, 1.0);//we're baking the subdermal roughness into the regular one
	}

	//buffers is 16161616, game's "decals" never blends on subsurface surfaces, we should be safe :P
	vec3 bit_pack_albedo_normal(in vec3 albedo, in vec3 normal, in float subsurface)
	{
		const float scale = 128.0;
		const float scale_bit_pack = 1.0 / scale;
		
		//assumes the normal to be normalized!
		return subsurface > 0.0 ? (floor(albedo * scale) + (normal * 0.5 + 0.5) * (1.0 - scale_bit_pack)) * scale_bit_pack : albedo;
	}
	void bit_unpack_albedo_normal(inout vec3 albedo, inout vec3 subsurface_normal, in float subsurface_mask, in float subsurface)
	{
		const float scale = 128.0;
		const float scale_bit_pack = 1.0 / scale;
		const float scale_normal = 1.0 / (1.0 - scale_bit_pack);

		//assumes subsurface_normal is passed in defined as the regular normal, to avoid NaN's, if it was 0!
		if(subsurface_mask > 0)
		{
			subsurface_normal = normalize(mix(subsurface_normal, (albedo * scale - floor(albedo * scale)) * scale_normal * 2.0 - 1.0, subsurface));
			albedo = floor(albedo * scale) * scale_bit_pack;
		}
	}
	vec3 level_glows(vec3 glow)
	{
		#ifdef JM_GLOWS_LEVELLED
			glow = mix(glow, pow4(1.0 - exp(-glow)), JM_GLOWS_LEVELLED);
		#endif
		#ifdef JM_GLOWS
			glow *= JM_GLOWS;
		#endif
		return glow;//compiler needs this!?
	}
	void get_colors(in vec3 albedo, 
					in float metalness, 
					in float roughness,
					out vec3 cspec, 
					out vec3 cdiff, 
					out vec3 csub,
					inout vec3 nsub,
					inout float subsurface, 
					inout float roughness_epidermal, 
					inout float subsurface_mask)
	{
		UnpackMetalSubsurface(metalness, subsurface);
		subsurface_mask = min(1.0, ceil(max(0.0, subsurface - 0.001)));
		bit_unpack_albedo_normal(albedo, nsub, subsurface_mask, subsurface);
		#ifdef JM_DEBUG_GREY_WORLD
			albedo = vec3(0.5);
		#endif
		//subsurface *= 1.0;
		cdiff = albedo * (1.0 - metalness);
		csub = JM_SUBSURFACE_SCATTER_RADIUS_HUMAN * subsurface;//TODO we could bitpack different things?
	//	cdiff *= (1.0 - subsurface * subsurface_mask);
		cspec = mix(vec3(mix(0.04, JM_SUBSURFACE_EPIDERMAL_F0, subsurface_mask)), albedo, metalness);
		get_subdermal_roughness(cspec, 
								roughness, 
								roughness_epidermal, 
								subsurface_mask);
		

		//cdiff = cdiff * saturate(1.0f - dot(LUM_ITU601, cspec)); // cheap luminance energy conservation why though!?
	}
	#define _JM_ENCOATING_FUNCTIONS_
#endif
	////////////////// JON MOD HOLODECK //////////////////
//Included in the very end of common.h, that is included most anywhere
/*
	Comment out to enable or disable. Change variable after define if relevant to tweak. 
	Indented #defines means the top non indeted one need to be one for them to work
	Have fun!
*/
//safeguard for double includes. #pragma once is not always safe to use, so let's do it manually
#ifndef _JM_DEFINES_SET_
	//#define JM_SPECULAR_OVERSHOOT_FIX //default on, fixes geometric light white bright artefact
	#define JM_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE //default on
	#define JM_FIX_TUBELIGHT_ATTENUATION//no more hard curtoffs

	#define JM_ROUGHNESS_REMAP // default on. Disney trick, since artists has a tendency to overuse the lower end of the roughness and neglect nuances in the high end, this one does a gentle remap improving both!
	#define JM_ROUGHNESS_REMAP_PRE_SQUARE_RANGE 0.4142f//default 0.4142f, at this point 0.5 = 0.5, 0 = 0.17 1=1

	// Human skin lowest index of refraction(IOR)1.35 = 0.28 in unreal dieletric specular, or #47, rgb71, 28%brightness, as linear color
	// Human skin highest index of refraction(IOR)1.55 = 0.58 in unreal dieletric specular, or #94, rgb148, 58%brightness, as linear color
	// Human hair(and nails technically too) highest index of refraction(IOR)1.55 = 0.58 in unreal specular, or #94, rgb148,
	// Specular scale is 0.08, so (0.28 * 0.08) = 0.0224 (0.58 * 0.08) = 0.0464 , etc...
	//#define JM_USE_FAST_25TAP_CACSCADE_FILTER // Cant be activated currently, needs a sampler state change to work and I haven't yet figures out if that is even possible.
	#define JM_ENABLE_SUBSURFACE_GBUFFER_PACKING
		#define JM_ENABLE_SUBSURFACE_BIAS_BLUR_TRICK
		#define JM_SUBSURFACE_SUBDERMAL_ROUGHNESS 0.5
		#define JM_SUBSURFACE_EPIDERMAL_ROUGHNESS 0.0
		#define JM_SUBSURFACE_EPIDERMAL_TINT vec3(0.968750, 0.833764, 0.483325) //vec3(0.910580, 0.338275, 0.271800) vec3(1.000000,0.088964,0.072095)
		#define JM_SUBSURFACE_EPIDERMAL_F0 0.0224f	//se notes above
		#define JM_SUBSURFACE_SUBDERMAL_SPEC_CAP 0.95	
		#define JM_SUBSURFACE_WRAP_SCALE 0.0//default 0.25, 
		#define JM_SUBSURFACE_SQUARED_NDX //much more energetic but perhaps more natural looking 
		#define JM_SUBSURFACE_ID_COUNT 8
																							// 0 default no SSS
		#define JM_SUBSURFACE_SCATTER_RADIUS_HUMAN 		vec3(1.0	,0.627	,0.447) // 1 Human, just this for now... TODO implement the rest
		#define JM_SUBSURFACE_SCATTER_RADIUS_TELADI 		vec3(0.749	,0.569	,0.267) // 2 losely based on berber skink
		#define JM_SUBSURFACE_SCATTER_RADIUS_BORON 		vec3(0.263	,0.882	,0.859) // 3 blue greenish laguna like
		#define JM_SUBSURFACE_SCATTER_RADIUS_PARANID 		vec3(0.31	,0.247	,0.792) // 4 losely based on blue blooded horse shoe and purple blooded red rock crabs
		#define JM_SUBSURFACE_SCATTER_RADIUS_FOLIAGE 		vec3(0.6	,1.0	,0.060) // 5 spring leaves ish, good baseline
		#define JM_SUBSURFACE_SCATTER_RADIUS_ICE_ASTEROID 	vec3(0.357	,0.78	,1.000) // 6 water ice
		#define JM_SUBSURFACE_SCATTER_EYE					vec3(1.0	,0.627	,0.447) // 7 eyes probably pretty generic?
	//	#define JM_BORON_SUBSURFACE_GLOW //disabled in the code, needs more polish!
	#define JM_ENABLE_FULL_ANGLE_CORRECTED_CHARACTER_NORMAL_COMPOSITING

	#define JM_USE_RETROREFLECTIVE_DIFFUSE_MODEL//This upgrades EvalBRDF() to include this https://advances.realtimerendering.com/s2018/MaterialAdvancesInWWII-course_notes.pdf Which UE5 also uses.
		#define JM_USE_AMBIENT_DIFFUSE_TRICKS
		#define JM_USE_AMBIENT_SPECULAR_TRICKS
		#define JM_USE_AMBIENT_SPECULAR_TRICKS_PROBE_VERSION //don't know if this needs it since it already parallax corrects. Now it can be turned off seperately.

	#define JM_USE_LUMINANCE_FRESNEL
		#define JM_USE_STRICTER_N_DOT_V
	#define JM_SSR_WIDER_ROUGH_SCATTER
	//#define JM_SSR_ANGLES_SHARPEN_POW5
	#define JM_SSR_DISCARD_BAD_NORMAL_MAPPING
	#define JM_USE_DISCARD_AREALIGHT_MORE
	#define JM_SSSHADOWS //default on
		//near and far
		//#define JM_SSSHADOWS_SUPPORT_BOTH_PRIMARY_LIGHTS //default on
		#define JM_SSSHADOWS_MAX_STEPS 32 //default 64, it's pretty rare to ever go this high be aware this is a times 2
		#define JM_SSSHADOWS_DITHER 0.0 //default 4.0
		//far
		#define JM_SSSHADOWS_FADE_DISTANCE 5000.0 //not all PCF shadows have the same distance, so some lods will still shadow pop if we just use that, so with this we can enforce a max distance where everything will use Screenspace Shadows
		#define JM_SSSHADOWS_RAY_MAX_DISTANCE 100.0 //default 100.0 = 100.0m distance. I think 1 is about 10cm, so a hundred meters is 10000
		#define JM_SSSHADOWS_BIAS 1.0 //default 10.0 = 1.0m
		#define JM_SSSHADOWS_MAX_THICKNESS 1000.0 //default 1000.0 = 100.0m shadows thicker than this from the camera are ignored, so as to things near ain't casting shadows on things far
		//near
		#define JM_SSSHADOWS_FADE_DISTANCE_NEAR 20.0 
		#define JM_SSSHADOWS_RAY_MAX_DISTANCE_NEAR 0.20
		#define JM_SSSHADOWS_BIAS_NEAR 0.05
		#define JM_SSSHADOWS_MAX_THICKNESS_NEAR 0.20 
		#define JM_SSSHADOWS_ATTENUATION_NEAR 1.0 //optional soft fade near shadows
		//filtering
		#define JM_SSSHADOWS_FILTER // filters with screenspace derivatives, might give very different result at different resolution
	//	#define JM_SSSHADOWS_DEBUG_MODE
	//		#define JM_SSSHADOWS_LIGHT_TO_DEBUG 0 //options are 0 or 1 only!

	/// these should all be 1 always, but it allows you to preview each in their isolation by setting the others to 0
	#define JM_GLOBAL_DIFFUSE_INTENSITY 1.0
	#define JM_GLOBAL_SPECULAR_INTENSITY 1.0
	#define JM_GLOBAL_SUBSURFACE_INTENSITY 1.0
	//enabling this tonemaps all existing glows to 0-1 range, so the JM_GLOWS has a more uniform effect
	#define JM_GLOWS_LEVELLED 0.9//0-1 range blend of levelled part
	//increase to boost globally!
	#define JM_GLOWS	vec3(12.0, 12.0, 12.0)

		
	//#define JM_DEBUG_SUBSURFACE_NORMALS
	//#define JM_DEBUG_BASE_NORMALS
	//#define JM_DEBUG_GREY_WORLD
	//#define JM_DEBUG_WHITE_FURNACE_AMBIENT
	//#define JM_DEBUG_DEBUG_LIGHT_TYPES
	// orange = l_pass_arealight_gen.f
	// teal = l_pass_arealight.f
	// blue = l_pass_boxlight.f
	// green = l_pass_pointlight.f
	// magenta = l_pass_spotlight.f
	// red = l_star_light1.
	// aqua = l_star_light2.
	// yellow = l_pass_envmap_probe.f
	//#define JM_DEBUG_DEBUG_LIGHT_TYPES_REACH
	//#define JM_DEBUG_DISABLE_AMBIENT_LIGHT
	//#define JM_DEBUG_SUBSURFACE
	//debugs

	//#define JM_COMPARE_VANILLA_SPLIT_SCREEN

	#define INVPI (0.318309886f)
	#define _JM_DEFINES_SET_	
#endif	////////////////// JON MOD LIGHTING FUNCTIONS //////////////////
//Included right before global_lights() in common.fh, that is included in all lighting code
// as well as in the start of lighting_common.h
#ifndef _JM_LIGHTING_FUNCTIONS_
	//L we have to trasnform to view space
	float ScreenSpaceShadows(	in vec3 light_ray, 
								in float n_dot_l,
								in vec2 cascade_blend, 
								inout vec3 debug)	
	{
		const float step_size = 1.0 / JM_SSSHADOWS_MAX_STEPS;
		
		// Compute ray step
		vec3 ray_step = light_ray * step_size * max(JM_SSSHADOWS_RAY_MAX_DISTANCE_NEAR, JM_SSSHADOWS_RAY_MAX_DISTANCE * cascade_blend.y);
		
		// Ray march towards the light
		float shadow = 0.0;
	//	float subsurface_shadow = 0.0;
		vec2 ray_uv = vec2(0.0);
		vec2 fade = vec2(0.0);

		vec3 ray_pos = GetViewPos();
		#if defined(AAMODE_SSAA_2X)	
			vec2 aspect = vec2(0.5, -1.0 * V_viewportpixelsize.x / V_viewportpixelsize.y);
		#else
			vec2 aspect = vec2(0.5, -0.5 * V_viewportpixelsize.x / V_viewportpixelsize.y);
		#endif
		//different ways of getting what we need
		//debug = fract(vec3(1.0 / vec2(GetDepth(GetFragUV()), GetDepth()), GetViewPos().z * 10.0));//why 10?
		//works too
		//debug = fract(vec3(1.0 / vec2(GetDepth((ray_pos.xy / ray_pos.z) * aspect + 0.5), GetDepth()), GetViewPos().z * 10.0));//why 10?
		
		float depth = (ray_pos.z * 10.0);
		vec2 dither = hash22(gl_FragCoord.xy);
		vec2 texel_size = (1.0 / V_viewportpixelsize.xy);
		float thickness_threshold = max(JM_SSSHADOWS_MAX_THICKNESS_NEAR, JM_SSSHADOWS_MAX_THICKNESS * ceil(cascade_blend.y));
		float depth_bias = max(JM_SSSHADOWS_BIAS_NEAR * (1.0 + depth * 0.1), JM_SSSHADOWS_BIAS * ceil(cascade_blend.y));
	//	float attenuation = ceil(cascade_blend.x) * step_size * JM_SSSHADOWS_ATTENUATION_NEAR;
		ray_pos += ray_step * 0.5;
		for (uint i = 0; i < JM_SSSHADOWS_MAX_STEPS; i++)
		{
			// Step the ray
			ray_pos -= ray_step;
			ray_uv = ray_pos.xy / ray_pos.z;

			fade = abs(ray_uv);
			
			// Ensure the UV coordinates are inside the screen
			if(max(fade.x, fade.y) > 1.0)
				break;

			
			float depth_step = 1.0 / GetDepth(ray_uv * aspect + 0.5 + uv2clip(fract(dither + step_size)) * texel_size * JM_SSSHADOWS_DITHER);
			dither += step_size;
			float depth_delta = ray_pos.z * 10.0 - depth_step - depth_bias;
			
			if(depth_delta > 0.0 && depth_delta <  thickness_threshold)
			{
				// Fade out as we approach the edges of the screen
				fade				= 1.0 - saturate(fade * 30.0 - 29.0);
				shadow				= min(fade.x, fade.y);
	//			subsurface_shadow	= -shadow * i * JM_SSSHADOWS_ATTENUATION_NEAR;
				break;
			}

		}
		#ifdef JM_SSSHADOWS_DEBUG_MODE
			debug.g = shadow;
		#endif
		
		return 1.0 - shadow * (cascade_blend.x + cascade_blend.y);
	}

	// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
	// Similar to UE4/5 but with actual luminance, since that's a nice touch, rather than just cspec.g
	vec3 schlick_f(vec3 cspec, float v_dot_h)
	{
		float f = pow5(1.0 - v_dot_h);
		#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
			if(GetViewPos().x < 0.0)
				return f + (1-f) * cspec;
		#endif	
		return min(50.0 * dot(LUM_ITU601, cspec), 1.0) * f + (1.0 - f) * cspec;
	}
	// https://advances.realtimerendering.com/s2018/index.htm
	// It has been extended here to fade out retro reflectivity contribution from area light in order to avoid visual artefacts.
	float chan_diff(float a2, float n_dot_v, float n_dot_l, float v_dot_h, float n_dot_h, float retroreflective_energy, vec3 cspec)
	{
		float g = saturate((1.0 / 18.0) * log2(2.0 / a2 - 1.0));
		
		float f0 = (v_dot_h + pow5(1.0 - v_dot_h));
		float fdv = (1.0 - 0.75 * pow5(1.0 - n_dot_v));
		float fdl = (1.0 - 0.75 * pow5(1.0 - n_dot_l));

		// Rough (f0) to smooth (fdv * fdv) response interpolation
		float fd = mix(f0, fdv * fdl, saturate(2.2 * g - 0.5));
		
		// Retro reflectivity contribution.
		float fb = (((34.5 * g - 59.0) * g + 24.5) * v_dot_h * exp2(-max(73.2 * g - 21.2, 8.9) * sqrt(n_dot_h))) * retroreflective_energy;
		
		#ifdef JM_COMPARE_VANILLA_SPLIT_SCREEN
			if(GetViewPos().x < 0.0)
				return (1.0 / PI) * saturate(1.0f - dot(LUM_ITU601, cspec));
		#endif
			
		return INVPI * (fd + fb);
		
	}
	float sss_wrap_dot(vec3 l, vec3 n, float subsurface)
	{
		subsurface *= JM_SUBSURFACE_WRAP_SCALE;
		return max(0.0, (dot(l, n) + subsurface) * (1.0 / (1.0 + subsurface))) * INVPI;// match it to regular diffuse, and note that this is only called to non ambient light!
	//	return saturate((-dot(l, n) + subsurface JM_SUBSURFACE_WRAP_SCALE) / pow2(1.0 + JM_SUBSURFACE_WRAP_SCALE));
	}

	vec3 sss_direct_approx(float n_dot_l_abs, vec3 subsurface_scatter_radius, vec3 surface_color)
	{
		#ifdef JM_SUBSURFACE_SQUARED_NDX
			n_dot_l_abs = pow2(n_dot_l_abs);
		#endif
		return max(vec3(0.0), exp(-3.0 * n_dot_l_abs / (subsurface_scatter_radius + 0.001))) * surface_color * subsurface_scatter_radius;
	}

	// https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf
	vec3 muli_bounce_ambient_occlusion(vec3 cdiff, float ambient_occlusion)
	{

		vec3 a = 2.0404 * cdiff - 0.3324;
		vec3 b = -4.7951 * cdiff + 0.6417;
		vec3 c = 2.7552 * cdiff + 0.6903;
		return max(vec3(ambient_occlusion), ((ambient_occlusion * a + b) * ambient_occlusion + c) * ambient_occlusion);
	}
	// Point lobe in off-specular peak direction and specular occlusion from Unreal - but they got it from somwhere else, forgotten where, think I first encountered it in a Marmoset IBL article, that heavily quated the Frostbite PBR paper...?
	vec3 off_specular_peak(vec3 normal, vec3 reflection, float roughness_sr)
	{
		return mix(normal, reflection, (1.0 - roughness_sr) * (sqrt(1.0 - roughness_sr) + roughness_sr));	
	}
	float get_specular_occlusion(float n_dot_v, float roughness_sr, float ambient_occlusion)
	{
		return clamp(pow(n_dot_v + ambient_occlusion, roughness_sr) - 1.0 + ambient_occlusion, 0.0, 1.0);
	}

	int max_spec_level_less_strict(samplerCube filtered_env_map)
	{
		return textureQueryLevels(filtered_env_map) - 3;//Egosoft, You had -2 in yours, that's 4x4 pixels. I would not recommend at least 8x8
	}

	vec3 combined_ambient_brdf(	samplerCube filtered_env_map, 
								vec3 cspec, 
								vec3 cdiff, 
								vec3 csub, 
								vec3 normal, 
								vec3 normal_subdermal, 
								vec3 view, 
								float roughness, 
								float roughness_epidermal, 
								float subsurface_mask, 
								float subsurface, 
								float ambient_occlusion, 
								vec4 ssr, 
								vec3 flat_diffuse_addition)
	{
		#ifdef JM_DEBUG_DISABLE_AMBIENT_LIGHT
			return vec3(0.0);
		#endif
		#if 1
			int lowest_mip = max_spec_level_less_strict(filtered_env_map);
			float n_dot_v = dot(normal, view);
			vec3 reflection = -(view - 2.0 * normal * n_dot_v);//view and normal are both normalized, so we don't need to too.
			n_dot_v = saturate(n_dot_v);
			//chan_diffuse is now baked into to T_preintegrated_GGX b channel
			vec3 env_brdfs = textureLod(T_preintegrated_GGX, vec2(roughness, n_dot_v), 0).xyz;
			
			if(subsurface_mask > 0.0)
				env_brdfs = mix(env_brdfs, textureLod(T_preintegrated_GGX, vec2(roughness_epidermal, saturate(dot(view, normal_subdermal))), 0).xyz, subsurface);
			
	//		mix(D, D_GGX(pow4(roughness_epidermal), n_dot_h), subsurface);
			vec3 ambient_sss = vec3(0.0);
			if(subsurface_mask > 0.0) //may or may not be faster, cubemaps are emulated on modern hardware mostly.
				ambient_sss += (textureLod(filtered_env_map, -normal_subdermal, lowest_mip).rgb + flat_diffuse_addition) * sss_direct_approx(saturate(dot(view, normal_subdermal)), csub, cdiff);
			
			float roughness_sr = roughness * roughness;
			#ifdef JM_USE_AMBIENT_SPECULAR_TRICKS
				reflection = off_specular_peak(normal, reflection, roughness_sr);
			#endif
			vec3 specular_ibl = textureLod(filtered_env_map, reflection, lowest_mip * sqrt(roughness)).rgb;
			if(subsurface_mask > 0.0) //may or may not be faster, cubemaps are emulated on modern hardware mostly.
				specular_ibl = mix(specular_ibl, textureLod(filtered_env_map, reflection, lowest_mip * sqrt(roughness_epidermal)).rgb, subsurface);
				
			#ifdef JM_DEBUG_WHITE_FURNACE_AMBIENT
				specular_ibl = vec3(1.0);
			#endif
			
			//why was the SSR missing a PI in inensity to match!? Nah, seemed to intense
			vec3 ambient_specular = mix(specular_ibl.rgb, ssr.rgb, ssr.a);
		
			ambient_specular *= (cspec * env_brdfs.x + min(dot(LUM_ITU601, cspec) * 50.0, 1.0) * env_brdfs.y);
			#ifdef JM_USE_AMBIENT_SPECULAR_TRICKS
				ambient_specular *= get_specular_occlusion(n_dot_v, roughness_sr, ambient_occlusion);
			#else
				ambient_specular *= ambient_occlusion;
			#endif
			
			vec3 ambient_diffuse = textureLod(filtered_env_map, normal, lowest_mip).rgb + flat_diffuse_addition;
			#ifdef JM_DEBUG_WHITE_FURNACE_AMBIENT
				ambient_diffuse = vec3(1.0);
			#endif
			#ifdef JM_USE_AMBIENT_SPECULAR_TRICKS
				ambient_diffuse *= (cdiff * muli_bounce_ambient_occlusion(cdiff, ambient_occlusion)) * env_brdfs.b;	
			#else
				ambient_diffuse *= ambient_occlusion;
			#endif

			return 	vec3(	ambient_diffuse * 	JM_GLOBAL_DIFFUSE_INTENSITY + 
							ambient_specular * 	JM_GLOBAL_SPECULAR_INTENSITY + 
							ambient_sss * 		JM_GLOBAL_SUBSURFACE_INTENSITY);
		#else
			return vec3(0.0);
		#endif
	}

	//l_pass_envmap_probe.f version
	vec4 combined_ambient_probe_brdf(	samplerCube filtered_env_map, 
										vec3 cspec, 
										vec3 cdiff, 
										vec3 csub, 
										vec3 normal, 
										vec3 normal_subdermal, 
										vec3 reflection, 
										vec3 view, 
										float roughness, 
										float roughness_epidermal, 
										float subsurface_mask, 
										float subsurface, 
										float ambient_occlusion, 
										float ssr_mask)
	{
		#ifdef JM_DEBUG_DISABLE_AMBIENT_LIGHT
			return vec4(0.0);
		#endif		
		#if 1
			int lowest_mip = max_spec_level_less_strict(filtered_env_map);
			float n_dot_v = saturate(dot(normal, view));
			//chan_diffuse is now baked into to T_preintegrated_GGX b channel
			vec3 env_brdfs = textureLod(T_preintegrated_GGX, vec2(roughness, n_dot_v), 0).xyz;
			
			if(subsurface_mask > 0.0)
				env_brdfs = mix(env_brdfs, textureLod(T_preintegrated_GGX, vec2(roughness_epidermal, saturate(dot(view, normal_subdermal))), 0).xyz, subsurface);

			vec3 ambient_sss = vec3(0);
			if(subsurface_mask > 0.0) //may or may not be faster, cubemaps are emulated on modern hardware mostly.
				ambient_sss += (textureLod(filtered_env_map, -normal_subdermal, lowest_mip).rgb) * sss_direct_approx(saturate(dot(view, normal_subdermal)), csub, cdiff) * ambient_occlusion;
			
			float roughness_sr = roughness * roughness;
			#ifdef JM_USE_AMBIENT_SPECULAR_TRICKS
				reflection = off_specular_peak(normal, reflection, roughness_sr);
			#endif
			vec4 specular_ibl = textureLod(filtered_env_map, reflection, lowest_mip * sqrt(roughness));
			if(subsurface_mask > 0.0) //may or may not be faster, cubemaps are emulated on modern hardware mostly.
				specular_ibl = mix(specular_ibl, textureLod(filtered_env_map, reflection, lowest_mip * sqrt(roughness_epidermal)), subsurface);

			#ifdef JM_DEBUG_WHITE_FURNACE_AMBIENT
				specular_ibl.rgb = vec3(1.0);
			#endif
			
			//why was the SSR missing a PI in inensity to match!? Nah, seemed to intense
			vec3 ambient_specular = specular_ibl.rgb * ssr_mask;
		
			ambient_specular *= (cspec * env_brdfs.x + min(dot(LUM_ITU601, cspec) * 50.0, 1.0) * env_brdfs.y);

			#ifdef JM_USE_AMBIENT_SPECULAR_TRICKS
				ambient_specular *= get_specular_occlusion(n_dot_v, roughness_sr, ambient_occlusion);
			#else
				ambient_specular *= ambient_occlusion;
			#endif
			
			vec3 ambient_diffuse = textureLod(filtered_env_map, normal, lowest_mip).rgb;
			
			#ifdef JM_DEBUG_WHITE_FURNACE_AMBIENT
				ambient_diffuse = vec3(1.0);
			#endif
			
			#ifdef JM_USE_AMBIENT_SPECULAR_TRICKS
				ambient_diffuse *= (cdiff * muli_bounce_ambient_occlusion(cdiff, ambient_occlusion)) * env_brdfs.b;	
			#else
				ambient_diffuse *= ambient_occlusion;
			#endif
			
			return vec4(ambient_diffuse * 	JM_GLOBAL_DIFFUSE_INTENSITY + 
						ambient_specular * 	JM_GLOBAL_SPECULAR_INTENSITY + 
						ambient_sss * 		JM_GLOBAL_SUBSURFACE_INTENSITY, 
						specular_ibl.a);
		#else
			return vec4(0.0);
		#endif
	}
	#define _JM_LIGHTING_FUNCTIONS_
#endif
/////////////////////////// JON MOD UTIL FUNCTIONS //////////////////////
//Included in the very end of common.h, that is included most anywhere
//safeguard for double includes. #pragma once is not always safe to use, so let's do it manually
#ifndef _JM_UTILS_FUNCTIONS_
	/*
	Egosoft already got this one! and we inject after it's defined!
	float pow2(float x)
	{
		return x*x;
	}
	*/
	float pow4(float x)
	{
		return pow2(pow2(x));
	}
	vec2 pow4(vec2 x)
	{
		return pow2(pow2(x));
	}
	vec3 pow4(vec3 x)
	{
		return pow2(pow2(x));
	}
	vec4 pow4(vec4 x)
	{
		return pow2(pow2(x));
	}
	float pow5(float x)
	{
		return pow4(x)*x;
	}
	vec2 pow5(vec2 x)
	{
		return pow4(x)*x;
	}
	vec3 pow5(vec3 x)
	{
		return pow4(x)*x;
	}
	vec4 pow5(vec4 x)
	{
		return pow4(x)*x;
	}
	// from https://blog.selfshadow.com/publications/blending-in-detail/
	//nice angle corrected blend
	vec3 blend_reoriented_normals(vec3 n1, vec3 n2)
	{

		n1 = vec3(n1.xy, n1.z + 1.0);
		n2 = vec3(-n2.xy, n2.z);

		return normalize(n1 * dot(n1, n2) - n2 * n1.z);
	}

	// Hash without Sine
	// MIT License...
	/* Copyright (c)2014 David Hoskins.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.*/

	//----------------------------------------------------------------------------------------
	// https://www.shadertoy.com/view/4djSRW
	//  1 out, 1 in...
	float hash11(float p)
	{
		p = fract(p * .1031);
		p *= p + 33.33;
		p *= p + p;
		return fract(p);
	}

	//----------------------------------------------------------------------------------------
	//  1 out, 2 in...
	float hash12(vec2 p)
	{
		vec3 p3  = fract(vec3(p.xyx) * .1031);
		p3 += dot(p3, p3.yzx + 33.33);
		return fract((p3.x + p3.y) * p3.z);
	}

	//----------------------------------------------------------------------------------------
	//  1 out, 3 in...
	float hash13(vec3 p3)
	{
		p3  = fract(p3 * .1031);
		p3 += dot(p3, p3.zyx + 31.32);
		return fract((p3.x + p3.y) * p3.z);
	}
	//----------------------------------------------------------------------------------------
	// 1 out 4 in...
	float hash14(vec4 p4)
	{
		p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));
		p4 += dot(p4, p4.wzxy+33.33);
		return fract((p4.x + p4.y) * (p4.z + p4.w));
	}

	//----------------------------------------------------------------------------------------
	//  2 out, 1 in...
	vec2 hash21(float p)
	{
		vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
		p3 += dot(p3, p3.yzx + 33.33);
		return fract((p3.xx+p3.yz)*p3.zy);

	}

	//----------------------------------------------------------------------------------------
	///  2 out, 2 in...
	vec2 hash22(vec2 p)
	{
		vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
		p3 += dot(p3, p3.yzx+33.33);
		return fract((p3.xx+p3.yz)*p3.zy);

	}

	//----------------------------------------------------------------------------------------
	///  2 out, 3 in...
	vec2 hash23(vec3 p3)
	{
		p3 = fract(p3 * vec3(.1031, .1030, .0973));
		p3 += dot(p3, p3.yzx+33.33);
		return fract((p3.xx+p3.yz)*p3.zy);
	}

	//----------------------------------------------------------------------------------------
	//  3 out, 1 in...
	vec3 hash31(float p)
	{
	   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	   p3 += dot(p3, p3.yzx+33.33);
	   return fract((p3.xxy+p3.yzz)*p3.zyx); 
	}


	//----------------------------------------------------------------------------------------
	///  3 out, 2 in...
	vec3 hash32(vec2 p)
	{
		vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
		p3 += dot(p3, p3.yxz+33.33);
		return fract((p3.xxy+p3.yzz)*p3.zyx);
	}

	//----------------------------------------------------------------------------------------
	///  3 out, 3 in...
	vec3 hash33(vec3 p3)
	{
		p3 = fract(p3 * vec3(.1031, .1030, .0973));
		p3 += dot(p3, p3.yxz+33.33);
		return fract((p3.xxy + p3.yxx)*p3.zyx);

	}

	//----------------------------------------------------------------------------------------
	// 4 out, 1 in...
	vec4 hash41(float p)
	{
		vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));
		p4 += dot(p4, p4.wzxy+33.33);
		return fract((p4.xxyz+p4.yzzw)*p4.zywx);
		
	}

	//----------------------------------------------------------------------------------------
	// 4 out, 2 in...
	vec4 hash42(vec2 p)
	{
		vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));
		p4 += dot(p4, p4.wzxy+33.33);
		return fract((p4.xxyz+p4.yzzw)*p4.zywx);

	}

	//----------------------------------------------------------------------------------------
	// 4 out, 3 in...
	vec4 hash43(vec3 p)
	{
		vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));
		p4 += dot(p4, p4.wzxy+33.33);
		return fract((p4.xxyz+p4.yzzw)*p4.zywx);
	}

	//----------------------------------------------------------------------------------------
	// 4 out, 4 in...
	vec4 hash44(vec4 p4)
	{
		p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));
		p4 += dot(p4, p4.wzxy+33.33);
		return fract((p4.xxyz+p4.yzzw)*p4.zywx);
	}
	#define _JM_UTILS_FUNCTIONS_
#endif