#include <common.h>
#include <ssr_common.h>

#ifdef OUT_R8_UINT
layout(location = 0) out uint OUT_UINT;
#elif defined(OUT_ENVMAP)
layout(location = 0) out vec4 OUT_Color;
layout(location = 1) out vec4 OUT_Color1;
layout(location = 2) out vec4 OUT_Color2;
layout(location = 3) out vec4 OUT_Color3;
layout(location = 4) out vec4 OUT_Color4;
layout(location = 5) out vec4 OUT_Color5;
#elif defined(OUT_1)
layout(location = 0) out vec4 OUT_Color;
#else
layout(location = 0) out vec4 OUT_Color;
layout(location = 1) out vec4 OUT_Color1;
layout(location = 2) out vec4 OUT_Color2;
layout(location = 3) out vec4 OUT_Color3;
#endif


#define DIR in
#include <vertex.h>
#undef DIR

#ifdef GFX_RT_DEBUG
void DebugStore(vec4 col)
{
	imageStore(T_debug, ivec2(gl_FragCoord.xy), col);
}
void DebugStore(vec3 col)
{
	DebugStore(vec4(col, 1));
}

void DebugStore(float val, float alpha)
{
	DebugStore(vec4(-val, val, 0, alpha));
}
void DebugStore(float val)
{
	DebugStore(val, 1);
}
#endif

#define LOCALSPEC

float Luminance()
{
#ifdef PROJECT_XR
	return 0.6f;
#else
	return 1.0f;
#endif
//	return textureLod(T_luminance, vec2(0, 0), 0).x;
}

float LuminanceLast()
{
	return Luminance();
//	return textureLod(T_luminance_last, vec2(0, 0), 0).x;
}

#ifdef GFX_VULKAN
layout(constant_id = 0) const bool B_alpha_test = false;
layout(constant_id = 1) const float F_alpha_ref = 0.5f;
#else
uniform float F_alpha_ref = 0.0f;	//for alpha-testing
#endif

void StandardControlTexture()
{
#ifdef SHADERTAG_CT
	if (texture(S_input_rt, IO_uv0).r < 0.5f) {
		discard;
	}
#endif
}

void AlphaTest(float a)
{
	if (B_alpha_test)
	{
		if (a < F_alpha_ref) {
			discard;
		}
	}/**/
}

void AlwaysAlphaTestWithCoverage(inout float a, float ref)
{
	if (a < ref) {
		discard;
	}
	a = (a - ref) / max(abs(dFdx(a)) + abs(dFdy(a)), FLOAT_SMALL_NUMBER) + 0.5;
}
void AlphaTestWithCoverage(inout float a)
{
	if (B_alpha_test)
	{
		AlwaysAlphaTestWithCoverage(a, F_alpha_ref);
	}
}

#if 0//don't use this it crashes on intel gpus
void Alpha2DepthScale(float a)// when using this preferrably add "layout (depth_less) out float gl_FragDepth;" before include "common.fh"
{
	gl_FragDepth = gl_FragCoord.z * sqrt(saturate(a));
}
#endif

#ifdef D_OBJECT_RENDER_MODE
	#define OBJECTRENDERMODE_SOLID()		\
		{			\
			if (B_alpha_test) {				\
				if (OUT_Color.a >= F_alpha_ref) {	\
					OUT_Color.a = 1.0f;			\
				}			\
			}			\
			else {			\
				OUT_Color.a = 1.0f;		\
			}			\
		}
#else
	#define OBJECTRENDERMODE_SOLID() /* OBJECTRENDERMODE_SOLID() */
#endif


/*void OrthogonalNTB(out vec3 n, out vec3 t, out vec3 b)
{
	n = normalize(IO_normal);//TODO @Timon referencing IO_normal from a function breaks vr_oculus_avatar_pbs naturally
	t = IO_tangent;
	b = IO_binormal;
	t = normalize(t - n * dot(n, t));
	b = normalize(b - n * dot(n, b));
	b = normalize(b - t * dot(t, b));
}*/

#define INPUT_NTB_ONESIDED()			\
	vec3 IO_normal, IO_tangent, IO_binormal;			\
	IO_normal = normalize(_IO_normal);			\
	IO_tangent = normalize(_IO_tangent);			\
	IO_binormal = normalize(_IO_binormal);

#define INPUT_NTB_TWOSIDED()			\
	vec3 IO_normal, IO_tangent, IO_binormal;			\
	IO_normal = normalize(_IO_normal);			\
	IO_tangent = normalize(_IO_tangent);			\
	IO_binormal = normalize(_IO_binormal);		\
	if (gl_FrontFacing) {				\
		IO_normal = -IO_normal;			\
	}

#define CalcWorldNormal(texnormal)	normalize( ((texnormal).x * -IO_tangent) + ((texnormal).y * IO_binormal) + ((texnormal).z * IO_normal) )

#define CalcViewNormalOffset(texnormal)	((mat3(M_view) * ((texnormal).x * -IO_tangent + (texnormal).y * IO_binormal)).xy)

float3 UncompressDXT5_NM(float4 normPacked)
{
	float3 norm = float3(normPacked.a * 2.0 - 1.0, normPacked.g * 2.0 - 1.0, 0.0);
	norm.z = sqrt(1.0 - norm.x * norm.x - norm.y * norm.y);
	return norm;
}

//TODO @Timon further dedup the various variants
vec3 NormalReZ(vec3 texnormal)
{
	texnormal.z = sqrt(1 - saturate(dotself(texnormal.xy)));	//without saturate we'd get NaNs in some textures
	return texnormal;
}

vec2 textureNormalXY(sampler2D samp, vec2 uv)
{
	return SIGNED(texture(samp, uv).xy);
}
vec2 textureNormalXY(sampler2D samp, vec2 uv, float str)
{
	return SIGNED(texture(samp, uv).xy) * str;
}

vec3 textureNormalXYZ(sampler2D samp, vec2 uv)
{
	vec3 ret;
	ret = SIGNED(texture(samp, uv).xyz);
	return ret;
}
vec3 textureNormalXYZ(sampler2D samp, vec2 uv, float str)
{
	vec3 ret;
	ret = SIGNED(texture(samp, uv).xyz);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2D samp, vec2 uv)
{
	vec3 ret;
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2D samp, vec2 uv, float str)
{
	vec3 ret;
#if 0
	// experimental jitter for TAA
	float t = fract(F_time * 10);
	vec2 off = vec2(random(t * gl_FragCoord.xy), random(t * gl_FragCoord.yx));
	// DebugStore(vec3(off, 0));
	off = uv2clip(off);
	off *= 0.5 / textureSize(samp, 0).xy;
//	uv += off;
#endif
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2DArray samp, vec3 uv, float str)
{
	vec3 ret;
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}

vec3 textureNormal(sampler2D samp, vec2 uv, float str)
{
	return textureNormalXYreZ(samp, uv, str);
}
vec3 textureNormal(sampler2DArray samp, vec3 uv, float str)
{
	return textureNormalXYreZ(samp, uv, str);
}
vec3 textureNormal(sampler2D samp, vec2 uv)
{
	return textureNormalXYreZ(samp, uv);
}

#define TEXTURE_NORMAL(name0, uv0)		textureNormal(S_##name0##_map, (uv0) * S_##name0##_tiling, S_##name0##str)
#define TEXTURE_NORMAL_XY(name0, uv0)	textureNormalXY(S_##name0##_map, (uv0) * S_##name0##_tiling, S_##name0##str)


#define SAMPLE_NORMAL_MAP(out, name0, uv0)			\
	{			\
		(out) = IO_normal;			\
		_IF(S_##name0##_bool) {			\
			vec3 texnorm = TEXTURE_NORMAL(name0, (uv0));			\
			(out) = CalcWorldNormal(texnorm);			\
		}			\
	}

#define SAMPLE_NORMAL_MAP2(out, name0, uv0, name1, uv1)			\
	{			\
		(out) = IO_normal;			\
		_IF(S_##name0##_bool) {			\
			vec3 texnorm = TEXTURE_NORMAL(name0, (uv0));			\
			_IF(S_##name1##_bool) {			\
				texnorm.xy += TEXTURE_NORMAL_XY(name1, (uv1));			\
			}			\
			texnorm = normalize(texnorm);				\
			(out) = CalcWorldNormal(texnorm);			\
		}			\
	}

#define STANDARD_NORMAL_MAP(out)			SAMPLE_NORMAL_MAP(out, normal, IO_uv0)
#define STANDARD_NORMAL_DETAIL_MAP(out)		SAMPLE_NORMAL_MAP2(out, normal, IO_uv0, normal_detail, IO_uv0)
#define STANDARD_NORMAL_NOISE_MAP(out)		SAMPLE_NORMAL_MAP2(out, normal, IO_uv0, normal_noise, IO_uv0)

#define STANDARD_NORMAL_DETAIL_MAPUV(out,uv)		SAMPLE_NORMAL_MAP2(out, normal, uv, normal_detail, uv)

vec3 calcWorldNormal(vec3 TexNormal, vec3 Norm, vec3 Tang, vec3 BiNo)
{
	return normalize(TexNormal.x * normalize(-Tang) + TexNormal.y * normalize(BiNo) + TexNormal.z * normalize(Norm));
}

float3 calcWorldNormal2(CONST float3 TexNormal, CONST float3 Norm, CONST float3 Tang, CONST float3 BiNo)
{
	return calcWorldNormal(TexNormal, Norm, Tang, BiNo);
}

half CalcNewViewAngleFading(CONST float3 normalWV, CONST float3 posWV, CONST half AnglePower)
{
	return lerp(0.0, 1.0, saturate((abs(dot(normalWV, normalize(posWV))) - AnglePower)));
}


vec2 GetFragUV()
{
	return gl_FragCoord.xy / V_viewportpixelsize.xy;
}

vec3 GetFragUVZ()
{
	return vec3(GetFragUV(), gl_FragCoord.z);
}

vec3 GetFragClip()
{
	return uv2clipZ(GetFragUVZ());
}

vec3 GetFragView()
{
	return UnProject(GetFragClip());
}

vec3 GetFragViewDir()
{
	return normalize(GetFragView());
}

vec3 GetFragWorld()
{
	return view2world(GetFragView());
}

vec3 GetCheckers(int size)
{
	uvec2 pix = uvec2(gl_FragCoord.xy) / size;
	if (((pix.x + pix.y) & 1) != 0)
		return vec3(0.2);
	return vec3(0.4);
}
vec3 GetCheckers()
{
	return GetCheckers(16);
}

half4 RTResolve(sampler2D samp)
{
	return texelFetch(samp, ivec2(gl_FragCoord.xy), 0);	//TODO should be better, but need to test perf/compat
	
//	float2 uv = float2(inVPos.xy / ViewPort.xy); // use ps3 inputs and set LOD to 0
	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / V_viewportpixelsize.xy;
//	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / textureSize(samp, 0);
//	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / vec2(1024, 768);
	
	//CONST half localoccl = pow(Occl, 1.0/4.0); // scale power up, allow locallight to ignore occl to some degree, but if its very dark still scale down more.
//	return vec4(textureLod(samp, uv, 0).rgb, 0.8f);
//	return textureLod(samp, uv, 0).rgba * vec4(1, 1, 1, 0.5f); 
	return textureLod(samp, uv, 0);
}
half4 RTResolve(sampler2D samp, vec2 uv)
{
#ifndef VIEWPORT_HACK2
	#ifdef UPMODE_FSR
		//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
		#ifdef VIEWPORT_HALF_RES_FSR_HACK
		uv *= 2;
		#endif
		uv *= V_viewportpixelsize.xy / textureSize(samp, 0);
	#endif
#endif
	return textureLod(samp, uv, 0);
}
half4 RTResolveSoft(sampler2D samp)
{
	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / V_viewportpixelsize.xy;
	//float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / textureSize(samp, 0);
	return textureLod(samp, uv, 0);
}
half4 RTResolveSample(sampler2D samp, int idx)
{
	return RTResolve(samp);
}

half4 RTResolve(sampler2DMS samp)
{
#ifdef PER_SAMPLE
	vec4 col = texelFetch(samp, ivec2(gl_FragCoord.xy), gl_SampleID);
#elif defined(MAIN_MSAA)
	vec4 col = texelFetch(samp, ivec2(gl_FragCoord.xy), 0);
/*	for (int i = 1; i < MAIN_MSAA; ++i) {
		col += texelFetch(samp, ivec2(gl_FragCoord.xy), i);
	}
	/**/
/*	#if MAIN_MSAA > 1
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 1);
	#elif MAIN_MSAA > 2
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 2);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 3);
	#elif MAIN_MSAA > 4
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 4);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 5);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 6);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 7);
	#elif MAIN_MSAA > 8
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 8);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 9);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 10);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 11);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 12);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 13);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 14);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 15);
	#else
	#error weird MAIN_MSAA
	#endif
	/**/
// 	col /= vec4(MAIN_MSAA);
//	col = vec4(1, 0, 1, 1);
#else
	vec4 col = vec4(1, 0, 1, 1);
#endif
	return col;
}
half4 RTResolve(sampler2DMS samp, vec2 uv)
{
#ifndef VIEWPORT_HACK2
	#ifdef UPMODE_FSR
		//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
		uv *= V_viewportpixelsize.xy / textureSize(samp);
		#ifdef VIEWPORT_HALF_RES_FSR_HACK
		uv *= 2;
		#endif
	#endif
#endif
// 	uv *= V_viewportpixelsize.xy;
	uv *= textureSize(samp).xy;
#ifdef PER_SAMPLE
	return texelFetch(samp, ivec2(uv), gl_SampleID);
#else
	return texelFetch(samp, ivec2(uv), 0);
#endif
}
half4 RTResolveSample(sampler2DMS samp, int idx)
{
	return texelFetch(samp, ivec2(gl_FragCoord.xy), idx);
}

#define FLAG_COMPLEX_DEPTH (1 << 7)
#define FLAG_COMPLEX_NORMAL (1 << 6)
#define FLAG_STATIONARY (1 << 5)
#define FLAG_BACKGROUND (1 << 4)
#define FLAG_COMPLEX (FLAG_COMPLEX_DEPTH | FLAG_COMPLEX_NORMAL)

bool IsComplex(uint flags)
{
	return (flags & FLAG_COMPLEX) != 0;
}
bool IsComplexDepth(uint flags)
{
	return (flags & FLAG_COMPLEX_DEPTH) != 0;
}
bool IsStationary(uint flags)
{
	return (flags & FLAG_STATIONARY) != 0;
}


uint GetFlags()
{
	return texelFetch(T_flags, ivec2(gl_FragCoord.xy), 0).r;
}
uint GetFlagsLevel1()
{
	return texelFetch(T_flags, ivec2(gl_FragCoord.xy) >> 1, 1).r;
}

uint GetFlags(vec2 uv)
{
#ifdef UPMODE_FSR
	//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
	#ifdef VIEWPORT_HALF_RES_FSR_HACK
	#endif
	uv *= V_viewportpixelsize.xy / textureSize(T_flags, 0);
#endif
	return textureLod(T_flags, uv, 0).r;
}


//offset has to be a constant/literal, AMD is more anal about this! they check before optimizations
#define RTResolveOffset(samp,offset)	texelFetchOffset(samp, ivec2(gl_FragCoord.xy), 0, offset)


float GetDepth()
{
#ifdef OVERRIDE_DEPTH
	return RTResolve(OVERRIDE_DEPTH).r;
#else
	return RTResolve(T_zdepth).r;
#endif
}
float GetDepth(vec2 uv)
{
#ifdef OVERRIDE_DEPTH
	return RTResolve(OVERRIDE_DEPTH, uv).r;
#else
	return RTResolve(T_zdepth, uv).r;
#endif
}

vec3 GetUVPos()
{
	return vec3(GetFragUV(), GetDepth());
}
vec3 GetUVPos(vec2 uv)
{
	return vec3(uv, GetDepth(uv));
}

vec3 GetClipPos()
{
	return uv2clipZ(GetUVPos());
}
vec3 GetClipPos(vec2 uv)
{
	return uv2clipZ(GetUVPos(uv));
}

vec3 GetViewPos()
{
	return UnProject(GetClipPos());
}
vec3 GetViewPos(vec2 uv)
{
	return UnProject(GetClipPos(uv));
}

half Brightness(half3 c)
{
    return max(max(c.r, c.g), c.b);
}

#define LUM_ITU601 half3(0.299, 0.587, 0.114)

// avoid clutter
#include <p1/deferred/lighting_common.h>
#include <p1/deferred/gbuffer_access.h>

half lluma(vec3 c)
{
	return dot(c, vec3(0.2126, 0.7152, 0.0722));
}
half luminance(CONST half3 c)
{
	return dot( c, LUM_ITU601 );
}

float blendScreen(CONST float A, CONST float B)
{
	return (1 - (1 - A) * (1 - B));
}
half3 blendScreen(CONST half3 A, CONST half3 B)
{
	return (1 - (1 - A) * (1 - B));
}

float blendAvg(CONST float A, CONST float B)
{
 	return ((A + B) / 2);
}

half3 blendAvg(CONST half3 A, CONST half3 B)
{
 	return ((A + B) / 2);
}

half3 blendAdd(CONST half3 A, CONST half3 B)
{
 	return (A + B);
}

half3 blendMix(CONST half3 A, const half3 B, const half fac)
{
	return A+(B-A)*fac;
}

half blendMix(CONST half A, const half B, const half fac)
{
	return A+(B-A)*fac;
}

float blendMultiply(CONST float A, CONST float B)
{
 	return (A * B);
}

float blendMultiply(CONST float A, CONST float B, CONST float fac)
{
	return ((1-fac) * A + fac * A * B);
}

half3 blendMultiply(CONST half3 A, CONST half3 B)
{
 	return (A * B);
}

half3 blendAlpha(CONST half3 A, CONST half3 B, CONST half alpha)
{
 	//return ( (A * alpha) +  (B * (1 - alpha)) );
 	return lerp(A, B, saturate(alpha));
}
float4 blendAlphaF(float4 A, float4 B)
{
	return float4((A.rgb * A.a) + (B.rgb * (1.0f - A.a)), min(A.a + B.a, 1.0f));
}


float blendOverlay(CONST float A, CONST float B)
{
	half L = saturate(10 * (A - 0.45));
	float result1 = 2.0 * A * B;
	float result2 = 1.0 - 2.0 * (1.0 - B) * (1.0 - A);
	return lerp(result1, result2, L);
}

half3 blendOverlay(CONST half3 A, CONST half3 B)
{
	//half3 lumCoeff = half3(0.25,0.65,0.1);
	//half L = min(1,max(0,10*(dot(lumCoeff,A)- 0.45)));
	half L = saturate(10 * (luminance(A) - 0.45));
	half3 result1 = 2.0 * A * B;
	half3 result2 = 1.0 - 2.0 * (1.0 - B) * (1.0 - A);
	return lerp(result1, result2, L);
}
 
half3 blendClimate(CONST half3 A, CONST half3 B)
{
	if (A.r>0.99 && A.g>0.99 && A.b>0.99)
	{
		return half3(1.0,1.0,1.0);
	}else
	return A*B + ((A + B)/4.0 );
}

half3 blendOverlayHDR2(CONST half3 A, CONST half3 B, CONST half strength)
{
//float3 multiplyResults = base * blend;  
//float3 screenResults = 1 - (1 - base) * (1 - blend);  
//float3 t = max(0, sign(base - 0.5));  
//float3 finalColor = 2 * lerp(multiplyResults, screenResults, t); 
	half3 multiplyResults = A*B;//	base * blend;  
	half3 screenResults = half3(4) - (half3(4) - A) * (half3(1) - B);  
	half3 t = max(half3(0), sign(A - half3(10)));  
	//return (A+B+ 8*lerp(multiplyResults, screenResults, t)); 
	//return (A+strength*screenResults+ strength*20 * multiplyResults ); //the one
	return (A+strength*B);//+ strength*20 * multiplyResults ); 
	//return screenResults; 
}




float fresnel_a(float x)
{
	return ((( 1.0f/(pow(abs(x-1.12f),2))) - (1.0f/pow(1.12f,2))) / 68.652f);// (( 1/pow(1.0f-1.12f,2)) - (1/pow(1.12f,2)));
}

float fresnel(CONST float3 V, CONST float3 N, CONST half Power, CONST half Str, CONST half minRange)
{
	//TODO @Timon investigate the exact source of the NaN on the glass floor in the Thresher
//	float fresnel = pow(1-abs(dot(V, N)), Power) * Str;    // note: abs() makes 2-sided materials work
    float fresnel = pow(saturate(1-abs(dot(V, N))), Power) * Str;    // note: abs() makes 2-sided materials work
    float result = minRange + (1-minRange) * fresnel;
    return result;
}

float shadow(float x)
{
	//return ((10000.0f - (1.0f/(pow(abs(x-1.01f),2)))) / 9999.2f);//(( 1/pow(1.0f-1.01f,2)) - (1/pow(1.01f,2)));
	return ((10000.0f - (1.0f/(pow((x-1.01f),2)))) / 9999.2f);//(( 1/pow(1.0f-1.01f,2)) - (1/pow(1.01f,2)));
}

float SoftParticleAttenuation(float softmin, float softmax, float z)
{
	float delta = z - softmin;
	float range = softmax - softmin;
	return saturate(delta / (range + 0.00001)); // prevent division by zero
}

vec3 Tonemap(vec3 color)
{
	color *= half3(F_exposure / (Luminance() + 0.001f));
	color /= half3(1.0f + color);
	return color;
}
vec3 InvTonemap(vec3 color)
{
	color *= half3(Luminance() / F_exposure);
	return color;
}

mat2x3 calc_Light_Hair_PS(float3 DiffColor, float3 VertexToLight, float3 VertexToEye, float3 Normal, float3 Tangent, half SpecPower, half3 LightColor)
{
	mat2x3 Light = mat2x3(0); //(half2x3)0; // 698
	float3 Diff;
	float3 Spec;
	float3 HalfAngle = normalize(VertexToEye + VertexToLight);
	float NdL = dot(Normal, VertexToLight);
	Diff = float3(max(0.0, 0.75 * NdL + 0.25));

	float3 T1 = normalize(Tangent - 0.2 * Normal);
	float3 T2 = normalize(Tangent + 0.1 * Normal);
	
	float3 T1dH = float3(dot(T1, HalfAngle));
	float3 T2dH = float3(dot(T2, HalfAngle));
	
	float3 colorkey = DiffColor / luminance(DiffColor);
	Spec = pow(float3(1) - T1dH * T1dH, float3(0.5 * SpecPower * 0.2)) * (float3(0.5) + float3(0.5) * colorkey);
	Spec += pow(float3(1) - T2dH * T2dH, float3(0.5 * SpecPower)) * (float3(0.9) + float3(0.1) * colorkey);
	Spec *= saturate(3.0 * saturate(NdL) ); //Shadow term
	
	Light[0].rgb = Diff * LightColor.rgb;
	Light[1].rgb = Spec * LightColor.rgb;
	return Light;
}

//rescaled lambert
float lambert_half(CONST float NdL, CONST half lambertpower)
{
	return (pow( (NdL * 0.5) + 0.5, lambertpower));
}

half2 calc_LambertHalf_Phong(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;

	float3 R = reflect(-L, N);
	half NdL = dot(N, L);
		
	Light.x = lambert_half(NdL, Power.y);		// Diffuse (half lambert/scaled up)
	Light.y = pow(saturate(dot(R, V)) + HALF_SMALL_NUMBER, Power.x);	// Phong (half precission)
	Light.y *= saturate(3.0 * saturate(NdL)); 	// Shadow term
	
   	return Light;
}

half2 calc_LambertHalf_Blinn(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;
	
	CONST float3 H = normalize(V + L);
	CONST half NdL = dot(N, L);
	
	Light.x = lambert_half(NdL, Power.y);
	Light.y = pow(saturate(dot(N, H)), Power.x);//Specular
	Light.y *= saturate(3.0 * saturate(NdL)); //Shadow term
	
	return Light;
}

half2 calc_Lambert_Phong(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;

	CONST float3 R = reflect(-L, N); 	
	CONST half NdL = dot(N, L);
		
	Light.x = saturate(NdL);		// Diffuse
	Light.y = pow(saturate(dot(R, V)), Power.x);	// Phong (half precission)
	Light.y *= saturate(3.0 * Light.x); 	// Shadow term
	
   	return Light;
}

half2 calc_Lambert_Blinn(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;
	
	CONST float3 H = normalize(V + L); // NOTE: we need float here, but this triggers the flow control bug...???
	CONST half NdL = dot(N, L);
	
	Light.x = saturate(NdL); 		//Diffuse
	Light.y = pow(saturate(dot(N, H)), Power.x);//Specular
	Light.y *= saturate(3.0 * Light.x); //Shadow term
	
	return Light;
}

half3 calc_StraussNew(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float _smooth, 
					CONST float metal,
					CONST float diffusestr,
					CONST float specularstr,
					CONST float specfunc,
					CONST half3 lightcolor,
					CONST half3 diffusecolor,
					CONST half3 F0)
{
//	return specularstr *= 0.001;
	  // Make sure the interpolated inputs and
    // constant parameters are normalized
	half3 diffuse;
	
   //  float3 nn = normalize( N );
   //  float3 ln = normalize( L );
   //  float3 vn = normalize( V );
 
	
	float3 h = reflect( -L, N );
 
	    
    // Declare any aliases:
    float NdotL   = (dot( N, L ));
	
	float NdotV   = (dot( N, V ));
    float HdotV   = (dot( h, V ));
    float fNdotL  = fresnel_a( NdotL ); //((( 1.0f/(pow(abs(NdotL-1.12f),2)+0.01f)) - 0.797f) / 68.652f);
    float s_cubed = _smooth * _smooth * _smooth;
	//float s_cubed = _smooth * _smooth ;
		
	float fTransparency = 0.0f;
	
    // Evaluate the diffuse term
    float d  = ( 1.0f - metal * _smooth );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	
	
	diffuse = NdotL * d * Rd * diffusecolor;
   // Compute the inputs into the specular term
    float r = ( 1.0f - fTransparency ) - Rd;
 
	
    float j = fNdotL;// * shadow( NdotL ) * shadow( NdotV );
 
 

    // 'k' is used to provide small off-specular
    // peak for very rough surfaces. Can be changed
    // to suit desired results...
 /*   float k = 0.0f;//was 0.1
    float reflect = min( 1.0f, r + j * ( r + k ) );
 
    float3 C1 = float3( 1.0f, 1.0f, 1.0f );
    float3 Cs = C1 + metal * (1.0f - fNdotL) * (diffusecolor - C1);
 
 	half specatten = saturate(3.0 * saturate(NdotL));*/
	//half specatten = saturate(NdotL);

	

    // Evaluate the specular term
    
	//half3 specular = Cs* reflect*specatten;
    //specular *= pow( -HdotV, 3.0f / ((1.0f - smooth)) ); //(0.000000134123f + (1.0f - smooth))
	
	//specular = C1 * pow(saturate(HdotV), 32.0f);

	CONST float3 H2 = normalize(V + L);
	half3 specular = half3(pow(saturate(dot(N,H2)), 60.0f));
	//specular = float3(0.0f,0.0f,0.0f);

    // Composite the final result, ensuring
    // the values are >= 0.0f yields better results. Some
    // combinations of inputs generate negative values which
    // looks wrong when rendered...
    diffuse  = max( half3(0.0f), diffusestr*diffuse*lightcolor.rgb );
    specular = max( half3(0.0f), specularstr*specular*lightcolor.rgb * diffusecolor.rgb );
	//new : additive/multiply mix

	CONST half3 addSpecular = specfunc*specular;
	CONST half3 mulSpecular = (1.0 - specfunc)*specular;
	diffuse = (diffuse + addSpecular) + (diffuse*mulSpecular);
//	diffuse *= 0.00001;
	
	//old style aditive only
//	diffuse += specular/1.0; //diffuse += diffuse*specular;
//	diffuse += specular;
//	diffuse = half3(specularstr) / 100;
//	diffuse += V / 10;
//	diffuse += L / 100;
//	diffuse += V + L;
//	diffuse += N / 100;
//	diffuse += H2 / 100;
//	diffuse += half3(NdotL, NdotV, HdotV) / 100.0;
//	diffuse += half3(saturate(dot(N,H2)) / 50.0);
//	diffuse += half3(pow(saturate(dot(N,H2)), 60.0f));
	
    return diffuse;
}

half3 calc_StraussNew2(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float _smooth, 
					CONST float metal,
					CONST float diffusestr,
					CONST float specularstr,
					CONST float specfunc,
					CONST half3 lightcolor,
					CONST half3 diffusecolor,
					CONST half3 F0,
					CONST half3 specularcolor)
{
	  // Make sure the interpolated inputs and
    // constant parameters are normalized
	half3 diffuse;
	
   //  float3 nn = normalize( N );
   //  float3 ln = normalize( L );
   //  float3 vn = normalize( V );
     float3 h = reflect( -L, N );
 
	    
    // Declare any aliases:
    float NdotL   = (dot( N, L ));
	
	float NdotV   = (dot( N, V ));
    float HdotV   = (dot( h, V ));
    float fNdotL  = fresnel_a( NdotL ); //((( 1.0f/(pow(abs(NdotL-1.12f),2)+0.01f)) - 0.797f) / 68.652f);
    float s_cubed = _smooth * _smooth * _smooth;
	//float s_cubed = smooth * smooth ;
		
	float fTransparency = 0.0f;
	
    // Evaluate the diffuse term
    float d  = ( 1.0f - metal * _smooth );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	
	
	diffuse = NdotL * d * Rd * diffusecolor;
   // Compute the inputs into the specular term
    float r = ( 1.0f - fTransparency ) - Rd;
 
	
    float j = fNdotL;// * shadow( NdotL ) * shadow( NdotV );
 


    // 'k' is used to provide small off-specular
    // peak for very rough surfaces. Can be changed
    // to suit desired results...
     float k = 0.1f;//was 0.1
    float reflect = min( 1.0f, r + j * ( r + k ) );
 
    float3 C1 = specularcolor;//float3( 1.0f, 1.0f, 1.0f );
    //float3 Cs = C1 + metal * (1.0f - fNdotL) * (diffusecolor - C1);
	float3 Cs = C1 + metal * (1.0f - NdotL) * (diffusecolor - C1);
 
 	//half specatten = saturate(3.0 * saturate(NdotL));
	half specatten = saturate(NdotL);

	

    // Evaluate the specular term
 //   half3 specular = Cs * reflect*specatten;
//	specular *= pow( -HdotV, 3.0f / ((1.0f - _smooth)) ); //(0.000000134123f + (1.0f - _smooth))
	
	CONST float3 H2 = normalize(V+L);
	half3 specular = half3(pow(saturate(dot(N,H2)), 40.0f));

	
    // Composite the final result, ensuring
    // the values are >= 0.0f yields better results. Some
    // combinations of inputs generate negative values which
    // looks wrong when rendered...
    diffuse  = max(half3(0.0f), diffusestr*diffuse*lightcolor.rgb );
    specular = max(half3(0.0f), specularstr*specular*specularcolor.rgb*diffusecolor.rgb ); //*diffusecolor.rgb
	//new : additive/multiply mix

	CONST half3 addSpecular = specfunc*specular;
	CONST half3 mulSpecular = (1.0 - specfunc)*specular;
	diffuse = (diffuse + addSpecular) + (diffuse*mulSpecular);

	//old style aditive only
	//diffuse += specular; //diffuse += diffuse*specular;
	
    return diffuse;
}

#include <common_shadows.h>

#ifndef DISABLE_SHADOW_HELPERS
#ifndef OCULUS_SHADER
#ifndef DISABLE_SHADOW_SUPPORT

vec3 CSMColorCascades(in float depth)
{
	int cascadeIndex = -1;
	for(int i = 0; i < 4; ++i) {
		if(depth < V_csmthresholds[i]) {	
			cascadeIndex = i;
			break;
		}
	}
	if (cascadeIndex == -1) {
		return vec3(0.0f, 0.0f, 1.0f);
	}
	if (cascadeIndex == 0) {
		return vec3(1.0f, 0.0f, 0.0f);
	}
	if (cascadeIndex == 1) {
		return vec3(1.0f, 1.0f, 0.0f);
	}
	if (cascadeIndex == 2) {
		return vec3(0.0f, 1.0f, 0.0f);
	}
	if (cascadeIndex == 3) {
		return vec3(0.0f, 1.0f, 1.0f);
	}
	
	return vec3(1.0f, 1.0f, 1.0f);
}

//vec3 csmDebugRender(in float ndotl)
vec3 csmDebugRender(in float ndotl, in vec4 coords[5])
{
	
	float z = IO_worldview_pos.z; // would not work for deferred
	
	vec4 weights = getCSMWeights(coords, ndotl);
	//weights = getCSMWeightsChar(coords);
	float w0 = weights.x;
	float w1 = min(1.0f - weights.x, weights.y);
	float w2 = min(1.0f - weights.y, weights.z);
	float w3 = min(1.0f - weights.z, weights.w);
	float w4 = 1.0f - (weights.w + weights.z + weights.y + weights.x); // recheck this one
	w4 = 1 - saturate(w0 + w1 + w2 + w3);

	
	CONST vec3 c0color = vec3(4, 0,0);
	CONST vec3 c1color = vec3(0, 4, 4);
	CONST vec3 c2color = vec3(4, 0, 4);
	CONST vec3 c3color = vec3(4, 4, 4);
	CONST vec3 c4color = vec3(4, 4, 4);
	
	float ndotle = max(epsilon, ndotl);
	
#define CSM_DRAW_TEXELS

	vec3 dbgcol = vec3(0);
	dbgcol += c0color*w0;
#ifdef CSM_DRAW_TEXELS
	float t = floor(coords[0].x * F_shadowmapsize + 0.5f) + floor(coords[0].y * F_shadowmapsize + 0.5f);
	float s0 = w0 * GetCSMSampleHard(T_shadowCSM0, coords[0].xyz + biasCSM[0] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w0+s0);
#endif
#ifdef D_USE_CSM_C1
	dbgcol += c1color*w1;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[1].x * F_shadowmapsize + 0.5f) + floor(coords[1].y * F_shadowmapsize + 0.5f);
	float s1 = w1 * GetCSMSampleHard(T_shadowCSM1, coords[1].xyz + biasCSM[1] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w1+s1);
#endif
#endif
#ifdef D_USE_CSM_C2
	dbgcol += c2color*w2;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[2].x * F_shadowmapsize + 0.5f) + floor(coords[2].y * F_shadowmapsize + 0.5f);
	float s2 = w2 * GetCSMSampleHard(T_shadowCSM2, coords[2].xyz + biasCSM[2] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w2+s2);
#endif
#endif
#ifdef D_USE_CSM_C3
	dbgcol += c3color*w3;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[3].x * F_shadowmapsize + 0.5f) + floor(coords[3].y * F_shadowmapsize + 0.5f);
	float s3 = w3 * GetCSMSampleHard(T_shadowCSM3, coords[3].xyz + biasCSM[3] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w3+s3);
#endif
#endif
#ifdef D_USE_CSM_C4
	dbgcol += c4color*w4;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[4].x * F_shadowmapsize + 0.5f) + floor(coords[4].y * F_shadowmapsize + 0.5f);
	float s4 = w4 * GetCSMSampleHard(T_shadowCSM4, coords[4].xyz + biasCSM[4] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w4+s4);
#endif
#endif

	//if(z>F_shadowmaxdistance)
	//	dbgcol *= 0.0f;
	//
	//// draw cascade boundaries
	//CONST float linetreshold = z/500.0f;
	//
	//for(int i=0; i<4; ++i) {
	//	if(abs(z - V_csmthresholds[i]) < linetreshold)
	//		dbgcol = vec3(100.0f);
	//	// if(F_csm_blendstrength > 1.0f && abs(z - V_csmthresholds[i]) < linetreshold)
	//	// 	dbgcol = vec3(100.0f, 0.0f, 100.0f);
	//}

	
	return dbgcol;
		}


vec3 csmDebugRender(in float ndotl) {
	vec4 coords[5];
	return csmDebugRender(ndotl, coords);
}




// unified shadow interface
// make also depend on B_shadow?

float GetShadow(in float ndotl)
{
	// float z = RTResolve(T_gbuffer3).w;
	float z = IO_worldview_pos.z; // would not work for deferred
    
	CONST float FADE_OUT_PERCENTAGE = 0.1;
	float fade = saturate((z - (1.0 - FADE_OUT_PERCENTAGE) * F_shadowmaxdistance) / (FADE_OUT_PERCENTAGE * F_shadowmaxdistance));

	// if(fade>0.99)
	// 	return 1.0f;
	
	vec4 coords[5];
	coords[0] = IO_texshadowCSM0;
	coords[1] = IO_texshadowCSM1;
	coords[2] = IO_texshadowCSM2;
	coords[3] = IO_texshadowCSM3;
	coords[4] = IO_texshadowCSM4;
	return saturate(GetCSMShadow(ndotl, coords) + fade);
}

float GetShadow()
{
	return GetShadow(1.0f);
}

#endif //DISABLE_SHADOW_SUPPORT
#endif //OCULUS_SHADER
#endif //DISABLE_SHADOW_HELPERS

// #else /*GFX_VULKAN*/
/*
float GetShadow(in float ndotl)
{
	return 1.0f;
}

float GetShadow()
{
	return 1.0f;
}

#endif*/

//-------------------------------------------------------------------------------
// Lighting/Shadow defines ( pixel-shader specific )
//-------------------------------------------------------------------------------

#define CALC_AMBIENT(DIFFUSE, AMBIENT, OUT_COLOR)														\
	OUT_COLOR += AMBIENT * DIFFUSE;


#define CALC_GLOBAL_DIRLIGHT(NR, LIGHTFUNCTION) 														\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;											\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);										\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * F_globallightscale);								\
       	half2 DiffSpecTerms = LIGHTFUNCTION(Normal, V_direction##NR.rgb, VertexToEye, LightPower.xy); 	\
		DiffuseLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 									\
		SpecularLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y;									\
	}

#define CALC_GLOBAL_DIRLIGHT_SHADOW(NR, LIGHTFUNCTION_GLOBAL, LIGHT_POWER, IN_OUT_DIFFUSE, IN_OUT_SPECULAR, SHADOW) 	\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																										\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;												\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);											\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * F_globallightscale);									\
       	half2 DiffSpecTerms = LIGHTFUNCTION_GLOBAL(Normal.xyz, V_direction##NR.xyz, VertexToEye, LIGHT_POWER); 	\
       	DiffSpecTerms.x *= saturate(SHADOW * 0.9 + 0.1); /* sum to 1.0, 10% light still at shadow) */		\
       	DiffSpecTerms.y *= saturate(SHADOW * SHADOW); /* we dont want specular in shadow areas */			\
		IN_OUT_DIFFUSE.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 									\
		IN_OUT_SPECULAR.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y; 									\
	}

#define CALC_STRAUSS_DIRLIGHT_SHADOW(NR, DIFFUSE, F0, SHADOW, OUT_COLOR)								\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*12.0f;								\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew(Normal.rgb, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 		0.5,				\
										LightColor.rgb, DIFFUSE, F0); 								\
	/*	OUT_COLOR.rgb *= 0.0001; OUT_COLOR.rgb += half3(specstr);*/	\
	}
	
#define CALC_STRAUSS_DIRLIGHT_2_SHADOW(NR, DIFFUSE, SPECULAR, F0, SHADOW, OUT_COLOR)								\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*6.0f;								\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew2(Normal, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 		0.5,				\
										LightColor.rgb, DIFFUSE, F0,SPECULAR); 								\
	}

#define CALC_STRAUSS_DIRLIGHT_COCKPIT_SHADOW(NR, DIFFUSE, F0, SHADOW, OUT_COLOR)							\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																										\
		half4 LightColor = V_lightcolor##NR.rgba;															\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale*0.5;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*256.0f;					\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 1.0,			\
										LightColor.rgb, DIFFUSE, F0); 										\
	}

#define CALC_GLOBAL_DIRLIGHT_PLANET(NR, LIGHTFUNCTION) \
	if (V_lightcolor##NR.a > 0.0)									\
	{																	\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;			\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);		\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * 0.15); /* HACK layer multiply + HDR = bad idea */					\
       	half2 DiffSpecTerms = LIGHTFUNCTION(Normal, V_direction##NR.xyz, VertexToEye, LightPower.xy ); \
		DiffuseLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 	\
		SpecularLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y;	\
	}																	

#define CALC_STRAUSS_PLANET_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		float specstr = S_specularstr * (TexSpecularStr.g)*12.0f;												\
		float diffstr = S_diffusestr;																	\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.xyz, VertexToEye, 						\
										Smoothness2, Metallness2, diffstr, specstr, 0.0	,					\
										LightColor.rgb, DIFFUSE, F0);								\
	/*	OUT_COLOR.rgb *= 0.0001; OUT_COLOR.rgb += LightColor.xyz/ 10;*/	\
	}


#define CALC_STRAUSS_2ND_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
		LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g)*4.0f;												\
		CONST float diffstr = S_diffusestr;																	\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.xyz, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 	1.0,					\
										LightColor.rgb, DIFFUSE, F0);								\
	}

#ifdef P1_SHADERS

float4 calc_Strauss_PBR(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float fSmoothness, 
					CONST float fMetalness,
					CONST float fTransparency,
					CONST float refractionIndex,
					CONST half3 lightcolor,
					CONST half3 cDiffuse
					)
{
	// Make sure the interpolated inputs and
	// constant parameters are normalized
	float3 n = N;//normalize( N );
	float3 l =normalize( L );
	float3 v = V;//normalize( V );
	float3 h = reflect( l, n );

	// Declare any aliases:
	float NdotL   = dot( n, l );
	float NdotV   = dot( n, v );
	float HdotV   = dot( h, v );
	float fNdotL  = fresnel_a( NdotL );
	float s_cubed = fSmoothness * fSmoothness * fSmoothness;

	//	return float4(fNdotL,fNdotL,fNdotL,1.0f);

	// Evaluate the diffuse term
	float d  = ( 1.0f - fMetalness * fSmoothness );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	float3 diffuse = NdotL * d * Rd * cDiffuse  * lightcolor;

	// Compute the inputs into the specular term
	float r = ( 1.0f - fTransparency ) - Rd;

	float j = fNdotL * shadow( NdotL ) * shadow( NdotV );

	// 'k' is used to provide small off-specular
	// peak for very rough surfaces. Can be changed
	// to suit desired results...
	CONST float k = 0.01f;
	float reflect = min( 1.0f, r + j * ( r + k ) );

	float3 C1 = float3( 1.0f, 1.0f, 1.0f );
	float3 Cs = C1 + fMetalness * (1.0f - fNdotL) * (cDiffuse - C1);


	// Evaluate the specular term
	float3 specular = Cs * reflect;
	specular *= pow( -HdotV, 3.0f / (1.0f - fSmoothness) );
	//below: test to tint spec more to material color
	specular = specular * (1.1f-fMetalness)+ specular*(fMetalness+0.1f)*cDiffuse * lightcolor;
	// Composite the final result, ensuring
	// the values are >= 0.0f yields better results. Some
	// combinations of inputs generate negative values which
	// looks wrong when rendered...
	diffuse  = max( float3(0.0f), diffuse );
	specular = max( float3(0.0f), specular*2.0f *  float3(lambert_half(NdotL, 2.2)) );
	// return float4(specular, 1.0f );
	return float4( diffuse + specular, luminance(specular));
}

	float4 calc_Strauss_PBR_aniso(	CONST float3 N,
					CONST float3 L,
					CONST float3 V,
					CONST float fSmoothness,
					CONST float fMetalness,
					CONST float fTransparency,
					CONST float refractionIndex,
					CONST half3 lightcolor,
					CONST half3 cDiffuse,
					float2 fAnisotropicRoughness
					)
	{
		// Make sure the interpolated inputs and
		// constant parameters are normalized
		float3 n = N;//normalize( N );
		float3 l =normalize( L );
		float3 v = V;//normalize( V );
		float3 h = reflect( l, n );
		float3 h2 = normalize( l + v );

		// Declare any aliases:
		float NdotL   = dot( n, l );
		float NdotV   = dot( n, v );
		float HdotV   = dot( h, v );
		float fNdotL  = fresnel_a( NdotL );
		float s_cubed = fSmoothness * fSmoothness * fSmoothness;

		// Apply a small bias to the roughness
		// coefficients to avoid divide-by-zero
		fAnisotropicRoughness += float2( 1e-5f, 1e-5f );

		// Define the coordinate frame
		float3 epsilon   = float3( 1.0f, 0.0f, 0.0f );
		float3 tangent   = normalize( cross( n, epsilon ) );
		float3 bitangent = normalize( cross( n, tangent ) );
		// float VdotN = dot( v, n );
		// float LdotN = dot( l, n );
		float H2dotN = dot( h2, n );

		float H2dotT = dot( h2, tangent );
		float H2dotB = dot( h2, bitangent );

		// Evaluate the specular exponent
		float beta_a  = H2dotT / fAnisotropicRoughness.x;
		beta_a       *= beta_a;

		float beta_b  = H2dotB / fAnisotropicRoughness.y;
		beta_b       *= beta_b;

		float beta = -2.0f * ( ( beta_a + beta_b ) / ( 1.0f + H2dotN ) );

		// Evaluate the specular denominator
		float s_den  = 4.0f * 3.14159f; 
		s_den       *= fAnisotropicRoughness.x;
		s_den       *= fAnisotropicRoughness.y;
		s_den       *= sqrt( abs(NdotL * NdotV) );	//<Timon> I had to add the abs because apparently in HLSL sqrt of negative values is fine

		// Compute the final specular term
		//float3 Specular = Ps * ( exp( beta ) / s_den );


		// Evaluate the diffuse term
		float d  = ( 1.0f - fMetalness * fSmoothness );
		float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
		float3 diffuse = NdotL * d * Rd * cDiffuse * lightcolor;

		// Compute the inputs into the specular term
		float r = ( 1.0f - fTransparency ) - Rd;

		float j = fNdotL * shadow( NdotL ) * shadow( NdotV );

		// 'k' is used to provide small off-specular
		// peak for very rough surfaces. Can be changed
		// to suit desired results...
		CONST float k = 0.01f;
		float reflect = min( 1.0f, r + j * ( r + k ) );

		float3 C1 = float3( 1.0f, 1.0f, 1.0f );
		float3 Cs = C1 + fMetalness * (1.00001f - fNdotL) * (cDiffuse - C1);

		// Evaluate the specular term
		float3 specular;
// 		specular = Cs * reflect;
// 		specular *= pow( -HdotV, 3.0f / (1.00001f - fSmoothness) );
	//	specular = C1*NdotL*( exp( beta ) / s_den);
		specular = float3( exp( beta ) / s_den) * float3(fSmoothness+0.001f);
		//to tint spec more to material color
		specular = (specular * saturate(1.00001f-fMetalness)+ specular*saturate(fMetalness+0.0001f)*cDiffuse) * lightcolor ;
		//specular = (specular * saturate(1.00001f-pow(fMetalness,0.1f))+ specular*saturate(pow(fMetalness,0.1f)+0.0001f)*cDiffuse) * lightcolor ;
	
		// Composite the final result, ensuring
		// the values are >= 0.0f yields better results. Some
		// combinations of inputs generate negative values which
		// looks wrong when rendered...
		diffuse  = max( float3(0.0f), diffuse );
		specular = max( float3(0.0f), specular *  lambert_half(NdotL, 6.2) );
		//specular = max( 0.0f, specular*(30.0f+15.0f*fMetalness) *  lambert_half(NdotL, 2.2) );
		//return float4(specular, 1.0f );
		return saturate(float4( diffuse + specular, luminance(specular) ));
	}

	#define CALC_STRAUSS_PBR_ANI(NR, DIFFUSE, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;														\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float transparency = 0.0f;																\
		CONST float refraction = 1.0f;																	\
		OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.rgb, VertexToEye, 			\
										SmoothnessVal, MetalnessVal, transparency, refraction,			\
										LightColor.rgb, DIFFUSE,SmoothnessVal);							\
	}

	#define CALC_STRAUSS_PBR_ANI2(NR, DIFFUSE, OUT_COLOR)												\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;														\
    	LightColor.rgb = (LightColor.rgb) * F_globallightscale;											\
		CONST float transparency = 0.0f;																\
		CONST float refraction = 0.0f;																	\
		OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.rgb, VertexToEye, 			\
										SmoothnessVal, MetalnessVal, transparency, refraction,			\
										LightColor.rgb, DIFFUSE,fAnisotropicRoughness).rgb;					\
	}

	#define CALC_STRAUSS_PBR_ANI2_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
		{																									\
			half4 LightColor = V_lightcolor##NR.rgba;													\
			LightColor.rgb = (LightColor.rgb) * F_globallightscale;				\
			CONST float transparency = 0.0f;																\
			CONST float refraction = 0.0f;																\
			OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.xyz, VertexToEye, 						\
											SmoothnessVal, MetalnessVal, transparency, refraction,						\
											LightColor.rgb, DIFFUSE, fAnisotropicRoughness).rgb;								\
		}
	#define CALC_STRAUSS_PBR_TRANSP_DIRLIGHT(NR, DIFFUSE, ALPHA, OUT_COLOR)												\
		{																									\
			half4 LightColor = V_lightcolor##NR.rgba;													\
			LightColor.rgb = (LightColor.rgb) * F_globallightscale;				\
			CONST float transparency = 1.0f-ALPHA;																\
			CONST float refraction = 0.0f;																\
			CONST float SmoothnessVal = 0.20f;																\
			CONST float MetalnessVal = 0.0f;																\
			CONST float2 fAnisotropicRoughness = float2(0.75f,0.75f);											\
			OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.xyz, VertexToEye, 						\
											SmoothnessVal, MetalnessVal, transparency, refraction,						\
											LightColor.rgb, DIFFUSE,fAnisotropicRoughness).rgb;								\
		}
	
#endif


vec3 global_lights(in vec3 wn, in vec3 view_pos, in vec3 Albedo, in float Metalness, in float Roughness, bool dossr, vec4 prev)
{
	vec3 wv = normalize(-view_pos) * mat3(M_view);
	vec3 wr = reflect(-wv, wn);

	float ambient_occlusion = 1.0f;
	// ambient_occlusion = mix(1, Shadow, n_dot_l); // ambient attenuation wrt. shadow (sometimes "weird")
	ambient_occlusion = GetSSAO();
	
	// vec3 cspec = mix(vec3(0.04), Albedo, Metalness);
	// vec3 cdiff = Albedo * (1-Metalness);
	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	get_colors(Albedo, Metalness, cspec, cdiff);
	// vec3 cdiff = Albedo * saturate(1.0f - luminance(cspec)); // alt energy conservation
	
	// dirlight data
	vec3 ldirs[2];
	vec3 lcolors[2];
	float direct_occlusions[2];

	ldirs[0] = normalize(V_direction1.xyz);
	ldirs[1] = normalize(V_direction2.xyz);

#ifdef LOCALSPEC
	lcolors[0] = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale*2.0f;
	lcolors[1] = XR_TO_linearRGB(V_lightcolor2.rgb) * F_globallightscale*2.0f;
#else
	lcolors[0] = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale;
	lcolors[1] = XR_TO_linearRGB(V_lightcolor2.rgb) * F_globallightscale;
#endif


	for (int i = 0; i < 2; ++i) {
		direct_occlusions[i] = saturate(dot(ldirs[i], wn));
	}
	
	//vec3 l = mat3(M_view) * normalize(V_direction1.xyz);

	// shadows for mainlight
	float Shadow = 0.0f;
	vec4 test = vec4(0);
#ifndef DISABLE_SHADOW_HELPERS
#ifndef DISABLE_SHADOW_SUPPORT
	if (B_shadow && direct_occlusions[0] > 0.0f) {
		float ndotle = max(epsilon, direct_occlusions[0]);
		CONST float FADE_STR = 0.1;
		CONST float FADE_STR_DIST = 0.5;
		if (F_shadowmaxdistance < 6000.0f) {
			FADE_STR_DIST = 0.7;
		}

		float fade = saturate((length(view_pos) - (1.0 - FADE_STR) * F_shadowmaxdistance) / (FADE_STR_DIST * F_shadowmaxdistance));

		vec4 coords[5];
		coords[0] = mul(float4(view_pos, 1), M_shadowCSM0);
		coords[1] = mul(float4(view_pos, 1), M_shadowCSM1);
		coords[2] = mul(float4(view_pos, 1), M_shadowCSM2);
		coords[3] = mul(float4(view_pos, 1), M_shadowCSM3);
		coords[4] = mul(float4(view_pos, 1), M_shadowCSM4);
		direct_occlusions[0] *= saturate(fade + GetCSMShadow(direct_occlusions[0], coords));
		
	/*	vec4 weights = getCSMWeights(coords);
		float w0 = weights.x;
		float w1 = min(1.0f-weights.x, weights.y);
		float w2 = min(1.0f-weights.y, weights.z);
		float w3 = min(1.0f-weights.z, weights.w);
		float w4 = 1.0f - (weights.w+weights.z+weights.y+weights.x); // recheck this one
		w4 = 1 - saturate(w0+w1+w2+w3);
		
// 		direct_occlusions[0] *= GetCSMSample3Taps(T_shadowCSM2, mul(float4(view_pos, 1), M_shadowCSM2).xyz + biasC2/ndotle);
// 		direct_occlusions[0] *= GetCSMSample3Taps(T_shadowCSM3, mul(float4(view_pos, 1), M_shadowCSM3).xyz + biasC3/ndotle);
		
// 		Shadow += GetCSMSample3Taps(T_shadowCSM2, mul(float4(view_pos, 1), M_shadowCSM2).xyz + biasC2/ndotle);
		
// 			Shadow += w0 * GetCSMSample3Taps(T_shadowCSM0, coords[0].xyz + biasC0/ndotle);
// 			Shadow += w1 * GetCSMSample3Taps(T_shadowCSM1, coords[1].xyz + biasC1/ndotle);
// 			Shadow += w2 * GetCSMSample3Taps(T_shadowCSM2, coords[2].xyz + biasC2/ndotle);
// 			Shadow += w3 * GetCSMSample2Taps(T_shadowCSM3, coords[3].xyz + biasC3/ndotle);
// 			Shadow += w4 * GetCSMSampleFast(T_shadowCSM4, coords[4].xyz + biasC4/ndotle);
		
		direct_occlusions[0] *= saturate(Shadow);
// 		test = getCSMWeights(coords);
// 		test = coords[1];/**/
	}
#endif
#endif

	// light accumulation
	vec3 light_accum = vec3(0);

	// dirlights
	for(int i=0; i<2; i++) {
		//float n_dot_l = saturate(dot(Normal, ldirs[i]));
		//float direct_occlusion = n_dot_l;
		//if(i==0) { // only attenuation for 1st light
		//	direct_occlusion *= Shadow;
		//}
		CONST float light_radius = V_deferred_lightparams.x*10; // dbg scale

		// todo: slightly refactor the following
		vec3 L;
		vec3 E_sph = direct_occlusions[i] * lcolors[i] * EvalSphereLight(light_radius, ldirs[i] * 1000, wv, wn, wr, Roughness, L);
		//E_sph *= PI; // diffuse normalization
		L = normalize(L);
		light_accum += EvalBRDF(cspec, cdiff, Roughness, L, wv, wn, vec2(0, 1)) * E_sph; // specular
		
		// clearcoat
		//float clearcoat_spec = cc * EvalBRDF(vec3(0.05), cdiff, 0.1, L, v, Normal2, vec2(0,1)).r; // ok since dielectric reflection
		//light_accum += clearcoat_spec * E_sph;

		vec3 E_diffuse = direct_occlusions[i] * ambient_occlusion * lcolors[i];
		//light_accum += cdiff / PI * E_diffuse; // diffuse
		light_accum += cdiff * E_diffuse; // diffuse
	}
	
	{// ambient light
		// reduce roughness based on v_dot_n yields nicer fresnel contours
		float v_dot_n = saturate(dot(wv, wn));
		
		// smaller cone at edges to highlight fresnel
		float ambRoughness = mix(Roughness*0.3, Roughness, pow(v_dot_n, 1.0/3.0));
		//ambRoughness = Roughness; // deactivated, effect too strong
		
		// vec3 spec_amb =  simple_spec_brdf_ibl(T_ibl_envmap, cspec, Roughness, wn, wv);
		// vec3 spec_amb =  spec_brdf_ibl(T_ibl_envmap, vec3(0,0,0), T_preintegrated_GGX, cspec, ambRoughness, wn, wv);
		vec3 Eamb = V_ambient1.rgb;

		//TODO SSR has higher priority!
		vec4 ssr = vec4(0);
		if (dossr) {
			ssr = RTResolveSoft(T_ssr);
			ssr.a = SSR_GetHit(ssr.a);
// 			ssr *= (1 - ambRoughness);
// 			ssr.rgb *= cspec;
// 			float n_dot_v = saturate(dot(wn, wv));

// 			vec2 env_brdf = textureLod(T_preintegrated_GGX, vec2(ambRoughness, n_dot_v), 0).xy;
			// return vec3(env_brdf, 0);
// 			ssr.rgb *= (cspec*env_brdf.x + env_brdf.y);
		}

		float a = ssr.a;
		vec3 first_sum = a * ssr.rgb;

		a += prev.a;
		first_sum += saturate(1 - a) * spec_first_sum_ibl(T_ibl_envmap, ambRoughness, wn, wv).rgb;
		first_sum += Eamb;
		vec3 spec_amb = spec_brdf(first_sum, cspec, ambRoughness, v_dot_n);
		vec3 diff_amb = saturate(1 - prev.a) * cdiff * (get_irradiance(T_ibl_envmap, wn) + Eamb);

		light_accum += (spec_amb + diff_amb) * ambient_occlusion;

	}
	
	light_accum = clamp(light_accum.rgb, 0, 10); // safety clamp, not visible
	return DEFERRED_HACK_TO_sRGB(light_accum) * ambient_occlusion * vec3(0.0, 1.0, 0.0);	//TODO why is there a double ambient_occlusion multiply?!
}

vec3 global_lights(in vec3 wn, in vec3 view_pos, in vec3 Albedo, in float Metalness, in float Roughness, bool dossr)
{
	return global_lights(wn, view_pos, Albedo, Metalness, Roughness, dossr, vec4(0));
}

#include <common_envmap.h>

#if SHADERFLAGS & SHADERFLAG_FORWARD_ENVMAP_PROBES

// // #define GLASS_PROBE_BLENDING_DEBUG /* def or ndef */
// WARNING also uncomment the undef below for safety

vec4 global_envmap_resolve_glass(vec3 wn, vec3 wv, float Roughness, float shadow)
{
	//TODO @Timon/Florian the below sampling math seems "a bit sketchy" and has somewhat specific to the glass shader,
	// would be nice to generalize it into multiple functions, at least one with proper math? further and do the proper math if we ever have a use-case for it?
	vec3 wpos = GetFragWorld();
	half3 R = reflect(-wv, wn);
	vec4 env = vec4(0);
#ifdef GLASS_PROBE_BLENDING_DEBUG
	vec3 col = vec3(0);
#endif
	for (uint i = 0; i < U_envmapprobe_num; ++i) {
		// spec str,rgb vs luminosity, aka bright areas reflect more than dark, "shiny" also reflect more -> spec str?
		//ColorEnvi.rgb += S_environmentstr * textureLod/*texCUBE*/(T_ibl_envmap, R_Eye,Roughness*MaxSpecularLevel(T_ibl_envmap)).rgb * ((saturate(1.0f-pow(dot(Normal,VertexToEye),0.5f))+0.1)/1.1f)*(1.0-ColorBaseDiffuse.a);
		vec3 r = R;
		r = EnvMapAdjust(i, wpos, r);
		vec4 e = textureLod(S_environment_map[i], r, Roughness * MaxSpecularLevel(S_environment_map[i]) + 0.50); //TODO darkening, etc?? like for dirt border
		float fade = EnvMapFading(i);
		e *= fade;
		// only multiply rgb here, so we still block the cluster envmap from shining through geometry
		e.rgb *= U_envmapprobe_insideglassfadein;

#ifdef GLASS_PROBE_BLENDING_DEBUG
		col += V_envmapprobe_color[i].rgb * fade * (1 - env.a);
#endif
		// e.a = 1; return e;
		env += e * (1 - env.a);
	}
#ifdef GLASS_PROBE_BLENDING_DEBUG
	DebugStore(vec4(col, 0.2f));
#endif
	{
		vec4 e = textureLod(T_ibl_envmap, R, Roughness * MaxSpecularLevel(T_ibl_envmap) + 0.50) * shadow; //TODO darkening, etc?? like for dirt border
		e.rgb *= U_envmapprobe_insideglassfadein;
		env += e * (1 - env.a);
	}
	return env;
}

// #undef GLASS_PROBE_BLENDING_DEBUG

#endif

//#extension GL_ARB_shading_language_420pack : enable // not supported on OSX (10.10.4)

/*useful pragmas for nvidia
#pragma optionNV(fastmath on)
#pragma optionNV(fastprecision on)
#pragma optionNV(ifcvt none)
#pragma optionNV(inline all)
#pragma optionNV(strict on)
#pragma optionNV(unroll all)
#pragma optionNV(inline all)
*/

#include <jon_mod.h>

#define D_DYNAMIC 1
#define D_STATIC 2
#define D_SPECIAL 3

#define X_CONCAT(a,b) a##b

// #define centroid /*centroid*/	//workaround for RADV:/


	#define VK_BLOCK(name,block)			\
		layout(set = ENUM_BUFFER_##name, binding = 0, std140) uniform BUFFER_##name			\
		{			\
			block			\
		};


#ifdef XIMGUI
	#define I_HATE_MACROS			\
		uniform mat4 DEBUG_Matrix0;			\
		uniform mat4 DEBUG_Matrix1;			\
		uniform vec4 DEBUG_Vector0;			\
		uniform vec4 DEBUG_Vector1;			\
		uniform vec4 DEBUG_Vector2;			\
		uniform vec4 DEBUG_Vector3;			\
		uniform float DEBUG_Float0;			\
		uniform float DEBUG_Float1;			\
		uniform float DEBUG_Float2;			\
		uniform float DEBUG_Float3;			\
		uniform int DEBUG_Int0;				\
		uniform int DEBUG_Int1;				\
		uniform int DEBUG_Int2;				\
		uniform int DEBUG_Int3;
#else
	#define I_HATE_MACROS
#endif
	
VK_BLOCK(CAMERA,
	uniform mat4 M_view;
	uniform mat4 M_projection;
	uniform mat4 M_invprojection;
	uniform mat4 M_viewprojection;
	uniform mat4 M_viewinverse;
	
	uniform mat4 M_shadowCSM0Clip;
	uniform mat4 M_shadowCSM1Clip;
	
	uniform vec4 V_viewportpixelsize/* = vec4(1024, 768, 3, 5000000)*/;
	uniform vec4 V_cameraposition;
	
	uniform vec4 V_ambient1;

	uniform vec4 V_direction1;
	uniform vec4 V_lightcolor1;
	uniform vec4 V_direction2;
	uniform vec4 V_lightcolor2;
	uniform vec4 V_direction3;
	uniform vec4 V_lightcolor3;

	uniform vec4 V_light_direction_view[3];
	
	uniform vec4 V_tintcolor;			//for tinted_glass: DEF_AUTO_PARA(BlendColor	, TINTCOLOR				, float3	, {1.0, 1.0, 1.0})

	uniform vec4 V_csmthresholds;
	
	
	uniform vec4 V_volume_range;
	uniform vec4 V_volume_size;
	
	uniform vec4 V_volume_scatter_power[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_sigma_extinction[GFX_MAX_VOLUME_TYPES];
	
	uniform vec4 V_volume_phase0_param[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_phase1_param[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_phase2_param[GFX_MAX_VOLUME_TYPES];
	
	uniform ivec4 I_volume_phases[GFX_MAX_VOLUME_TYPES];
/*	uniform int I_volume_phase_num[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase0[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase1[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase2[GFX_MAX_VOLUME_TYPES];*/
	
/*	uniform vec4 V_volume_type0_scatter_power;
	uniform vec4 V_volume_type0_sigma_extinction;
	
	uniform vec4 V_volume_type0_phase0_param;
	uniform vec4 V_volume_type0_phase1_param;
	uniform vec4 V_volume_type0_phase2_param;
	
	uniform vec4 V_volume_type1_scatter_power;
	uniform vec4 V_volume_type1_sigma_extinction;
	
	uniform vec4 V_volume_type1_phase0_param;
	uniform vec4 V_volume_type1_phase1_param;
	uniform vec4 V_volume_type1_phase2_param;
	
	uniform vec4 V_volume_type2_scatter_power;
	uniform vec4 V_volume_type2_sigma_extinction;
	
	uniform vec4 V_volume_type2_phase0_param;
	uniform vec4 V_volume_type2_phase1_param;
	uniform vec4 V_volume_type2_phase2_param;*/
	
	uniform float F_globallightscale;
	uniform float F_locallightscale;
	uniform float F_time;
	uniform float F_framedeltatime;
	uniform float F_exposure;			//DEF_AUTO_PARA(Exposure, EXPOSURE, float, (0.5))
	uniform float F_ibl_maxvalidlevel;

	uniform float F_csm_blendstrength;
	uniform float F_shadowmapsize; // used for kernel width adjustment
	uniform float F_shadowmaxdistance;		//DEF_AUTO_PARA(ShadowMaxDist	, SHADOWMAXDISTANCE			, float		, {5000.0})
	//I think F_shadowbias, F_shadowtexelbias, F_shadowmaxdistance is never set,
	// and F_shadowmapsize is never used...
	// F_shadowmaxdistance is set according to videoparameters
	uniform bool B_csmpcfenabled;
	uniform float F_texturefactorCSM0;
	uniform float F_texturefactorCSM1;
	uniform float F_texturefactorCSM2;
	uniform float F_texturefactorCSM3;
	uniform float F_texturefactorCSM4;

	uniform bool B_ssao_enabled;
	uniform bool B_lighting;
	
	uniform bool B_csmdebugcolor;
	
	uniform bool B_shadow;
	
	uniform float F_volume_off;
	uniform float F_volume_scale;

	uniform bool B_pom_enabled;
	uniform float F_pom_minlayers;
	uniform float F_pom_maxlayers;
	
	I_HATE_MACROS
)

#undef I_HATE_MACROS

#ifdef GFX_VULKAN
	layout(constant_id = 2) const bool B_deferred_draw = false;
	layout(constant_id = 3) const int I_instancetype = VERTEXTYPE_ENUMSIZE;
	
#ifdef GFX_EXTENDEDVDATA
	VK_BLOCK(WORLD,
		uniform mat4 M_worldviewprojection;
		uniform mat4 M_world;
		
		uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
		uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
		uniform mat4 M_shadowCSM2;
		uniform mat4 M_shadowCSM3;
		uniform mat4 M_shadowCSM4;
		
		uniform vec4 V_blendcolor;
		uniform float F_alphascale;
		uniform bool B_packedtangentframe;
		uniform bool B_vertexdata0;
		uniform bool B_vertexdata1;
		uniform bool B_vertexdata2;
		uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)
	)
#else
	VK_BLOCK(WORLD,
		uniform mat4 M_worldviewprojection;
		uniform mat4 M_world;

		uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
		uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
		uniform mat4 M_shadowCSM2;
		uniform mat4 M_shadowCSM3;
		uniform mat4 M_shadowCSM4;

		uniform vec4 V_blendcolor;
		uniform float F_alphascale;
		uniform bool B_packedtangentframe;
		uniform bool B_vertexdata0;
		uniform bool B_vertexdata1;
		uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)
	)
#endif

/*	layout(push_constant) uniform BUFFER_PC
	{
		mat4 worldviewprojection;
		mat4 world;
	}PC;
	#define M_worldviewprojection PC.worldviewprojection
	#define M_world PC.world*/
#else
	uniform mat4 M_worldviewprojection;
	uniform mat4 M_world;
	
	uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
	uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
	uniform mat4 M_shadowCSM2;
	uniform mat4 M_shadowCSM3;
	uniform mat4 M_shadowCSM4;
	
	// uniform mat4 M_worldview; // these two will be needed for proper view space lighting
	// uniform mat4 M_worldviewinversetranspose;
	uniform vec4 V_blendcolor;
	uniform float F_alphascale;
	uniform bool B_packedtangentframe;
	uniform bool B_vertexdata0;
	uniform bool B_vertexdata1;
#ifdef GFX_EXTENDEDVDATA
	uniform bool B_vertexdata2;
#endif
	uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)

	uniform bool B_deferred_draw;			// set whenever a deferred shader is called in a deferred way
	
	uniform int I_instancetype = VERTEXTYPE_ENUMSIZE;//TODO @Timon if we ever implement it in OGL it should be specialized
	
	D_shadow_QUAL bool B_shadow = D_shadow_VALUE;
	
	#if D_alpha_test == D_DYNAMIC
	uniform bool B_alpha_test = false;		//for alpha-testing
	#elif D_alpha_test == D_SPECIAL
	const bool B_alpha_test = D_alpha_test_VALUE;
	//#define B_alpha_test D_alpha_test_VALUE
#endif

#endif

layout(set = ENUM_BUFFER_DYNAMIC, binding = 0, std140) uniform BUFFER_DYNAMIC
{
uniform mat4 M_texturematrix0;
uniform mat4 M_texturematrix1;
uniform mat4 M_texturematrix2;
uniform mat4 M_texturematrix3;
uniform bool B_textureanimation;

#define B_vertexcolorsrgb true

//for luminance
uniform float F_eyeadaptionspeed;	// DEF_AUTO_PARA(EyeAdaptionSpeed, EYEADAPTIONSPEED, float, 0.9)


//for SSAO
uniform vec4 V_frustumsize;			//DEF_AUTO_PARA(FrustumSize		, FRUSTUMSIZE		, float4	, {1.0, 1.0, 0.0, 0.0})

//for tonemap
//DEF_AUTO_PARA(ScreenLuminance, LUMINANCE, float4, (0,0,0,0))
uniform bool B_srgbout;			//DEF_AUTO_PARA(SRGBOut, SRGBOUT, bool, false)
uniform vec4 V_textureviews;	//DEF_AUTO_PARA(TextureViews, TEXTUREVIEWS, float4, {1280.0, 720.0, 1280.0, 720.0})

//#ifdef PROJECT_XR
uniform float F_lutblend;		//DEF_AUTO_PARA(ColorLUTBlend, DIFFUSE_SCALE, float, (0.0))
//#endif

#if SHADERFLAGS & SHADERFLAG_FORWARD_ENVMAP_PROBES
uniform vec4 V_envmapprobe_shape[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_color[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform mat4 M_envmapprobe_world[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform mat4 M_envmapprobe_world_rot[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_volumeoffset[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_fadein[GFX_MAX_FORWARD_ENVMAP_PROBES];
#else
uniform mat4 M_envmapprobe_world;
uniform mat4 M_envmapprobe_world_rot;
uniform vec4 V_envmapprobe_volumeoffset;
uniform vec4 V_envmapprobe_shape;
#endif

DPREDEF_BUFFER_DYNAMIC

#if defined(CHROMATIC_ABERRATION) && defined(GFX_CHROMA_SAMPLES)
	uniform vec4 V_color[GFX_CHROMA_SAMPLES];
#endif

#ifdef BONE_MATRICES
	//TODO @Timon/Florian this and actually most of these should be refactored to .ogl if/when possible
	//although given how many and common they are, it seems necessary to also extend .ogl handling to allow including files or something
	// (to group common param sets into separate files)
	uniform mat4 M_boneworld[50];		//float4x4 mBone0[50] : BONEWORLD0;
	// TODO: P1 specific stuff
#endif
	
#ifdef VOLUME_POINT
	#define VOLUME_POINT_NUM 32	//ALSO defined in renderframe.cpp
// 	uniform vec4 V_point_pos[VOLUME_POINT_NUM];
	uniform mat4 M_offset[VOLUME_POINT_NUM];
	uniform vec4 V_scale[VOLUME_POINT_NUM];
	uniform int I_index[VOLUME_POINT_NUM];
	#ifndef VOLUME_POINT_FULL
	uniform int I_point_num;
	#endif
#endif
	
};


#ifdef GFX_VULKAN
layout(set = ENUM_BUFFER_MATERIAL, binding = 0, std140) uniform BUFFER_MATERIAL
#else
/*layout(binding = ENUM_BUFFER_EXTRA)*/ uniform BUF_material
#endif
{
#ifdef OCULUS_SHADER
	#define MAX_LAYER_COUNT 8

	vec4 baseColor;
	int baseMaskType;
	vec4 baseMaskParameters;
	vec4 baseMaskAxis;
	vec4 alphaMaskScaleOffset;
	vec4 normalMapScaleOffset;
	vec4 parallaxMapScaleOffset;
	vec4 roughnessMapScaleOffset;

	mat4 projectorInv;

//	bool useAlpha;
//	bool useNormalMap;
//	bool useRoughnessMap;
	bool useProjector;
	float elapsedSeconds;

	int layerCount;

	int layerSamplerModes[MAX_LAYER_COUNT];
	int layerBlendModes[MAX_LAYER_COUNT];
	int layerMaskTypes[MAX_LAYER_COUNT];
	vec4 layerColors[MAX_LAYER_COUNT];
	vec4 layerSurfaceScaleOffsets[MAX_LAYER_COUNT];
	vec4 layerSampleParameters[MAX_LAYER_COUNT];
	vec4 layerMaskParameters[MAX_LAYER_COUNT];
	vec4 layerMaskAxes[MAX_LAYER_COUNT];
	
/*	sampler2D alphaMask;
	sampler2D normalMap;
	sampler2D parallaxMap;
	sampler2D roughnessMap;
	sampler2D layerSurfaces[MAX_LAYER_COUNT];*/
#endif
	DPREDEF_BUFFER_MATERIAL
};

float epsilon = 0.000001f;

//TODO @Timon especially with AA we get NaNs at edges of transparent draws (mostly simple_hdr_out, lightcone) this seems to be mostly due to TO_linearRGB calls
//#define pow(x,y)	pow(max((x),0) + HALF3_SMALL_NUMBER, (y))


#define BGDIST (2000000.0f)
#define BGZ (1.0f / BGDIST)

#define PI (3.141592654f)
#define EUL (2.718281828459f)

#define mul(a,b) ((b) * (a))

vec2 SIGNED(vec2 v)
{
	return (v * 2.0) - 1.0;
}
vec3 SIGNED(vec3 v)
{
	return (v * 2.0) - 1.0;
}
/*
vec4 UNSIGNED(vec4 v)
{
	return (v * 0.5) + 0.5;
*/
vec4 SIGNED(vec4 v)
{
	return (v * 2.0) - 1.0;
}
#define SIGNED_pp SIGNED

float clip2uv(float v)
{
	v += 1;
	v /= 2;
	return v;
}
float uv2clip(float v)
{
	v *= 2;
	v -= 1;
	return v;
}
vec2 clip2uv(vec2 v)
{
	v += vec2(1);
	v /= vec2(2);
	return v;
}
vec2 uv2clip(vec2 v)
{
	v *= vec2(2);
	v -= vec2(1);
	return v;
}
vec3 clip2uv(vec3 v)
{
	v += vec3(1);
	v /= vec3(2);
	return v;
}
vec3 uv2clip(vec3 v)
{
	v *= vec3(2);
	v -= vec3(1);
	return v;
}

vec3 clipZ2uv(vec3 v)
{
	v.xy += vec2(1);
	v.xy /= vec2(2);
	return v;
}
vec3 uv2clipZ(vec3 v)
{
	v.xy *= vec2(2);
	v.xy -= vec2(1);
	return v;
}

vec3 clip2view(vec3 cs)
{
	vec4 p = M_invprojection * vec4(cs, 1);
	return p.xyz / p.w;
}

#ifdef GFX_OGL
	#define DEFAULT_TES_WINDING ccw
#else
	#define DEFAULT_TES_WINDING cw
#endif

/*
Unfortunately there are issues with const:
- glsl < 4.2 has different meaning for const
- amd-vulkan crashes weirdly,	e.g.
	scaleMat(const) is fine
	make_ColorMatrix(any param const) crashes
*/
#define CONST /*const*/
#define _IF if

#define tex2D texture
#define tex1D texture
#define tex2Dproj textureProj
#define tex2Dlod textureLod
#define tex3D texture
#define float2 vec2
#define float3 vec3
#define float4 vec4

#define half float
#define half2 vec2
#define half3 vec3
#define half4 vec4

#define float3x3 mat3
#define float4x4 mat4

float saturate(float v) {
	return clamp(v, 0, 1);
}
float2 saturate(float2 v) {
	return clamp(v, 0, 1);
}
float3 saturate(float3 v) {
	return clamp(v, 0, 1);
}
float4 saturate(float4 v) {
	return clamp(v, 0, 1);
}

float saturate0(float v)	{ return max(v, 0); }
vec2 saturate0(vec2 v)		{ return max(v, 0); }
vec3 saturate0(vec3 v)		{ return max(v, 0); }
vec4 saturate0(vec4 v)		{ return max(v, 0); }

float maxvec(vec2 v)
{
	return max(v.r, v.g);
}
float maxvec(vec3 v)
{
	return max(maxvec(v.rg), v.b);
}
float maxvec(vec4 v)
{
	return max(maxvec(v.rgb), v.a);
}

#define lerp(x,y,s)	mix(x,y,s)
#define frac fract

#define pow2(val) ((val) * (val))
#define dotself(val) dot((val), (val))

#define HALF_SMALL_NUMBER (0.00001)
#define HALF3_SMALL_NUMBER half3(HALF_SMALL_NUMBER, HALF_SMALL_NUMBER, HALF_SMALL_NUMBER)

#define FLOAT_SMALL_NUMBER (0.000000001)

// simple sRGB color conversion with 2.2f NOTE: preserve alpha
half3 TO_sRGB(CONST half3 inColor)
{
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(1.0/2.2)));
}

half4 TO_sRGB(CONST half4 inColor)
{
	return half4(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(1.0/2.2)), inColor.a);
}

half TO_linearRGB(CONST half inColor)
{
	return pow(inColor + HALF_SMALL_NUMBER, 2.2);
}

half3 TO_linearRGB(CONST half3 inColor)
{
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, vec3(2.2)));
}

half4 TO_linearRGB(CONST half4 inColor)
{
	return half4(pow(inColor.rgb + HALF3_SMALL_NUMBER, vec3(2.2)), inColor.a);
}

half3 D3DCOLOR_X_TO_linearRGB_HDR(CONST half4 inColor)
{
	//return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, 2.2) * inColor.a * LIGHTINTENSITY_SCALE);
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(2.2)) );
}

float fresnel(CONST float3 V, CONST float3 N, CONST half Power)
{
	return (pow(1-abs(dot(V, N)), Power));    // note: abs() makes 2-sided materials work
}

//--- Color Correction matrix math ---

float4x4 scaleMat(CONST float s)
{
	return float4x4(
		s, 0, 0, 0,
		0, s, 0, 0,
		0, 0, s, 0,
		0, 0, 0, 1);
}
float4x4 scaleMat(CONST vec3 s)
{
	return float4x4(
		s.x, 0, 0, 0,
		0, s.y, 0, 0,
		0, 0, s.z, 0,
		0, 0, 0, 1);
}

float4x4 translateMat(CONST float3 t)
{
	return float4x4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		t, 1);
}

float4x4 saturationMat(CONST float s)
{ 
	CONST float rwgt = 0.3086;
	CONST float gwgt = 0.6094;
	CONST float bwgt = 0.0820;

	return float4x4(
		(1.0-s)*rwgt + s,	(1.0-s)*rwgt,  		(1.0-s)*rwgt,		0,
		(1.0-s)*gwgt, 		(1.0-s)*gwgt + s, 	(1.0-s)*gwgt,		0,
		(1.0-s)*bwgt,    	(1.0-s)*bwgt, 		(1.0-s)*bwgt + s,	0,
		0.0, 0.0, 0.0, 1.0);
}

float4x4 rotateMat(float3 d, CONST float ang)
{
	float s = sin(ang);
	float c = cos(ang);
	d = normalize(d);
	return float4x4(
		d.x*d.x*(1 - c) + c,		d.x*d.y*(1 - c) - d.z*s,	d.x*d.z*(1 - c) + d.y*s,	0,
		d.x*d.y*(1 - c) + d.z*s,	d.y*d.y*(1 - c) + c,		d.y*d.z*(1 - c) - d.x*s,	0, 
		d.x*d.z*(1 - c) - d.y*s,	d.y*d.z*(1 - c) + d.x*s,	d.z*d.z*(1 - c) + c,		0, 
		0, 0, 0, 1 );
}

mat4x3 make_ColorMatrix(CONST float inBrightness,CONST float inContrast,CONST float inSaturation,CONST float inHue)
{
	// construct color matrix

	// brightness - scale around (0.0, 0.0, 0.0)
	float4x4 brightnessMatrix = scaleMat(inBrightness);

	// contrast - scale around (0.5, 0.5, 0.5)
	float4x4 contrastMatrix = translateMat(vec3(-0.5));
	contrastMatrix = mul(contrastMatrix, scaleMat(inContrast) );
	contrastMatrix = mul(contrastMatrix, translateMat(vec3(0.5)) );

	// saturation
	float4x4 saturationMatrix = saturationMat(inSaturation);

	// hue - rotate around (1, 1, 1)
	float4x4 hueMatrix = rotateMat(float3(1, 1, 1), radians(inHue));

	// composite together matrices
	float4x4 m;
	m = brightnessMatrix;
	m = mul(m, contrastMatrix);
	m = mul(m, saturationMatrix);
	m = mul(m, hueMatrix);

	return mat4x3(m);
}

vec3 GetRGBBox(vec3 ray)
{
	ray = normalize(ray);
	vec3 mag = abs(ray);
	if (mag.r > mag.g && mag.r > mag.b) {
		if (ray.r >= 0)
			return vec3(1, 0, 0);
		else
			return vec3(0, 1, 1);
	}
	if (mag.g > mag.r && mag.g > mag.b) {
		if (ray.g >= 0)
			return vec3(0, 1, 0);
		else
			return vec3(1, 0, 1);
	}
	if (mag.b > mag.r && mag.b > mag.g) {
		if (ray.b >= 0)
			return vec3(0, 0, 1);
		else
			return vec3(1, 1, 0);
	}
	return vec3(0);
}


float random( float2 p )
{
  // We need irrationals for pseudo randomness.
  // Most (all?) known transcendental numbers will (generally) work.
  CONST float2 r = float2(
    23.1406926327792690,  // e^pi (Gelfond's constant)
     2.6651441426902251); // 2^sqrt(2) (Gelfond?Schneider constant)
  return frac( cos( /*f*/mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  //was 256.
}

float square(in float val)
{
	return val*val;
}

bool IsOutsideUV(float uv)
{
	return uv < 0 || uv > 1;
}

bool IsInsideUV(vec2 uv)
{
	return all(greaterThanEqual(uv, vec2(0))) && all(lessThanEqual(uv, vec2(1)));
}
bool IsOutsideUV(vec2 uv)
{
	return any(lessThan(uv, vec2(0))) || any(greaterThan(uv, vec2(1)));
}

vec4 Project(in vec4 val)
{
	val = M_projection * val;
	return val / val.w;
}
vec4 UnProject(in vec4 val)
{
	val = M_invprojection * val;
	return val / val.w;
}

vec3 Project(in vec3 val)
{
	vec4 tmp = M_projection * vec4(val, 1);
	return tmp.xyz / tmp.w;
}
vec3 UnProject(in vec3 val)
{
	vec4 tmp = M_invprojection * vec4(val, 1);
	return tmp.xyz / tmp.w;
}

vec3 view2world(in vec3 val)
{
	return (M_viewinverse * vec4(val, 1)).xyz;
// 	vec4 tmp = M_viewinverse * vec4(val, 1);
//	return tmp.xyz / tmp.w;
}
vec3 view2world_rot(in vec3 val)
{
	return mat3(M_viewinverse) * val;
}

vec3 world2view(in vec3 val)
{
	return (M_view * vec4(val, 1)).xyz;
}
vec3 world2view_rot(in vec3 val)
{
	return mat3(M_view) * val;
}


vec3 pix2volume(ivec3 pix)
{
	return pix / (V_volume_size.xyz - 1);
}
ivec3 volume2pix(vec3 uv)
{
	return ivec3(uv * (V_volume_size.xyz - 1));
}

/*
vec3 proj2volume(vec3 cs)
{
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}
vec3 volume2proj(vec3 uv)
{
	vec3 cs = uv2clipZ(uv);
// 	cs.z = 1 - cs.z;//flip for intuition
// 	cs.z *= 0.5;
// 	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
// 	cs.z = pow(cs.z, 2);
	cs.z *= F_volume_scale;
	cs.z += F_volume_off;
	return cs;
}*/

const float volume_near_scale = 1.0f;
const float volume_dist_scale = 1000.0f;

#define VOLUME_DIST_GODRAYS_LAYERS 1

const float volume_fom_min = 6000.0f;
// const float volume_fom_min = 0.0f;
const float volume_fom_max = 60000.0f;

#ifdef VOLUME_SHAD

#define VOLUME_SHAD_MARGIN /*def or ndef*/
#ifdef VOLUME_SHAD_MARGIN
	const float shvol_margin = 0.01;
#endif

const int shvol_offsets_num = 5;
const float shvol_offsets[shvol_offsets_num] = { 0, 0.63, 0.1, 0.32, 0.85 };

/*vec3 volume2shvol(vec3 uv)
{
	uv.xy += shvol_margin;
	uv.xy /= 1 + 2 * shvol_margin;
	return uv;
}
vec3 shvol2volume(vec3 uv)
{
	uv.xy *= 1 + 2 * shvol_margin;
	uv.xy -= shvol_margin;
	return uv;
}*/

float shvol_zoffset(ivec3 pix, int idx)
{
	if (idx >= 0 /*&& uv.z >= 1.0f / V_volume_size.z/**/) {
// 		idx /= 7;
// 		idx += pix.x + pix.y;
// 		idx += pix.x + int(V_volume_size.x) * pix.y;
// 		idx += pix.y + int(V_volume_size.y) * pix.x;
// 		idx = int(random(vec2(idx)) * shvol_offsets_num);
// 		idx = int(random(vec2(idx) + vec2(pix.xy)) * shvol_offsets_num);
// 		idx = int(random(vec2(idx) / 7 + vec2(pix.xy)) * (shvol_offsets_num - 1));
		idx %= shvol_offsets_num;
		return shvol_offsets[idx] / V_volume_size.z;
	}
	return 0;
}

vec3 volume2shvol(vec3 uv, ivec3 pix, int idx)
{
#ifdef VOLUME_SHAD_MARGIN
	uv.xy += shvol_margin;
	uv.xy /= 1 + 2 * shvol_margin;
#endif
	uv.z += shvol_zoffset(pix, idx);
	return uv;
}
vec3 volume2shvol(vec3 uv, ivec3 pix)
{
	return volume2shvol(uv, pix, U_offset);
}
vec3 volume2shvolPrev(vec3 uv, ivec3 pix)
{
	return volume2shvol(uv, pix, U_offset - 1);
}

vec3 shvol2volume(vec3 uv, ivec3 pix)
{
// 	return uv;
#ifdef VOLUME_SHAD_MARGIN
	uv.xy *= 1 + 2 * shvol_margin;
	uv.xy -= shvol_margin;
#endif
	uv.z -= shvol_zoffset(pix, U_offset);
	return uv;
}
#endif

float view2volume(float z)
{
	z = 0.1f / z; //TODO @Timon camera near-dist
	z -= F_volume_off;
	z /= F_volume_scale;
	z = sqrt(z);
	return z;
}
float volume2view(float z)
{
	z *= z;
	z *= F_volume_scale;
	z += F_volume_off;
	z = 0.1f / z; //TODO @Timon camera near-dist
	return z;
}


vec3 view2volume(vec3 vp)
{
	vec3 cs = Project(vp);
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
	cs.z = sqrt((cs.z));
// 	cs.z = sqrt(abs(cs.z));
// 	cs.z = pow(cs.z, 1.0f/2.0f);
// 	cs.z = pow(cs.z, 1.0f/4.0f);
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}
vec3 volume2view(vec3 uv)
{
	vec3 cs = uv2clipZ(uv);
// 	cs.z = 1 - cs.z;//flip for intuition
// 	cs.z *= 0.5;
	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
// 	cs.z = pow(cs.z, 2.0f);
// 	cs.z = pow(cs.z, 4.0f);
	cs.z *= F_volume_scale;
	cs.z += F_volume_off;
	vec3 view = UnProject(cs);
	return view;
}

vec3 view2volume_linear(vec3 vp)
{
	vec3 cs = Project(vp);
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
	cs.z = sqrt((cs.z));
// 	cs.z = sqrt(abs(cs.z));
// 	cs.z = pow(cs.z, 1.0f/2.0f);
// 	cs.z = pow(cs.z, 1.0f/4.0f);
	
	cs.xy -= cs.xy * vec2(1.0f / V_volume_size.xy);//compensate for difference to between texel addressing and linear texture filtering
	cs.z -= uv2clip(cs.z) * 0.5f / V_volume_size.z;
	
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}

vec3 volume_cellsize(vec3 uv)//TODO @Timon optimize, if needed with a precomputed matrix or something
{
	vec3 v0 = volume2view(uv);
	uv.xy += 1.0f / V_volume_size.xy;
	uv.z -= 1.0f / V_volume_size.z;
	vec3 v1 = volume2view(uv);
	return v1 - v0;
}

float cellsize_fadefactor(vec3 cellsize, float size)
{
// 	float fade = saturate(size * 0.5f - length(cellsize));
	float fade = saturate(size * 0.5f - cellsize.z);
	return fade;
}

float volume_getfadefactor(float viewz, float size)
{
/*	z = 0.1f / z; //TODO @Timon camera near-dist
	z -= F_volume_off;
	z /= F_volume_scale;
	z = sqrt(z);
	
	z -= 1.0f / V_volume_size.z;
	
	z *= z;
	z *= F_volume_scale;
	z += F_volume_off;
	z = 0.1f / z; //TODO @Timon camera near-dist
	/**/
// 	return 0.0;
	float n = 800 * size / 200;
	float f = 1400 * size / 200;
	n = min(n, V_volume_range[1] - min(size, V_volume_range[1] / 4));
	f = min(f, V_volume_range[1]);
	return smoothstep(n, f, viewz);
	
// 	float step = V_volume_range[1] - V_volume_range[0];
// 	step /= V_volume_size.z;
// 	float far = size;
// 	return smoothstep(, viewz);
/*	float volz = view2volume(viewz);
	volz -= 1.0f / V_volume_size.z;
	float nviewz = volume2view(volz);
	
	float dist = 0.1 / (0.1 / viewz + F_volume_scale / pow2(V_volume_size.z));	return saturate(size * 0.5 - abs(dist));
	
	return saturate(size * 0.5 - abs(nviewz - viewz));/**/
// 	return fade;
}

//-------------------------------------------------------------------------------
// Lighting/Shadow defines ( used in vertex + pixel shaders )
//-------------------------------------------------------------------------------

#define USE_TEXTURE_LIGHTING /**/
#define DEF_LIGHT_AMBIENT(_NR) /**/
#define DEF_LIGHT_DIR(_NR) /**/

#define B_material_override false
#define B_globallight_tonemap true
#define V_matparams vec4(0.5f)
#define V_deferred_lightparams vec4(1)
#define F_arealightcutoff 0.001f

#ifdef PROJECT_XR
	#define XR_TO_linearRGB(val)	TO_linearRGB(val)
#else
	#define XR_TO_linearRGB(val)	(val)
#endif



////////////////// JON MOD SETTINGS START //////////////////
//Included in common.h, that is included most anywhere

//#define JON_MOD_SPECULAR_OVERSHOOT_FIX //default on, fixes geometric light white bright artefact
#define JON_MOD_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE //default on

#define JON_MOD_ROUGHNESS_REMAP // default on. Old Pixar trick, since artists has a tendency to overuse the lower end of the roughness and neglect the high end, this one does a gentle remap improving both!
#define JON_MOD_ROUGHNESS_REMAP_PRE_SQUARE_RANGE 0.5//default 0.5

//#define JON_MOD_ENFORCE_STRICT_METALLIC
//#define JON_MOD_ENFORCE_PBR_INPUT_COLORS		//will follow the loose PBR guidlines
//#define JON_MOD_ENFORCE_PBR_INPUT_COLORS_STRICT //will endorce the strict PBR guidlines


// Human skin lowest index of refraction(IOR)1.35 = 0.28 in unreal specular, or #47, rgb71, 28%brightness, as linear color
// Human skin highest index of refraction(IOR)1.55 = 0.58 in unreal specular, or #94, rgb148, 58%brightness, as linear color
// Human hair(and nails technically too) highest index of refraction(IOR)1.55 = 0.58 in unreal specular, or #94, rgb148,
// Specular scale is 0.08, so (0.28 * 0.08), etc...
#define JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
#define JON_MOD_SUBSURFACE_SUBDERMAL_ROUGHNESS 0.5
#define JON_MOD_SUBSURFACE_EPIDERMAL_ROUGHNESS -0.1
#define JON_MOD_SUBSURFACE_EPIDERMAL_F0 0.0224f

#define JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL//This upgrades EvalBRDF() to include this https://advances.realtimerendering.com/s2018/MaterialAdvancesInWWII-course_notes.pdf Which UE5 also uses.

#define JON_MOD_USE_LUMINANCE_FRESNEL

#define JON_MOD_USE_ROUGHNESS_SQRT_PROBE_ROUGHNESS //un-fuck-up-ing it

#define JON_MOD_SSSHADOWS //default on
#define JON_MOD_SSSHADOWS_SUPPORT_BOTH_PRIMARY_LIGHTS //default on
#define JON_MOD_SSSHADOWS_MAX_STEPS 32 //default 64, it's pretty rare to ever go this high be aware this is a times 2

#define JON_MOD_SSSHADOWS_FADE_DISTANCE 5000.0 //not all PCF shadows have the same distance, so some lods will still shadow pop if we just use that, so with this we can enforce a max distance where everything will use Screenspace Shadows
#define JON_MOD_SSSHADOWS_DITHER 2.0 //default 1

#define JON_MOD_SSSHADOWS_RAY_MAX_DISTANCE 240.0 //default 240.0 = 24.0m distance. I think 1 is about 10cm, so a hundred meters is 10000
#define JON_MOD_SSSHADOWS_BIAS 1.0 //default 10.0 = 1.0m
#define JON_MOD_SSSHADOWS_MAX_THICKNESS 1000.0 //default 1000.0 = 100.0m shadows thicker than this from the camera are ignored, so as to things near ain't casting shadows on things far

#define JON_MOD_SSSHADOWS_RAY_MAX_DISTANCE_NEAR 0.25 //default 10cm
#define JON_MOD_SSSHADOWS_BIAS_NEAR 0.05 //0.1cm
#define JON_MOD_SSSHADOWS_MAX_THICKNESS_NEAR 0.1 //1cm
#define JON_MOD_SSSHADOWS_FADE_DISTANCE_NEAR 10.0 //not all PCF shadows have the same distance, so some lods will still shadow pop if we just use that, so with this we can enforce a max distance where everything will use Screenspace Shadows
#define JON_MOD_SSSHADOWS_ATTENUATION_NEAR 1.0
#define JON_MOD_SSSHADO_FILTER // filters with screenspace derivatives, might give very different result at different resolution

#define JON_MOD_SSSHADOWS_POINTLIGHTS

//debugs
//#define JON_MOD_SSSHADOWS_DEBUG_MODE
//#define JON_MOD_SSSHADOWS_LIGHT_TO_DEBUG 0 //options are 0 or 1 only!

//#define JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN

#define INVPI 	(0.318309886f)
//nice angle corrected blend
vec3 BlendReorientedNormals(vec3 n1, vec3 n2)
{

	n1 = vec3(n1.xy, n1.z + 1.0);
	n2 = vec3(-n2.xy, n2.z);

    return normalize(n1 * dot(n1, n2) - n2 * n1.z);
}
////////////////// JON MOD SETTINGS END //////////////////