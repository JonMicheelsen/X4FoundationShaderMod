#include <common.h>
#include <ssr_common.h>

#ifdef OUT_R8_UINT
layout(location = 0) out uint OUT_UINT;
#elif defined(OUT_ENVMAP)
layout(location = 0) out vec4 OUT_Color;
layout(location = 1) out vec4 OUT_Color1;
layout(location = 2) out vec4 OUT_Color2;
layout(location = 3) out vec4 OUT_Color3;
layout(location = 4) out vec4 OUT_Color4;
layout(location = 5) out vec4 OUT_Color5;
#elif defined(OUT_1)
layout(location = 0) out vec4 OUT_Color;
#else
layout(location = 0) out vec4 OUT_Color;
layout(location = 1) out vec4 OUT_Color1;
layout(location = 2) out vec4 OUT_Color2;
layout(location = 3) out vec4 OUT_Color3;
#endif


#define DIR in
#include <vertex.h>
#undef DIR

#ifdef GFX_RT_DEBUG
void DebugStore(vec4 col)
{
	imageStore(T_debug, ivec2(gl_FragCoord.xy), col);
}
void DebugStore(vec3 col)
{
	DebugStore(vec4(col, 1));
}

void DebugStore(float val, float alpha)
{
	DebugStore(vec4(-val, val, 0, alpha));
}
void DebugStore(float val)
{
	DebugStore(val, 1);
}
#endif

#define LOCALSPEC

float Luminance()
{
#ifdef PROJECT_XR
	return 0.6f;
#else
	return 1.0f;
#endif
//	return textureLod(T_luminance, vec2(0, 0), 0).x;
}

float LuminanceLast()
{
	return Luminance();
//	return textureLod(T_luminance_last, vec2(0, 0), 0).x;
}

#ifdef GFX_VULKAN
layout(constant_id = 0) const bool B_alpha_test = false;
layout(constant_id = 1) const float F_alpha_ref = 0.5f;
#else
uniform float F_alpha_ref = 0.0f;	//for alpha-testing
#endif

void StandardControlTexture()
{
#ifdef SHADERTAG_CT
	if (texture(S_input_rt, IO_uv0).r < 0.5f) {
		discard;
	}
#endif
}

void AlphaTest(float a)
{
	if (B_alpha_test)
	{
		if (a < F_alpha_ref) {
			discard;
		}
	}/**/
}

void AlwaysAlphaTestWithCoverage(inout float a, float ref)
{
	if (a < ref) {
		discard;
	}
	a = (a - ref) / max(abs(dFdx(a)) + abs(dFdy(a)), FLOAT_SMALL_NUMBER) + 0.5;
}
void AlphaTestWithCoverage(inout float a)
{
	if (B_alpha_test)
	{
		AlwaysAlphaTestWithCoverage(a, F_alpha_ref);
	}
}

#if 0//don't use this it crashes on intel gpus
void Alpha2DepthScale(float a)// when using this preferrably add "layout (depth_less) out float gl_FragDepth;" before include "common.fh"
{
	gl_FragDepth = gl_FragCoord.z * sqrt(saturate(a));
}
#endif

#ifdef D_OBJECT_RENDER_MODE
	#define OBJECTRENDERMODE_SOLID()		\
		{			\
			if (B_alpha_test) {				\
				if (OUT_Color.a >= F_alpha_ref) {	\
					OUT_Color.a = 1.0f;			\
				}			\
			}			\
			else {			\
				OUT_Color.a = 1.0f;		\
			}			\
		}
#else
	#define OBJECTRENDERMODE_SOLID() /* OBJECTRENDERMODE_SOLID() */
#endif


/*void OrthogonalNTB(out vec3 n, out vec3 t, out vec3 b)
{
	n = normalize(IO_normal);//TODO @Timon referencing IO_normal from a function breaks vr_oculus_avatar_pbs naturally
	t = IO_tangent;
	b = IO_binormal;
	t = normalize(t - n * dot(n, t));
	b = normalize(b - n * dot(n, b));
	b = normalize(b - t * dot(t, b));
}*/

#define INPUT_NTB_ONESIDED()			\
	vec3 IO_normal, IO_tangent, IO_binormal;			\
	IO_normal = normalize(_IO_normal);			\
	IO_tangent = normalize(_IO_tangent);			\
	IO_binormal = normalize(_IO_binormal);

#define INPUT_NTB_TWOSIDED()			\
	vec3 IO_normal, IO_tangent, IO_binormal;			\
	IO_normal = normalize(_IO_normal);			\
	IO_tangent = normalize(_IO_tangent);			\
	IO_binormal = normalize(_IO_binormal);		\
	if (gl_FrontFacing) {				\
		IO_normal = -IO_normal;			\
	}

#define CalcWorldNormal(texnormal)	normalize( ((texnormal).x * -IO_tangent) + ((texnormal).y * IO_binormal) + ((texnormal).z * IO_normal) )

#define CalcViewNormalOffset(texnormal)	((mat3(M_view) * ((texnormal).x * -IO_tangent + (texnormal).y * IO_binormal)).xy)

float3 UncompressDXT5_NM(float4 normPacked)
{
	float3 norm = float3(normPacked.a * 2.0 - 1.0, normPacked.g * 2.0 - 1.0, 0.0);
	norm.z = sqrt(1.0 - norm.x * norm.x - norm.y * norm.y);
	return norm;
}

//TODO @Timon further dedup the various variants
vec3 NormalReZ(vec3 texnormal)
{
	texnormal.z = sqrt(1 - saturate(dotself(texnormal.xy)));	//without saturate we'd get NaNs in some textures
	return texnormal;
}

vec2 textureNormalXY(sampler2D samp, vec2 uv)
{
	return SIGNED(texture(samp, uv).xy);
}
vec2 textureNormalXY(sampler2D samp, vec2 uv, float str)
{
	return SIGNED(texture(samp, uv).xy) * str;
}

vec3 textureNormalXYZ(sampler2D samp, vec2 uv)
{
	vec3 ret;
	ret = SIGNED(texture(samp, uv).xyz);
	return ret;
}
vec3 textureNormalXYZ(sampler2D samp, vec2 uv, float str)
{
	vec3 ret;
	ret = SIGNED(texture(samp, uv).xyz);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2D samp, vec2 uv)
{
	vec3 ret;
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2D samp, vec2 uv, float str)
{
	vec3 ret;
#if 0
	// experimental jitter for TAA
	float t = fract(F_time * 10);
	vec2 off = vec2(random(t * gl_FragCoord.xy), random(t * gl_FragCoord.yx));
	// DebugStore(vec3(off, 0));
	off = uv2clip(off);
	off *= 0.5 / textureSize(samp, 0).xy;
//	uv += off;
#endif
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}
vec3 textureNormalXYreZ(sampler2DArray samp, vec3 uv, float str)
{
	vec3 ret;
	ret.xy = SIGNED(texture(samp, uv).xy);
	ret = NormalReZ(ret);
	ret.xy *= str;
// 	ret = normalize(ret);
	return ret;
}

vec3 textureNormal(sampler2D samp, vec2 uv, float str)
{
	return textureNormalXYreZ(samp, uv, str);
}
vec3 textureNormal(sampler2DArray samp, vec3 uv, float str)
{
	return textureNormalXYreZ(samp, uv, str);
}
vec3 textureNormal(sampler2D samp, vec2 uv)
{
	return textureNormalXYreZ(samp, uv);
}

#define TEXTURE_NORMAL(name0, uv0)		textureNormal(S_##name0##_map, (uv0) * S_##name0##_tiling, S_##name0##str)
#define TEXTURE_NORMAL_XY(name0, uv0)	textureNormalXY(S_##name0##_map, (uv0) * S_##name0##_tiling, S_##name0##str)


#define SAMPLE_NORMAL_MAP(out, name0, uv0)			\
	{			\
		(out) = IO_normal;			\
		_IF(S_##name0##_bool) {			\
			vec3 texnorm = TEXTURE_NORMAL(name0, (uv0));			\
			(out) = CalcWorldNormal(texnorm);			\
		}			\
	}

#define SAMPLE_NORMAL_MAP2(out, name0, uv0, name1, uv1)			\
	{			\
		(out) = IO_normal;			\
		_IF(S_##name0##_bool) {			\
			vec3 texnorm = TEXTURE_NORMAL(name0, (uv0));			\
			_IF(S_##name1##_bool) {			\
				texnorm.xy += TEXTURE_NORMAL_XY(name1, (uv1));			\
			}			\
			texnorm = normalize(texnorm);				\
			(out) = CalcWorldNormal(texnorm);			\
		}			\
	}

#define STANDARD_NORMAL_MAP(out)			SAMPLE_NORMAL_MAP(out, normal, IO_uv0)
#define STANDARD_NORMAL_DETAIL_MAP(out)		SAMPLE_NORMAL_MAP2(out, normal, IO_uv0, normal_detail, IO_uv0)
#define STANDARD_NORMAL_NOISE_MAP(out)		SAMPLE_NORMAL_MAP2(out, normal, IO_uv0, normal_noise, IO_uv0)

#define STANDARD_NORMAL_DETAIL_MAPUV(out,uv)		SAMPLE_NORMAL_MAP2(out, normal, uv, normal_detail, uv)

vec3 calcWorldNormal(vec3 TexNormal, vec3 Norm, vec3 Tang, vec3 BiNo)
{
	return normalize(TexNormal.x * normalize(-Tang) + TexNormal.y * normalize(BiNo) + TexNormal.z * normalize(Norm));
}

float3 calcWorldNormal2(CONST float3 TexNormal, CONST float3 Norm, CONST float3 Tang, CONST float3 BiNo)
{
	return calcWorldNormal(TexNormal, Norm, Tang, BiNo);
}

half CalcNewViewAngleFading(CONST float3 normalWV, CONST float3 posWV, CONST half AnglePower)
{
	return lerp(0.0, 1.0, saturate((abs(dot(normalWV, normalize(posWV))) - AnglePower)));
}


vec2 GetFragUV()
{
	return gl_FragCoord.xy / V_viewportpixelsize.xy;
}

vec3 GetFragUVZ()
{
	return vec3(GetFragUV(), gl_FragCoord.z);
}

vec3 GetFragClip()
{
	return uv2clipZ(GetFragUVZ());
}

vec3 GetFragView()
{
	return UnProject(GetFragClip());
}

vec3 GetFragViewDir()
{
	return normalize(GetFragView());
}

vec3 GetFragWorld()
{
	return view2world(GetFragView());
}

vec3 GetCheckers(int size)
{
	uvec2 pix = uvec2(gl_FragCoord.xy) / size;
	if (((pix.x + pix.y) & 1) != 0)
		return vec3(0.2);
	return vec3(0.4);
}
vec3 GetCheckers()
{
	return GetCheckers(16);
}

half4 RTResolve(sampler2D samp)
{
	return texelFetch(samp, ivec2(gl_FragCoord.xy), 0);	//TODO should be better, but need to test perf/compat
	
//	float2 uv = float2(inVPos.xy / ViewPort.xy); // use ps3 inputs and set LOD to 0
	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / V_viewportpixelsize.xy;
//	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / textureSize(samp, 0);
//	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / vec2(1024, 768);
	
	//CONST half localoccl = pow(Occl, 1.0/4.0); // scale power up, allow locallight to ignore occl to some degree, but if its very dark still scale down more.
//	return vec4(textureLod(samp, uv, 0).rgb, 0.8f);
//	return textureLod(samp, uv, 0).rgba * vec4(1, 1, 1, 0.5f); 
	return textureLod(samp, uv, 0);
}
half4 RTResolve(sampler2D samp, vec2 uv)
{
#ifndef VIEWPORT_HACK2
	#ifdef UPMODE_FSR
		//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
		#ifdef VIEWPORT_HALF_RES_FSR_HACK
		uv *= 2;
		#endif
		uv *= V_viewportpixelsize.xy / textureSize(samp, 0);
	#endif
#endif
	return textureLod(samp, uv, 0);
}
half4 RTResolveSoft(sampler2D samp)
{
	float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / V_viewportpixelsize.xy;
	//float2 uv = (gl_FragCoord.xy/* + half2(0.5f, 0.5f)*/) / textureSize(samp, 0);
	return textureLod(samp, uv, 0);
}
half4 RTResolveSample(sampler2D samp, int idx)
{
	return RTResolve(samp);
}

half4 RTResolve(sampler2DMS samp)
{
#ifdef PER_SAMPLE
	vec4 col = texelFetch(samp, ivec2(gl_FragCoord.xy), gl_SampleID);
#elif defined(MAIN_MSAA)
	vec4 col = texelFetch(samp, ivec2(gl_FragCoord.xy), 0);
/*	for (int i = 1; i < MAIN_MSAA; ++i) {
		col += texelFetch(samp, ivec2(gl_FragCoord.xy), i);
	}
	/**/
/*	#if MAIN_MSAA > 1
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 1);
	#elif MAIN_MSAA > 2
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 2);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 3);
	#elif MAIN_MSAA > 4
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 4);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 5);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 6);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 7);
	#elif MAIN_MSAA > 8
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 8);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 9);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 10);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 11);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 12);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 13);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 14);
	col += texelFetch(samp, ivec2(gl_FragCoord.xy), 15);
	#else
	#error weird MAIN_MSAA
	#endif
	/**/
// 	col /= vec4(MAIN_MSAA);
//	col = vec4(1, 0, 1, 1);
#else
	vec4 col = vec4(1, 0, 1, 1);
#endif
	return col;
}
half4 RTResolve(sampler2DMS samp, vec2 uv)
{
#ifndef VIEWPORT_HACK2
	#ifdef UPMODE_FSR
		//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
		uv *= V_viewportpixelsize.xy / textureSize(samp);
		#ifdef VIEWPORT_HALF_RES_FSR_HACK
		uv *= 2;
		#endif
	#endif
#endif
// 	uv *= V_viewportpixelsize.xy;
	uv *= textureSize(samp).xy;
#ifdef PER_SAMPLE
	return texelFetch(samp, ivec2(uv), gl_SampleID);
#else
	return texelFetch(samp, ivec2(uv), 0);
#endif
}
half4 RTResolveSample(sampler2DMS samp, int idx)
{
	return texelFetch(samp, ivec2(gl_FragCoord.xy), idx);
}

#define FLAG_COMPLEX_DEPTH (1 << 7)
#define FLAG_COMPLEX_NORMAL (1 << 6)
#define FLAG_STATIONARY (1 << 5)
#define FLAG_BACKGROUND (1 << 4)
#define FLAG_COMPLEX (FLAG_COMPLEX_DEPTH | FLAG_COMPLEX_NORMAL)

bool IsComplex(uint flags)
{
	return (flags & FLAG_COMPLEX) != 0;
}
bool IsComplexDepth(uint flags)
{
	return (flags & FLAG_COMPLEX_DEPTH) != 0;
}
bool IsStationary(uint flags)
{
	return (flags & FLAG_STATIONARY) != 0;
}


uint GetFlags()
{
	return texelFetch(T_flags, ivec2(gl_FragCoord.xy), 0).r;
}
uint GetFlagsLevel1()
{
	return texelFetch(T_flags, ivec2(gl_FragCoord.xy) >> 1, 1).r;
}

uint GetFlags(vec2 uv)
{
#ifdef UPMODE_FSR
	//with FSR the true resolution of depth can differ or be the same as the color RTs, hackishly compensate for that
	#ifdef VIEWPORT_HALF_RES_FSR_HACK
	#endif
	uv *= V_viewportpixelsize.xy / textureSize(T_flags, 0);
#endif
	return textureLod(T_flags, uv, 0).r;
}


//offset has to be a constant/literal, AMD is more anal about this! they check before optimizations
#define RTResolveOffset(samp,offset)	texelFetchOffset(samp, ivec2(gl_FragCoord.xy), 0, offset)


float GetDepth()
{
#ifdef OVERRIDE_DEPTH
	return RTResolve(OVERRIDE_DEPTH).r;
#else
	return RTResolve(T_zdepth).r;
#endif
}
float GetDepth(vec2 uv)
{
#ifdef OVERRIDE_DEPTH
	return RTResolve(OVERRIDE_DEPTH, uv).r;
#else
	return RTResolve(T_zdepth, uv).r;
#endif
}

vec3 GetUVPos()
{
	return vec3(GetFragUV(), GetDepth());
}
vec3 GetUVPos(vec2 uv)
{
	return vec3(uv, GetDepth(uv));
}

vec3 GetClipPos()
{
	return uv2clipZ(GetUVPos());
}
vec3 GetClipPos(vec2 uv)
{
	return uv2clipZ(GetUVPos(uv));
}

vec3 GetViewPos()
{
	return UnProject(GetClipPos());
}
vec3 GetViewPos(vec2 uv)
{
	return UnProject(GetClipPos(uv));
}

half Brightness(half3 c)
{
    return max(max(c.r, c.g), c.b);
}

#define LUM_ITU601 half3(0.299, 0.587, 0.114)

// avoid clutter
#include <p1/deferred/lighting_common.h>
#include <p1/deferred/gbuffer_access.h>

half lluma(vec3 c)
{
	return dot(c, vec3(0.2126, 0.7152, 0.0722));
}
half luminance(CONST half3 c)
{
	return dot( c, LUM_ITU601 );
}

float blendScreen(CONST float A, CONST float B)
{
	return (1 - (1 - A) * (1 - B));
}
half3 blendScreen(CONST half3 A, CONST half3 B)
{
	return (1 - (1 - A) * (1 - B));
}

float blendAvg(CONST float A, CONST float B)
{
 	return ((A + B) / 2);
}

half3 blendAvg(CONST half3 A, CONST half3 B)
{
 	return ((A + B) / 2);
}

half3 blendAdd(CONST half3 A, CONST half3 B)
{
 	return (A + B);
}

half3 blendMix(CONST half3 A, const half3 B, const half fac)
{
	return A+(B-A)*fac;
}

half blendMix(CONST half A, const half B, const half fac)
{
	return A+(B-A)*fac;
}

float blendMultiply(CONST float A, CONST float B)
{
 	return (A * B);
}

float blendMultiply(CONST float A, CONST float B, CONST float fac)
{
	return ((1-fac) * A + fac * A * B);
}

half3 blendMultiply(CONST half3 A, CONST half3 B)
{
 	return (A * B);
}

half3 blendAlpha(CONST half3 A, CONST half3 B, CONST half alpha)
{
 	//return ( (A * alpha) +  (B * (1 - alpha)) );
 	return lerp(A, B, saturate(alpha));
}
float4 blendAlphaF(float4 A, float4 B)
{
	return float4((A.rgb * A.a) + (B.rgb * (1.0f - A.a)), min(A.a + B.a, 1.0f));
}


float blendOverlay(CONST float A, CONST float B)
{
	half L = saturate(10 * (A - 0.45));
	float result1 = 2.0 * A * B;
	float result2 = 1.0 - 2.0 * (1.0 - B) * (1.0 - A);
	return lerp(result1, result2, L);
}

half3 blendOverlay(CONST half3 A, CONST half3 B)
{
	//half3 lumCoeff = half3(0.25,0.65,0.1);
	//half L = min(1,max(0,10*(dot(lumCoeff,A)- 0.45)));
	half L = saturate(10 * (luminance(A) - 0.45));
	half3 result1 = 2.0 * A * B;
	half3 result2 = 1.0 - 2.0 * (1.0 - B) * (1.0 - A);
	return lerp(result1, result2, L);
}
 
half3 blendClimate(CONST half3 A, CONST half3 B)
{
	if (A.r>0.99 && A.g>0.99 && A.b>0.99)
	{
		return half3(1.0,1.0,1.0);
	}else
	return A*B + ((A + B)/4.0 );
}

half3 blendOverlayHDR2(CONST half3 A, CONST half3 B, CONST half strength)
{
//float3 multiplyResults = base * blend;  
//float3 screenResults = 1 - (1 - base) * (1 - blend);  
//float3 t = max(0, sign(base - 0.5));  
//float3 finalColor = 2 * lerp(multiplyResults, screenResults, t); 
	half3 multiplyResults = A*B;//	base * blend;  
	half3 screenResults = half3(4) - (half3(4) - A) * (half3(1) - B);  
	half3 t = max(half3(0), sign(A - half3(10)));  
	//return (A+B+ 8*lerp(multiplyResults, screenResults, t)); 
	//return (A+strength*screenResults+ strength*20 * multiplyResults ); //the one
	return (A+strength*B);//+ strength*20 * multiplyResults ); 
	//return screenResults; 
}




float fresnel_a(float x)
{
	return ((( 1.0f/(pow(abs(x-1.12f),2))) - (1.0f/pow(1.12f,2))) / 68.652f);// (( 1/pow(1.0f-1.12f,2)) - (1/pow(1.12f,2)));
}

float fresnel(CONST float3 V, CONST float3 N, CONST half Power, CONST half Str, CONST half minRange)
{
	//TODO @Timon investigate the exact source of the NaN on the glass floor in the Thresher
//	float fresnel = pow(1-abs(dot(V, N)), Power) * Str;    // note: abs() makes 2-sided materials work
    float fresnel = pow(saturate(1-abs(dot(V, N))), Power) * Str;    // note: abs() makes 2-sided materials work
    float result = minRange + (1-minRange) * fresnel;
    return result;
}

float shadow(float x)
{
	//return ((10000.0f - (1.0f/(pow(abs(x-1.01f),2)))) / 9999.2f);//(( 1/pow(1.0f-1.01f,2)) - (1/pow(1.01f,2)));
	return ((10000.0f - (1.0f/(pow((x-1.01f),2)))) / 9999.2f);//(( 1/pow(1.0f-1.01f,2)) - (1/pow(1.01f,2)));
}

float SoftParticleAttenuation(float softmin, float softmax, float z)
{
	float delta = z - softmin;
	float range = softmax - softmin;
	return saturate(delta / (range + 0.00001)); // prevent division by zero
}

vec3 Tonemap(vec3 color)
{
	color *= half3(F_exposure / (Luminance() + 0.001f));
	color /= half3(1.0f + color);
	return color;
}
vec3 InvTonemap(vec3 color)
{
	color *= half3(Luminance() / F_exposure);
	return color;
}

mat2x3 calc_Light_Hair_PS(float3 DiffColor, float3 VertexToLight, float3 VertexToEye, float3 Normal, float3 Tangent, half SpecPower, half3 LightColor)
{
	mat2x3 Light = mat2x3(0); //(half2x3)0; // 698
	float3 Diff;
	float3 Spec;
	float3 HalfAngle = normalize(VertexToEye + VertexToLight);
	float NdL = dot(Normal, VertexToLight);
	Diff = float3(max(0.0, 0.75 * NdL + 0.25));

	float3 T1 = normalize(Tangent - 0.2 * Normal);
	float3 T2 = normalize(Tangent + 0.1 * Normal);
	
	float3 T1dH = float3(dot(T1, HalfAngle));
	float3 T2dH = float3(dot(T2, HalfAngle));
	
	float3 colorkey = DiffColor / luminance(DiffColor);
	Spec = pow(float3(1) - T1dH * T1dH, float3(0.5 * SpecPower * 0.2)) * (float3(0.5) + float3(0.5) * colorkey);
	Spec += pow(float3(1) - T2dH * T2dH, float3(0.5 * SpecPower)) * (float3(0.9) + float3(0.1) * colorkey);
	Spec *= saturate(3.0 * saturate(NdL) ); //Shadow term
	
	Light[0].rgb = Diff * LightColor.rgb;
	Light[1].rgb = Spec * LightColor.rgb;
	return Light;
}

//rescaled lambert
float lambert_half(CONST float NdL, CONST half lambertpower)
{
	return (pow( (NdL * 0.5) + 0.5, lambertpower));
}

half2 calc_LambertHalf_Phong(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;

	float3 R = reflect(-L, N);
	half NdL = dot(N, L);
		
	Light.x = lambert_half(NdL, Power.y);		// Diffuse (half lambert/scaled up)
	Light.y = pow(saturate(dot(R, V)) + HALF_SMALL_NUMBER, Power.x);	// Phong (half precission)
	Light.y *= saturate(3.0 * saturate(NdL)); 	// Shadow term
	
   	return Light;
}

half2 calc_LambertHalf_Blinn(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;
	
	CONST float3 H = normalize(V + L);
	CONST half NdL = dot(N, L);
	
	Light.x = lambert_half(NdL, Power.y);
	Light.y = pow(saturate(dot(N, H)), Power.x);//Specular
	Light.y *= saturate(3.0 * saturate(NdL)); //Shadow term
	
	return Light;
}

half2 calc_Lambert_Phong(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;

	CONST float3 R = reflect(-L, N); 	
	CONST half NdL = dot(N, L);
		
	Light.x = saturate(NdL);		// Diffuse
	Light.y = pow(saturate(dot(R, V)), Power.x);	// Phong (half precission)
	Light.y *= saturate(3.0 * Light.x); 	// Shadow term
	
   	return Light;
}

half2 calc_Lambert_Blinn(CONST float3 N, CONST float3 L, CONST half3 V, CONST half2 Power)
{
	half2 Light;
	
	CONST float3 H = normalize(V + L); // NOTE: we need float here, but this triggers the flow control bug...???
	CONST half NdL = dot(N, L);
	
	Light.x = saturate(NdL); 		//Diffuse
	Light.y = pow(saturate(dot(N, H)), Power.x);//Specular
	Light.y *= saturate(3.0 * Light.x); //Shadow term
	
	return Light;
}

half3 calc_StraussNew(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float _smooth, 
					CONST float metal,
					CONST float diffusestr,
					CONST float specularstr,
					CONST float specfunc,
					CONST half3 lightcolor,
					CONST half3 diffusecolor,
					CONST half3 F0)
{
//	return specularstr *= 0.001;
	  // Make sure the interpolated inputs and
    // constant parameters are normalized
	half3 diffuse;
	
   //  float3 nn = normalize( N );
   //  float3 ln = normalize( L );
   //  float3 vn = normalize( V );
 
	
	float3 h = reflect( -L, N );
 
	    
    // Declare any aliases:
    float NdotL   = (dot( N, L ));
	
	float NdotV   = (dot( N, V ));
    float HdotV   = (dot( h, V ));
    float fNdotL  = fresnel_a( NdotL ); //((( 1.0f/(pow(abs(NdotL-1.12f),2)+0.01f)) - 0.797f) / 68.652f);
    float s_cubed = _smooth * _smooth * _smooth;
	//float s_cubed = _smooth * _smooth ;
		
	float fTransparency = 0.0f;
	
    // Evaluate the diffuse term
    float d  = ( 1.0f - metal * _smooth );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	
	
	diffuse = NdotL * d * Rd * diffusecolor;
   // Compute the inputs into the specular term
    float r = ( 1.0f - fTransparency ) - Rd;
 
	
    float j = fNdotL;// * shadow( NdotL ) * shadow( NdotV );
 
 

    // 'k' is used to provide small off-specular
    // peak for very rough surfaces. Can be changed
    // to suit desired results...
 /*   float k = 0.0f;//was 0.1
    float reflect = min( 1.0f, r + j * ( r + k ) );
 
    float3 C1 = float3( 1.0f, 1.0f, 1.0f );
    float3 Cs = C1 + metal * (1.0f - fNdotL) * (diffusecolor - C1);
 
 	half specatten = saturate(3.0 * saturate(NdotL));*/
	//half specatten = saturate(NdotL);

	

    // Evaluate the specular term
    
	//half3 specular = Cs* reflect*specatten;
    //specular *= pow( -HdotV, 3.0f / ((1.0f - smooth)) ); //(0.000000134123f + (1.0f - smooth))
	
	//specular = C1 * pow(saturate(HdotV), 32.0f);

	CONST float3 H2 = normalize(V + L);
	half3 specular = half3(pow(saturate(dot(N,H2)), 60.0f));
	//specular = float3(0.0f,0.0f,0.0f);

    // Composite the final result, ensuring
    // the values are >= 0.0f yields better results. Some
    // combinations of inputs generate negative values which
    // looks wrong when rendered...
    diffuse  = max( half3(0.0f), diffusestr*diffuse*lightcolor.rgb );
    specular = max( half3(0.0f), specularstr*specular*lightcolor.rgb * diffusecolor.rgb );
	//new : additive/multiply mix

	CONST half3 addSpecular = specfunc*specular;
	CONST half3 mulSpecular = (1.0 - specfunc)*specular;
	diffuse = (diffuse + addSpecular) + (diffuse*mulSpecular);
//	diffuse *= 0.00001;
	
	//old style aditive only
//	diffuse += specular/1.0; //diffuse += diffuse*specular;
//	diffuse += specular;
//	diffuse = half3(specularstr) / 100;
//	diffuse += V / 10;
//	diffuse += L / 100;
//	diffuse += V + L;
//	diffuse += N / 100;
//	diffuse += H2 / 100;
//	diffuse += half3(NdotL, NdotV, HdotV) / 100.0;
//	diffuse += half3(saturate(dot(N,H2)) / 50.0);
//	diffuse += half3(pow(saturate(dot(N,H2)), 60.0f));
	
    return diffuse;
}

half3 calc_StraussNew2(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float _smooth, 
					CONST float metal,
					CONST float diffusestr,
					CONST float specularstr,
					CONST float specfunc,
					CONST half3 lightcolor,
					CONST half3 diffusecolor,
					CONST half3 F0,
					CONST half3 specularcolor)
{
	  // Make sure the interpolated inputs and
    // constant parameters are normalized
	half3 diffuse;
	
   //  float3 nn = normalize( N );
   //  float3 ln = normalize( L );
   //  float3 vn = normalize( V );
     float3 h = reflect( -L, N );
 
	    
    // Declare any aliases:
    float NdotL   = (dot( N, L ));
	
	float NdotV   = (dot( N, V ));
    float HdotV   = (dot( h, V ));
    float fNdotL  = fresnel_a( NdotL ); //((( 1.0f/(pow(abs(NdotL-1.12f),2)+0.01f)) - 0.797f) / 68.652f);
    float s_cubed = _smooth * _smooth * _smooth;
	//float s_cubed = smooth * smooth ;
		
	float fTransparency = 0.0f;
	
    // Evaluate the diffuse term
    float d  = ( 1.0f - metal * _smooth );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	
	
	diffuse = NdotL * d * Rd * diffusecolor;
   // Compute the inputs into the specular term
    float r = ( 1.0f - fTransparency ) - Rd;
 
	
    float j = fNdotL;// * shadow( NdotL ) * shadow( NdotV );
 


    // 'k' is used to provide small off-specular
    // peak for very rough surfaces. Can be changed
    // to suit desired results...
     float k = 0.1f;//was 0.1
    float reflect = min( 1.0f, r + j * ( r + k ) );
 
    float3 C1 = specularcolor;//float3( 1.0f, 1.0f, 1.0f );
    //float3 Cs = C1 + metal * (1.0f - fNdotL) * (diffusecolor - C1);
	float3 Cs = C1 + metal * (1.0f - NdotL) * (diffusecolor - C1);
 
 	//half specatten = saturate(3.0 * saturate(NdotL));
	half specatten = saturate(NdotL);

	

    // Evaluate the specular term
 //   half3 specular = Cs * reflect*specatten;
//	specular *= pow( -HdotV, 3.0f / ((1.0f - _smooth)) ); //(0.000000134123f + (1.0f - _smooth))
	
	CONST float3 H2 = normalize(V+L);
	half3 specular = half3(pow(saturate(dot(N,H2)), 40.0f));

	
    // Composite the final result, ensuring
    // the values are >= 0.0f yields better results. Some
    // combinations of inputs generate negative values which
    // looks wrong when rendered...
    diffuse  = max(half3(0.0f), diffusestr*diffuse*lightcolor.rgb );
    specular = max(half3(0.0f), specularstr*specular*specularcolor.rgb*diffusecolor.rgb ); //*diffusecolor.rgb
	//new : additive/multiply mix

	CONST half3 addSpecular = specfunc*specular;
	CONST half3 mulSpecular = (1.0 - specfunc)*specular;
	diffuse = (diffuse + addSpecular) + (diffuse*mulSpecular);

	//old style aditive only
	//diffuse += specular; //diffuse += diffuse*specular;
	
    return diffuse;
}

#include <common_shadows.h>

#ifndef DISABLE_SHADOW_HELPERS
#ifndef OCULUS_SHADER
#ifndef DISABLE_SHADOW_SUPPORT

vec3 CSMColorCascades(in float depth)
{
	int cascadeIndex = -1;
	for(int i = 0; i < 4; ++i) {
		if(depth < V_csmthresholds[i]) {	
			cascadeIndex = i;
			break;
		}
	}
	if (cascadeIndex == -1) {
		return vec3(0.0f, 0.0f, 1.0f);
	}
	if (cascadeIndex == 0) {
		return vec3(1.0f, 0.0f, 0.0f);
	}
	if (cascadeIndex == 1) {
		return vec3(1.0f, 1.0f, 0.0f);
	}
	if (cascadeIndex == 2) {
		return vec3(0.0f, 1.0f, 0.0f);
	}
	if (cascadeIndex == 3) {
		return vec3(0.0f, 1.0f, 1.0f);
	}
	
	return vec3(1.0f, 1.0f, 1.0f);
}

//vec3 csmDebugRender(in float ndotl)
vec3 csmDebugRender(in float ndotl, in vec4 coords[5])
{
	
	float z = IO_worldview_pos.z; // would not work for deferred
	
	vec4 weights = getCSMWeights(coords, ndotl);
	//weights = getCSMWeightsChar(coords);
	float w0 = weights.x;
	float w1 = min(1.0f - weights.x, weights.y);
	float w2 = min(1.0f - weights.y, weights.z);
	float w3 = min(1.0f - weights.z, weights.w);
	float w4 = 1.0f - (weights.w + weights.z + weights.y + weights.x); // recheck this one
	w4 = 1 - saturate(w0 + w1 + w2 + w3);

	
	CONST vec3 c0color = vec3(4, 0,0);
	CONST vec3 c1color = vec3(0, 4, 4);
	CONST vec3 c2color = vec3(4, 0, 4);
	CONST vec3 c3color = vec3(4, 4, 4);
	CONST vec3 c4color = vec3(4, 4, 4);
	
	float ndotle = max(epsilon, ndotl);
	
#define CSM_DRAW_TEXELS

	vec3 dbgcol = vec3(0);
	dbgcol += c0color*w0;
#ifdef CSM_DRAW_TEXELS
	float t = floor(coords[0].x * F_shadowmapsize + 0.5f) + floor(coords[0].y * F_shadowmapsize + 0.5f);
	float s0 = w0 * GetCSMSampleHard(T_shadowCSM0, coords[0].xyz + biasCSM[0] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w0+s0);
#endif
#ifdef D_USE_CSM_C1
	dbgcol += c1color*w1;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[1].x * F_shadowmapsize + 0.5f) + floor(coords[1].y * F_shadowmapsize + 0.5f);
	float s1 = w1 * GetCSMSampleHard(T_shadowCSM1, coords[1].xyz + biasCSM[1] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w1+s1);
#endif
#endif
#ifdef D_USE_CSM_C2
	dbgcol += c2color*w2;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[2].x * F_shadowmapsize + 0.5f) + floor(coords[2].y * F_shadowmapsize + 0.5f);
	float s2 = w2 * GetCSMSampleHard(T_shadowCSM2, coords[2].xyz + biasCSM[2] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w2+s2);
#endif
#endif
#ifdef D_USE_CSM_C3
	dbgcol += c3color*w3;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[3].x * F_shadowmapsize + 0.5f) + floor(coords[3].y * F_shadowmapsize + 0.5f);
	float s3 = w3 * GetCSMSampleHard(T_shadowCSM3, coords[3].xyz + biasCSM[3] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w3+s3);
#endif
#endif
#ifdef D_USE_CSM_C4
	dbgcol += c4color*w4;
#ifdef CSM_DRAW_TEXELS
	t = floor(coords[4].x * F_shadowmapsize + 0.5f) + floor(coords[4].y * F_shadowmapsize + 0.5f);
	float s4 = w4 * GetCSMSampleHard(T_shadowCSM4, coords[4].xyz + biasCSM[4] / ndotle);
	if(mod(t, 2.0) == 0) dbgcol *= saturate(1.0f-w4+s4);
#endif
#endif

	//if(z>F_shadowmaxdistance)
	//	dbgcol *= 0.0f;
	//
	//// draw cascade boundaries
	//CONST float linetreshold = z/500.0f;
	//
	//for(int i=0; i<4; ++i) {
	//	if(abs(z - V_csmthresholds[i]) < linetreshold)
	//		dbgcol = vec3(100.0f);
	//	// if(F_csm_blendstrength > 1.0f && abs(z - V_csmthresholds[i]) < linetreshold)
	//	// 	dbgcol = vec3(100.0f, 0.0f, 100.0f);
	//}

	
	return dbgcol;
		}


vec3 csmDebugRender(in float ndotl) {
	vec4 coords[5];
	return csmDebugRender(ndotl, coords);
}




// unified shadow interface
// make also depend on B_shadow?

float GetShadow(in float ndotl)
{
	// float z = RTResolve(T_gbuffer3).w;
	float z = IO_worldview_pos.z; // would not work for deferred
    
	CONST float FADE_OUT_PERCENTAGE = 0.1;
	float fade = saturate((z - (1.0 - FADE_OUT_PERCENTAGE) * F_shadowmaxdistance) / (FADE_OUT_PERCENTAGE * F_shadowmaxdistance));

	// if(fade>0.99)
	// 	return 1.0f;
	
	vec4 coords[5];
	coords[0] = IO_texshadowCSM0;
	coords[1] = IO_texshadowCSM1;
	coords[2] = IO_texshadowCSM2;
	coords[3] = IO_texshadowCSM3;
	coords[4] = IO_texshadowCSM4;
	return saturate(GetCSMShadow(ndotl, coords) + fade);
}

float GetShadow()
{
	return GetShadow(1.0f);
}

#endif //DISABLE_SHADOW_SUPPORT
#endif //OCULUS_SHADER
#endif //DISABLE_SHADOW_HELPERS

// #else /*GFX_VULKAN*/
/*
float GetShadow(in float ndotl)
{
	return 1.0f;
}

float GetShadow()
{
	return 1.0f;
}

#endif*/

//-------------------------------------------------------------------------------
// Lighting/Shadow defines ( pixel-shader specific )
//-------------------------------------------------------------------------------

#define CALC_AMBIENT(DIFFUSE, AMBIENT, OUT_COLOR)														\
	OUT_COLOR += AMBIENT * DIFFUSE;


#define CALC_GLOBAL_DIRLIGHT(NR, LIGHTFUNCTION) 														\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;											\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);										\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * F_globallightscale);								\
       	half2 DiffSpecTerms = LIGHTFUNCTION(Normal, V_direction##NR.rgb, VertexToEye, LightPower.xy); 	\
		DiffuseLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 									\
		SpecularLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y;									\
	}

#define CALC_GLOBAL_DIRLIGHT_SHADOW(NR, LIGHTFUNCTION_GLOBAL, LIGHT_POWER, IN_OUT_DIFFUSE, IN_OUT_SPECULAR, SHADOW) 	\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																										\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;												\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);											\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * F_globallightscale);									\
       	half2 DiffSpecTerms = LIGHTFUNCTION_GLOBAL(Normal.xyz, V_direction##NR.xyz, VertexToEye, LIGHT_POWER); 	\
       	DiffSpecTerms.x *= saturate(SHADOW * 0.9 + 0.1); /* sum to 1.0, 10% light still at shadow) */		\
       	DiffSpecTerms.y *= saturate(SHADOW * SHADOW); /* we dont want specular in shadow areas */			\
		IN_OUT_DIFFUSE.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 									\
		IN_OUT_SPECULAR.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y; 									\
	}

#define CALC_STRAUSS_DIRLIGHT_SHADOW(NR, DIFFUSE, F0, SHADOW, OUT_COLOR)								\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*12.0f;								\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew(Normal.rgb, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 		0.5,				\
										LightColor.rgb, DIFFUSE, F0); 								\
	/*	OUT_COLOR.rgb *= 0.0001; OUT_COLOR.rgb += half3(specstr);*/	\
	}
	
#define CALC_STRAUSS_DIRLIGHT_2_SHADOW(NR, DIFFUSE, SPECULAR, F0, SHADOW, OUT_COLOR)								\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*6.0f;								\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew2(Normal, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 		0.5,				\
										LightColor.rgb, DIFFUSE, F0,SPECULAR); 								\
	}

#define CALC_STRAUSS_DIRLIGHT_COCKPIT_SHADOW(NR, DIFFUSE, F0, SHADOW, OUT_COLOR)							\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																										\
		half4 LightColor = V_lightcolor##NR.rgba;															\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale*0.5;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g )* SHADOW * SHADOW*256.0f;					\
		CONST float diffstr = S_diffusestr * saturate(SHADOW * 0.9 + 0.1);									\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.rgb, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 1.0,			\
										LightColor.rgb, DIFFUSE, F0); 										\
	}

#define CALC_GLOBAL_DIRLIGHT_PLANET(NR, LIGHTFUNCTION) \
	if (V_lightcolor##NR.a > 0.0)									\
	{																	\
		half4 DirLightColor_Ex = V_lightcolor##NR.rgba;			\
    	DirLightColor_Ex.rgb = TO_linearRGB(DirLightColor_Ex.rgb);		\
    	DirLightColor_Ex.rgb *= (DirLightColor_Ex.a * 0.15); /* HACK layer multiply + HDR = bad idea */					\
       	half2 DiffSpecTerms = LIGHTFUNCTION(Normal, V_direction##NR.xyz, VertexToEye, LightPower.xy ); \
		DiffuseLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.x; 	\
		SpecularLight.rgb += DirLightColor_Ex.rgb * DiffSpecTerms.y;	\
	}																	

#define CALC_STRAUSS_PLANET_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		float specstr = S_specularstr * (TexSpecularStr.g)*12.0f;												\
		float diffstr = S_diffusestr;																	\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.xyz, VertexToEye, 						\
										Smoothness2, Metallness2, diffstr, specstr, 0.0	,					\
										LightColor.rgb, DIFFUSE, F0);								\
	/*	OUT_COLOR.rgb *= 0.0001; OUT_COLOR.rgb += LightColor.xyz/ 10;*/	\
	}


#define CALC_STRAUSS_2ND_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																	\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;													\
		LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float specstr = S_specularstr * (TexSpecularStr.g)*4.0f;												\
		CONST float diffstr = S_diffusestr;																	\
		OUT_COLOR.rgb += calc_StraussNew(Normal, V_direction##NR.xyz, VertexToEye, 						\
										U_mat_smoothness, U_mat_metallness, diffstr, specstr, 	1.0,					\
										LightColor.rgb, DIFFUSE, F0);								\
	}

#ifdef P1_SHADERS

float4 calc_Strauss_PBR(	CONST float3 N, 
					CONST float3 L, 
					CONST float3 V, 
					CONST float fSmoothness, 
					CONST float fMetalness,
					CONST float fTransparency,
					CONST float refractionIndex,
					CONST half3 lightcolor,
					CONST half3 cDiffuse
					)
{
	// Make sure the interpolated inputs and
	// constant parameters are normalized
	float3 n = N;//normalize( N );
	float3 l =normalize( L );
	float3 v = V;//normalize( V );
	float3 h = reflect( l, n );

	// Declare any aliases:
	float NdotL   = dot( n, l );
	float NdotV   = dot( n, v );
	float HdotV   = dot( h, v );
	float fNdotL  = fresnel_a( NdotL );
	float s_cubed = fSmoothness * fSmoothness * fSmoothness;

	//	return float4(fNdotL,fNdotL,fNdotL,1.0f);

	// Evaluate the diffuse term
	float d  = ( 1.0f - fMetalness * fSmoothness );
	float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
	float3 diffuse = NdotL * d * Rd * cDiffuse  * lightcolor;

	// Compute the inputs into the specular term
	float r = ( 1.0f - fTransparency ) - Rd;

	float j = fNdotL * shadow( NdotL ) * shadow( NdotV );

	// 'k' is used to provide small off-specular
	// peak for very rough surfaces. Can be changed
	// to suit desired results...
	CONST float k = 0.01f;
	float reflect = min( 1.0f, r + j * ( r + k ) );

	float3 C1 = float3( 1.0f, 1.0f, 1.0f );
	float3 Cs = C1 + fMetalness * (1.0f - fNdotL) * (cDiffuse - C1);


	// Evaluate the specular term
	float3 specular = Cs * reflect;
	specular *= pow( -HdotV, 3.0f / (1.0f - fSmoothness) );
	//below: test to tint spec more to material color
	specular = specular * (1.1f-fMetalness)+ specular*(fMetalness+0.1f)*cDiffuse * lightcolor;
	// Composite the final result, ensuring
	// the values are >= 0.0f yields better results. Some
	// combinations of inputs generate negative values which
	// looks wrong when rendered...
	diffuse  = max( float3(0.0f), diffuse );
	specular = max( float3(0.0f), specular*2.0f *  float3(lambert_half(NdotL, 2.2)) );
	// return float4(specular, 1.0f );
	return float4( diffuse + specular, luminance(specular));
}

	float4 calc_Strauss_PBR_aniso(	CONST float3 N,
					CONST float3 L,
					CONST float3 V,
					CONST float fSmoothness,
					CONST float fMetalness,
					CONST float fTransparency,
					CONST float refractionIndex,
					CONST half3 lightcolor,
					CONST half3 cDiffuse,
					float2 fAnisotropicRoughness
					)
	{
		// Make sure the interpolated inputs and
		// constant parameters are normalized
		float3 n = N;//normalize( N );
		float3 l =normalize( L );
		float3 v = V;//normalize( V );
		float3 h = reflect( l, n );
		float3 h2 = normalize( l + v );

		// Declare any aliases:
		float NdotL   = dot( n, l );
		float NdotV   = dot( n, v );
		float HdotV   = dot( h, v );
		float fNdotL  = fresnel_a( NdotL );
		float s_cubed = fSmoothness * fSmoothness * fSmoothness;

		// Apply a small bias to the roughness
		// coefficients to avoid divide-by-zero
		fAnisotropicRoughness += float2( 1e-5f, 1e-5f );

		// Define the coordinate frame
		float3 epsilon   = float3( 1.0f, 0.0f, 0.0f );
		float3 tangent   = normalize( cross( n, epsilon ) );
		float3 bitangent = normalize( cross( n, tangent ) );
		// float VdotN = dot( v, n );
		// float LdotN = dot( l, n );
		float H2dotN = dot( h2, n );

		float H2dotT = dot( h2, tangent );
		float H2dotB = dot( h2, bitangent );

		// Evaluate the specular exponent
		float beta_a  = H2dotT / fAnisotropicRoughness.x;
		beta_a       *= beta_a;

		float beta_b  = H2dotB / fAnisotropicRoughness.y;
		beta_b       *= beta_b;

		float beta = -2.0f * ( ( beta_a + beta_b ) / ( 1.0f + H2dotN ) );

		// Evaluate the specular denominator
		float s_den  = 4.0f * 3.14159f; 
		s_den       *= fAnisotropicRoughness.x;
		s_den       *= fAnisotropicRoughness.y;
		s_den       *= sqrt( abs(NdotL * NdotV) );	//<Timon> I had to add the abs because apparently in HLSL sqrt of negative values is fine

		// Compute the final specular term
		//float3 Specular = Ps * ( exp( beta ) / s_den );


		// Evaluate the diffuse term
		float d  = ( 1.0f - fMetalness * fSmoothness );
		float Rd = ( 1.0f - s_cubed ) * ( 1.0f - fTransparency );
		float3 diffuse = NdotL * d * Rd * cDiffuse * lightcolor;

		// Compute the inputs into the specular term
		float r = ( 1.0f - fTransparency ) - Rd;

		float j = fNdotL * shadow( NdotL ) * shadow( NdotV );

		// 'k' is used to provide small off-specular
		// peak for very rough surfaces. Can be changed
		// to suit desired results...
		CONST float k = 0.01f;
		float reflect = min( 1.0f, r + j * ( r + k ) );

		float3 C1 = float3( 1.0f, 1.0f, 1.0f );
		float3 Cs = C1 + fMetalness * (1.00001f - fNdotL) * (cDiffuse - C1);

		// Evaluate the specular term
		float3 specular;
// 		specular = Cs * reflect;
// 		specular *= pow( -HdotV, 3.0f / (1.00001f - fSmoothness) );
	//	specular = C1*NdotL*( exp( beta ) / s_den);
		specular = float3( exp( beta ) / s_den) * float3(fSmoothness+0.001f);
		//to tint spec more to material color
		specular = (specular * saturate(1.00001f-fMetalness)+ specular*saturate(fMetalness+0.0001f)*cDiffuse) * lightcolor ;
		//specular = (specular * saturate(1.00001f-pow(fMetalness,0.1f))+ specular*saturate(pow(fMetalness,0.1f)+0.0001f)*cDiffuse) * lightcolor ;
	
		// Composite the final result, ensuring
		// the values are >= 0.0f yields better results. Some
		// combinations of inputs generate negative values which
		// looks wrong when rendered...
		diffuse  = max( float3(0.0f), diffuse );
		specular = max( float3(0.0f), specular *  lambert_half(NdotL, 6.2) );
		//specular = max( 0.0f, specular*(30.0f+15.0f*fMetalness) *  lambert_half(NdotL, 2.2) );
		//return float4(specular, 1.0f );
		return saturate(float4( diffuse + specular, luminance(specular) ));
	}

	#define CALC_STRAUSS_PBR_ANI(NR, DIFFUSE, OUT_COLOR)												\
	if (V_lightcolor##NR.a > 0.0)																		\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;														\
    	LightColor.rgb = TO_linearRGB(LightColor.rgb) * LightColor.a * F_globallightscale;				\
		CONST float transparency = 0.0f;																\
		CONST float refraction = 1.0f;																	\
		OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.rgb, VertexToEye, 			\
										SmoothnessVal, MetalnessVal, transparency, refraction,			\
										LightColor.rgb, DIFFUSE,SmoothnessVal);							\
	}

	#define CALC_STRAUSS_PBR_ANI2(NR, DIFFUSE, OUT_COLOR)												\
	{																									\
		half4 LightColor = V_lightcolor##NR.rgba;														\
    	LightColor.rgb = (LightColor.rgb) * F_globallightscale;											\
		CONST float transparency = 0.0f;																\
		CONST float refraction = 0.0f;																	\
		OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.rgb, VertexToEye, 			\
										SmoothnessVal, MetalnessVal, transparency, refraction,			\
										LightColor.rgb, DIFFUSE,fAnisotropicRoughness).rgb;					\
	}

	#define CALC_STRAUSS_PBR_ANI2_DIRLIGHT(NR, DIFFUSE, F0, OUT_COLOR)												\
		{																									\
			half4 LightColor = V_lightcolor##NR.rgba;													\
			LightColor.rgb = (LightColor.rgb) * F_globallightscale;				\
			CONST float transparency = 0.0f;																\
			CONST float refraction = 0.0f;																\
			OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.xyz, VertexToEye, 						\
											SmoothnessVal, MetalnessVal, transparency, refraction,						\
											LightColor.rgb, DIFFUSE, fAnisotropicRoughness).rgb;								\
		}
	#define CALC_STRAUSS_PBR_TRANSP_DIRLIGHT(NR, DIFFUSE, ALPHA, OUT_COLOR)												\
		{																									\
			half4 LightColor = V_lightcolor##NR.rgba;													\
			LightColor.rgb = (LightColor.rgb) * F_globallightscale;				\
			CONST float transparency = 1.0f-ALPHA;																\
			CONST float refraction = 0.0f;																\
			CONST float SmoothnessVal = 0.20f;																\
			CONST float MetalnessVal = 0.0f;																\
			CONST float2 fAnisotropicRoughness = float2(0.75f,0.75f);											\
			OUT_COLOR.rgb += calc_Strauss_PBR_aniso(Normal, V_direction##NR.xyz, VertexToEye, 						\
											SmoothnessVal, MetalnessVal, transparency, refraction,						\
											LightColor.rgb, DIFFUSE,fAnisotropicRoughness).rgb;								\
		}
	
#endif

#include <jon_mod_lighting_functions.h>

vec3 global_lights(in vec3 wn, in vec3 view_pos, in vec3 Albedo, in float Metalness, in float Roughness, bool dossr, vec4 prev)
{
	vec3 wv = normalize(-view_pos) * mat3(M_view);
	vec3 wr = reflect(-wv, wn);

	float ambient_occlusion = 1.0f;
	// ambient_occlusion = mix(1, Shadow, n_dot_l); // ambient attenuation wrt. shadow (sometimes "weird")
	ambient_occlusion = GetSSAO();
	
	// vec3 cspec = mix(vec3(0.04), Albedo, Metalness);
	// vec3 cdiff = Albedo * (1-Metalness);
	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	get_colors(Albedo, Metalness, cspec, cdiff);
	// vec3 cdiff = Albedo * saturate(1.0f - luminance(cspec)); // alt energy conservation
	
	// dirlight data
	vec3 ldirs[2];
	vec3 lcolors[2];
	float direct_occlusions[2];

	ldirs[0] = normalize(V_direction1.xyz);
	ldirs[1] = normalize(V_direction2.xyz);

#ifdef LOCALSPEC
	lcolors[0] = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale*2.0f;
	lcolors[1] = XR_TO_linearRGB(V_lightcolor2.rgb) * F_globallightscale*2.0f;
#else
	lcolors[0] = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale;
	lcolors[1] = XR_TO_linearRGB(V_lightcolor2.rgb) * F_globallightscale;
#endif


	for (int i = 0; i < 2; ++i) {
		direct_occlusions[i] = saturate(dot(ldirs[i], wn));
	}
	
	//vec3 l = mat3(M_view) * normalize(V_direction1.xyz);

	// shadows for mainlight
	float Shadow = 0.0f;
	vec4 test = vec4(0);
#ifdef JON_MOD_SSSHADOWS
	float fade = 0.0;
#endif 		
	
#ifndef DISABLE_SHADOW_HELPERS
#ifndef DISABLE_SHADOW_SUPPORT
	if (B_shadow && direct_occlusions[0] > 0.0f) {
		float ndotle = max(epsilon, direct_occlusions[0]);
		CONST float FADE_STR = 0.1;
		CONST float FADE_STR_DIST = 0.5;
		if (F_shadowmaxdistance < 6000.0f) {
			FADE_STR_DIST = 0.7;
		}
		#ifdef JON_MOD_SSSHADOWS
			fade = saturate((length(view_pos) - (1.0 - FADE_STR) * F_shadowmaxdistance) / (FADE_STR_DIST * F_shadowmaxdistance));
		#else
			float fade = saturate((length(view_pos) - (1.0 - FADE_STR) * F_shadowmaxdistance) / (FADE_STR_DIST * F_shadowmaxdistance));
		#endif

		vec4 coords[5];
		coords[0] = mul(float4(view_pos, 1), M_shadowCSM0);
		coords[1] = mul(float4(view_pos, 1), M_shadowCSM1);
		coords[2] = mul(float4(view_pos, 1), M_shadowCSM2);
		coords[3] = mul(float4(view_pos, 1), M_shadowCSM3);
		coords[4] = mul(float4(view_pos, 1), M_shadowCSM4);
		direct_occlusions[0] *= saturate(fade + GetCSMShadow(direct_occlusions[0], coords));
		
	/*	vec4 weights = getCSMWeights(coords);
		float w0 = weights.x;
		float w1 = min(1.0f-weights.x, weights.y);
		float w2 = min(1.0f-weights.y, weights.z);
		float w3 = min(1.0f-weights.z, weights.w);
		float w4 = 1.0f - (weights.w+weights.z+weights.y+weights.x); // recheck this one
		w4 = 1 - saturate(w0+w1+w2+w3);
		
// 		direct_occlusions[0] *= GetCSMSample3Taps(T_shadowCSM2, mul(float4(view_pos, 1), M_shadowCSM2).xyz + biasC2/ndotle);
// 		direct_occlusions[0] *= GetCSMSample3Taps(T_shadowCSM3, mul(float4(view_pos, 1), M_shadowCSM3).xyz + biasC3/ndotle);
		
// 		Shadow += GetCSMSample3Taps(T_shadowCSM2, mul(float4(view_pos, 1), M_shadowCSM2).xyz + biasC2/ndotle);
		
// 			Shadow += w0 * GetCSMSample3Taps(T_shadowCSM0, coords[0].xyz + biasC0/ndotle);
// 			Shadow += w1 * GetCSMSample3Taps(T_shadowCSM1, coords[1].xyz + biasC1/ndotle);
// 			Shadow += w2 * GetCSMSample3Taps(T_shadowCSM2, coords[2].xyz + biasC2/ndotle);
// 			Shadow += w3 * GetCSMSample2Taps(T_shadowCSM3, coords[3].xyz + biasC3/ndotle);
// 			Shadow += w4 * GetCSMSampleFast(T_shadowCSM4, coords[4].xyz + biasC4/ndotle);
		
		direct_occlusions[0] *= saturate(Shadow);
// 		test = getCSMWeights(coords);
// 		test = coords[1];/**/
	}
#endif
#endif

	// light accumulation
	vec3 light_accum = vec3(0);
#ifdef JON_MOD_SSSHADOWS
	vec3 ss_shadow_debug = vec3(0.0);
#endif	
	// dirlights
	for(int i=0; i<2; i++) {
		//float n_dot_l = saturate(dot(Normal, ldirs[i]));
		//float direct_occlusion = n_dot_l;
		//if(i==0) { // only attenuation for 1st light
		//	direct_occlusion *= Shadow;
		//}
		CONST float light_radius = V_deferred_lightparams.x*10; // dbg scale

		float ss_shadow = 1.0;
		
		#ifdef JON_MOD_SSSHADOWS
			float fade_near = saturate(-(length(view_pos) - JON_MOD_SSSHADOWS_FADE_DISTANCE_NEAR) / (JON_MOD_SSSHADOWS_FADE_DISTANCE_NEAR * 0.5));
			fade = max(fade, saturate((length(view_pos) - (1.0 - 0.1) * JON_MOD_SSSHADOWS_FADE_DISTANCE) / (0.5 * JON_MOD_SSSHADOWS_FADE_DISTANCE)));
			#ifdef JON_MOD_SSSHADOWS_DEBUG_MODE
				ss_shadow_debug.r = direct_occlusions[JON_MOD_SSSHADOWS_LIGHT_TO_DEBUG] * (fade_near + fade);
				ss_shadow_debug.b = direct_occlusions[JON_MOD_SSSHADOWS_LIGHT_TO_DEBUG];
			#endif
			//screenspace shadow
			if((direct_occlusions[i] * (fade_near + fade)) > 0.0)
			{
				#ifndef JON_MOD_SSSHADOWS_SUPPORT_BOTH_PRIMARY_LIGHTS
				if(i > 0)
					break;
				#endif
				
				#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
					if(GetViewPos().x > 0.0)
				#endif
				ss_shadow = ScreenSpaceShadows(	world2view_rot(-ldirs[i]), 
															vec2(fade_near, fade), 
															ss_shadow_debug, 
															i);
			}
			#ifdef JON_MOD_SSSHADO_FILTER
				#if 1
					ss_shadow = mix(ss_shadow, 0.5, saturate((fwidth(ss_shadow))));
				#else
					ss_shadow = mix(ss_shadow, 0.5, saturate(max(abs(dFdxFine(ss_shadow)), abs(dFdyFine(ss_shadow)))));
				#endif
			#endif
		#endif
		direct_occlusions[i] *= ss_shadow;

		// todo: slightly refactor the following
		vec3 L;
		vec3 E_sph = direct_occlusions[i] * lcolors[i] * EvalSphereLight(light_radius, ldirs[i] * 1000, wv, wn, wr, Roughness, L);
		//E_sph *= PI; // diffuse normalization
		L = normalize(L);
		light_accum += EvalBRDF(cspec, cdiff, Roughness, L, wv, wn, vec2(0, 1)) * E_sph; // specular
		
		// clearcoat
		//float clearcoat_spec = cc * EvalBRDF(vec3(0.05), cdiff, 0.1, L, v, Normal2, vec2(0,1)).r; // ok since dielectric reflection
		//light_accum += clearcoat_spec * E_sph;

		vec3 E_diffuse = direct_occlusions[i] * ambient_occlusion * lcolors[i];
		//light_accum += cdiff / PI * E_diffuse; // diffuse
		light_accum += cdiff * E_diffuse; // diffuse
	}
	{// ambient light
		// reduce roughness based on v_dot_n yields nicer fresnel contours
		float v_dot_n = saturate(dot(wv, wn));
		
		/*
		Jon Note if anyone from Egosoft ever reads this, I would stronly recommend against this!! 
		None of the AAA engines does it. It leads to insane levels of specular aliasing, even with TAA.
		And the high anisotropic strething reflections you're trying to acomplish with it can't be achieved like this.
		It is technically possible to stretch the derivatives for a textureCUBEgrad() however. ;)
		*/
		#ifdef JON_MOD_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE
			#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
				float ambRoughness = GetViewPos().x > 0.0 ? Roughness : mix(Roughness*0.3, Roughness, pow(v_dot_n, 1.0/3.0));	
			#else				
				float ambRoughness = Roughness;
			#endif
		#else
			// smaller cone at edges to highlight fresnel
			float ambRoughness = mix(Roughness*0.3, Roughness, pow(v_dot_n, 1.0/3.0));
			//ambRoughness = Roughness; // deactivated, effect too strong
		#endif		

		// vec3 spec_amb =  simple_spec_brdf_ibl(T_ibl_envmap, cspec, Roughness, wn, wv);
		// vec3 spec_amb =  spec_brdf_ibl(T_ibl_envmap, vec3(0,0,0), T_preintegrated_GGX, cspec, ambRoughness, wn, wv);
		vec3 Eamb = V_ambient1.rgb;//Flat color in the age of PBR :(

		//TODO SSR has higher priority!
		vec4 ssr = vec4(0);
		if (dossr) {
			ssr = RTResolveSoft(T_ssr);
			ssr.a = SSR_GetHit(ssr.a);
// 			ssr *= (1 - ambRoughness);
// 			ssr.rgb *= cspec;
// 			float n_dot_v = saturate(dot(wn, wv));

// 			vec2 env_brdf = textureLod(T_preintegrated_GGX, vec2(ambRoughness, n_dot_v), 0).xy;
			// return vec3(env_brdf, 0);
// 			ssr.rgb *= (cspec*env_brdf.x + env_brdf.y);
		}

		#ifdef JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL
			#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
				if(GetViewPos().x > 0.0)
				{
					light_accum += combined_ambient_brdf(T_ibl_envmap, cspec, cdiff, wn, wv, ambRoughness, ambient_occlusion, ssr, Eamb);
				}
				else
				{
					float a = ssr.a;
					vec3 first_sum = a * ssr.rgb;
			
					a += prev.a;
					first_sum += saturate(1 - a) * spec_first_sum_ibl(T_ibl_envmap, ambRoughness, wn, wv).rgb;
					first_sum += Eamb;
					vec3 spec_amb = spec_brdf(first_sum, cspec, ambRoughness, v_dot_n);
					vec3 diff_amb = saturate(1 - prev.a) * cdiff * (get_irradiance(T_ibl_envmap, wn) + Eamb);
			
					light_accum += (spec_amb + diff_amb) * ambient_occlusion;			
				}
			#else
				light_accum += combined_ambient_brdf(T_ibl_envmap, cspec, cdiff, wn, wv, ambRoughness, ambient_occlusion, ssr, Eamb);
			#endif
		#else
			float a = ssr.a;
			vec3 first_sum = a * ssr.rgb;
	
			a += prev.a;
			first_sum += saturate(1 - a) * spec_first_sum_ibl(T_ibl_envmap, ambRoughness, wn, wv).rgb;
			first_sum += Eamb;
			vec3 spec_amb = spec_brdf(first_sum, cspec, ambRoughness, v_dot_n);
			vec3 diff_amb = saturate(1 - prev.a) * cdiff * (get_irradiance(T_ibl_envmap, wn) + Eamb);
	
			light_accum += (spec_amb + diff_amb) * ambient_occlusion;
		#endif
	}
	
	light_accum = clamp(light_accum.rgb, 0, 10); // safety clamp, not visible
	#ifdef JON_MOD_SSSHADOWS_DEBUG_MODE
		light_accum = ss_shadow_debug;
	#endif
	return DEFERRED_HACK_TO_sRGB(light_accum) * ambient_occlusion;	//TODO why is there a double ambient_occlusion multiply?!
}

vec3 global_lights(in vec3 wn, in vec3 view_pos, in vec3 Albedo, in float Metalness, in float Roughness, bool dossr)
{
	return global_lights(wn, view_pos, Albedo, Metalness, Roughness, dossr, vec4(0));
}

#include <common_envmap.h>

#if SHADERFLAGS & SHADERFLAG_FORWARD_ENVMAP_PROBES

// // #define GLASS_PROBE_BLENDING_DEBUG /* def or ndef */
// WARNING also uncomment the undef below for safety

vec4 global_envmap_resolve_glass(vec3 wn, vec3 wv, float Roughness, float shadow)
{
	//TODO @Timon/Florian the below sampling math seems "a bit sketchy" and has somewhat specific to the glass shader,
	// would be nice to generalize it into multiple functions, at least one with proper math? further and do the proper math if we ever have a use-case for it?
	vec3 wpos = GetFragWorld();
	half3 R = reflect(-wv, wn);
	vec4 env = vec4(0);
#ifdef GLASS_PROBE_BLENDING_DEBUG
	vec3 col = vec3(0);
#endif
	for (uint i = 0; i < U_envmapprobe_num; ++i) {
		// spec str,rgb vs luminosity, aka bright areas reflect more than dark, "shiny" also reflect more -> spec str?
		//ColorEnvi.rgb += S_environmentstr * textureLod/*texCUBE*/(T_ibl_envmap, R_Eye,Roughness*MaxSpecularLevel(T_ibl_envmap)).rgb * ((saturate(1.0f-pow(dot(Normal,VertexToEye),0.5f))+0.1)/1.1f)*(1.0-ColorBaseDiffuse.a);
		vec3 r = R;
		r = EnvMapAdjust(i, wpos, r);
		vec4 e = textureLod(S_environment_map[i], r, Roughness * MaxSpecularLevel(S_environment_map[i]) + 0.50); //TODO darkening, etc?? like for dirt border
		float fade = EnvMapFading(i);
		e *= fade;
		// only multiply rgb here, so we still block the cluster envmap from shining through geometry
		e.rgb *= U_envmapprobe_insideglassfadein;

#ifdef GLASS_PROBE_BLENDING_DEBUG
		col += V_envmapprobe_color[i].rgb * fade * (1 - env.a);
#endif
		// e.a = 1; return e;
		env += e * (1 - env.a);
	}
#ifdef GLASS_PROBE_BLENDING_DEBUG
	DebugStore(vec4(col, 0.2f));
#endif
	{
		vec4 e = textureLod(T_ibl_envmap, R, Roughness * MaxSpecularLevel(T_ibl_envmap) + 0.50) * shadow; //TODO darkening, etc?? like for dirt border
		e.rgb *= U_envmapprobe_insideglassfadein;
		env += e * (1 - env.a);
	}
	return env;
}

// #undef GLASS_PROBE_BLENDING_DEBUG

#endif

//#extension GL_ARB_shading_language_420pack : enable // not supported on OSX (10.10.4)

/*useful pragmas for nvidia
#pragma optionNV(fastmath on)
#pragma optionNV(fastprecision on)
#pragma optionNV(ifcvt none)
#pragma optionNV(inline all)
#pragma optionNV(strict on)
#pragma optionNV(unroll all)
#pragma optionNV(inline all)
*/

#define D_DYNAMIC 1
#define D_STATIC 2
#define D_SPECIAL 3

#define X_CONCAT(a,b) a##b

// #define centroid /*centroid*/	//workaround for RADV:/


	#define VK_BLOCK(name,block)			\
		layout(set = ENUM_BUFFER_##name, binding = 0, std140) uniform BUFFER_##name			\
		{			\
			block			\
		};


#ifdef XIMGUI
	#define I_HATE_MACROS			\
		uniform mat4 DEBUG_Matrix0;			\
		uniform mat4 DEBUG_Matrix1;			\
		uniform vec4 DEBUG_Vector0;			\
		uniform vec4 DEBUG_Vector1;			\
		uniform vec4 DEBUG_Vector2;			\
		uniform vec4 DEBUG_Vector3;			\
		uniform float DEBUG_Float0;			\
		uniform float DEBUG_Float1;			\
		uniform float DEBUG_Float2;			\
		uniform float DEBUG_Float3;			\
		uniform int DEBUG_Int0;				\
		uniform int DEBUG_Int1;				\
		uniform int DEBUG_Int2;				\
		uniform int DEBUG_Int3;
#else
	#define I_HATE_MACROS
#endif
	
VK_BLOCK(CAMERA,
	uniform mat4 M_view;
	uniform mat4 M_projection;
	uniform mat4 M_invprojection;
	uniform mat4 M_viewprojection;
	uniform mat4 M_viewinverse;
	
	uniform mat4 M_shadowCSM0Clip;
	uniform mat4 M_shadowCSM1Clip;
	
	uniform vec4 V_viewportpixelsize/* = vec4(1024, 768, 3, 5000000)*/;
	uniform vec4 V_cameraposition;
	
	uniform vec4 V_ambient1;

	uniform vec4 V_direction1;
	uniform vec4 V_lightcolor1;
	uniform vec4 V_direction2;
	uniform vec4 V_lightcolor2;
	uniform vec4 V_direction3;
	uniform vec4 V_lightcolor3;

	uniform vec4 V_light_direction_view[3];
	
	uniform vec4 V_tintcolor;			//for tinted_glass: DEF_AUTO_PARA(BlendColor	, TINTCOLOR				, float3	, {1.0, 1.0, 1.0})

	uniform vec4 V_csmthresholds;
	
	
	uniform vec4 V_volume_range;
	uniform vec4 V_volume_size;
	
	uniform vec4 V_volume_scatter_power[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_sigma_extinction[GFX_MAX_VOLUME_TYPES];
	
	uniform vec4 V_volume_phase0_param[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_phase1_param[GFX_MAX_VOLUME_TYPES];
	uniform vec4 V_volume_phase2_param[GFX_MAX_VOLUME_TYPES];
	
	uniform ivec4 I_volume_phases[GFX_MAX_VOLUME_TYPES];
/*	uniform int I_volume_phase_num[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase0[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase1[GFX_MAX_VOLUME_TYPES];
	uniform int I_volume_phase2[GFX_MAX_VOLUME_TYPES];*/
	
/*	uniform vec4 V_volume_type0_scatter_power;
	uniform vec4 V_volume_type0_sigma_extinction;
	
	uniform vec4 V_volume_type0_phase0_param;
	uniform vec4 V_volume_type0_phase1_param;
	uniform vec4 V_volume_type0_phase2_param;
	
	uniform vec4 V_volume_type1_scatter_power;
	uniform vec4 V_volume_type1_sigma_extinction;
	
	uniform vec4 V_volume_type1_phase0_param;
	uniform vec4 V_volume_type1_phase1_param;
	uniform vec4 V_volume_type1_phase2_param;
	
	uniform vec4 V_volume_type2_scatter_power;
	uniform vec4 V_volume_type2_sigma_extinction;
	
	uniform vec4 V_volume_type2_phase0_param;
	uniform vec4 V_volume_type2_phase1_param;
	uniform vec4 V_volume_type2_phase2_param;*/
	
	uniform float F_globallightscale;
	uniform float F_locallightscale;
	uniform float F_time;
	uniform float F_framedeltatime;
	uniform float F_exposure;			//DEF_AUTO_PARA(Exposure, EXPOSURE, float, (0.5))
	uniform float F_ibl_maxvalidlevel;

	uniform float F_csm_blendstrength;
	uniform float F_shadowmapsize; // used for kernel width adjustment
	uniform float F_shadowmaxdistance;		//DEF_AUTO_PARA(ShadowMaxDist	, SHADOWMAXDISTANCE			, float		, {5000.0})
	//I think F_shadowbias, F_shadowtexelbias, F_shadowmaxdistance is never set,
	// and F_shadowmapsize is never used...
	// F_shadowmaxdistance is set according to videoparameters
	uniform bool B_csmpcfenabled;
	uniform float F_texturefactorCSM0;
	uniform float F_texturefactorCSM1;
	uniform float F_texturefactorCSM2;
	uniform float F_texturefactorCSM3;
	uniform float F_texturefactorCSM4;

	uniform bool B_ssao_enabled;
	uniform bool B_lighting;
	
	uniform bool B_csmdebugcolor;
	
	uniform bool B_shadow;
	
	uniform float F_volume_off;
	uniform float F_volume_scale;

	uniform bool B_pom_enabled;
	uniform float F_pom_minlayers;
	uniform float F_pom_maxlayers;
	
	I_HATE_MACROS
)

#undef I_HATE_MACROS

#ifdef GFX_VULKAN
	layout(constant_id = 2) const bool B_deferred_draw = false;
	layout(constant_id = 3) const int I_instancetype = VERTEXTYPE_ENUMSIZE;
	
#ifdef GFX_EXTENDEDVDATA
	VK_BLOCK(WORLD,
		uniform mat4 M_worldviewprojection;
		uniform mat4 M_world;
		
		uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
		uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
		uniform mat4 M_shadowCSM2;
		uniform mat4 M_shadowCSM3;
		uniform mat4 M_shadowCSM4;
		
		uniform vec4 V_blendcolor;
		uniform float F_alphascale;
		uniform bool B_packedtangentframe;
		uniform bool B_vertexdata0;
		uniform bool B_vertexdata1;
		uniform bool B_vertexdata2;
		uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)
	)
#else
	VK_BLOCK(WORLD,
		uniform mat4 M_worldviewprojection;
		uniform mat4 M_world;

		uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
		uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
		uniform mat4 M_shadowCSM2;
		uniform mat4 M_shadowCSM3;
		uniform mat4 M_shadowCSM4;

		uniform vec4 V_blendcolor;
		uniform float F_alphascale;
		uniform bool B_packedtangentframe;
		uniform bool B_vertexdata0;
		uniform bool B_vertexdata1;
		uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)
	)
#endif

/*	layout(push_constant) uniform BUFFER_PC
	{
		mat4 worldviewprojection;
		mat4 world;
	}PC;
	#define M_worldviewprojection PC.worldviewprojection
	#define M_world PC.world*/
#else
	uniform mat4 M_worldviewprojection;
	uniform mat4 M_world;
	
	uniform mat4 M_shadowCSM0; // is also used in shadow generation pass
	uniform mat4 M_shadowCSM1; // is also used in shadow generation (for skinning)
	uniform mat4 M_shadowCSM2;
	uniform mat4 M_shadowCSM3;
	uniform mat4 M_shadowCSM4;
	
	// uniform mat4 M_worldview; // these two will be needed for proper view space lighting
	// uniform mat4 M_worldviewinversetranspose;
	uniform vec4 V_blendcolor;
	uniform float F_alphascale;
	uniform bool B_packedtangentframe;
	uniform bool B_vertexdata0;
	uniform bool B_vertexdata1;
#ifdef GFX_EXTENDEDVDATA
	uniform bool B_vertexdata2;
#endif
	uniform bool B_useskinning;				//DEF_SWITCH(bUseSkinning			, USESKINNING			, b4,false, use skinning)

	uniform bool B_deferred_draw;			// set whenever a deferred shader is called in a deferred way
	
	uniform int I_instancetype = VERTEXTYPE_ENUMSIZE;//TODO @Timon if we ever implement it in OGL it should be specialized
	
	D_shadow_QUAL bool B_shadow = D_shadow_VALUE;
	
	#if D_alpha_test == D_DYNAMIC
	uniform bool B_alpha_test = false;		//for alpha-testing
	#elif D_alpha_test == D_SPECIAL
	const bool B_alpha_test = D_alpha_test_VALUE;
	//#define B_alpha_test D_alpha_test_VALUE
#endif

#endif

layout(set = ENUM_BUFFER_DYNAMIC, binding = 0, std140) uniform BUFFER_DYNAMIC
{
uniform mat4 M_texturematrix0;
uniform mat4 M_texturematrix1;
uniform mat4 M_texturematrix2;
uniform mat4 M_texturematrix3;
uniform bool B_textureanimation;

#define B_vertexcolorsrgb true

//for luminance
uniform float F_eyeadaptionspeed;	// DEF_AUTO_PARA(EyeAdaptionSpeed, EYEADAPTIONSPEED, float, 0.9)


//for SSAO
uniform vec4 V_frustumsize;			//DEF_AUTO_PARA(FrustumSize		, FRUSTUMSIZE		, float4	, {1.0, 1.0, 0.0, 0.0})

//for tonemap
//DEF_AUTO_PARA(ScreenLuminance, LUMINANCE, float4, (0,0,0,0))
uniform bool B_srgbout;			//DEF_AUTO_PARA(SRGBOut, SRGBOUT, bool, false)
uniform vec4 V_textureviews;	//DEF_AUTO_PARA(TextureViews, TEXTUREVIEWS, float4, {1280.0, 720.0, 1280.0, 720.0})

//#ifdef PROJECT_XR
uniform float F_lutblend;		//DEF_AUTO_PARA(ColorLUTBlend, DIFFUSE_SCALE, float, (0.0))
//#endif

#if SHADERFLAGS & SHADERFLAG_FORWARD_ENVMAP_PROBES
uniform vec4 V_envmapprobe_shape[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_color[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform mat4 M_envmapprobe_world[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform mat4 M_envmapprobe_world_rot[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_volumeoffset[GFX_MAX_FORWARD_ENVMAP_PROBES];
uniform vec4 V_envmapprobe_fadein[GFX_MAX_FORWARD_ENVMAP_PROBES];
#else
uniform mat4 M_envmapprobe_world;
uniform mat4 M_envmapprobe_world_rot;
uniform vec4 V_envmapprobe_volumeoffset;
uniform vec4 V_envmapprobe_shape;
#endif

DPREDEF_BUFFER_DYNAMIC

#if defined(CHROMATIC_ABERRATION) && defined(GFX_CHROMA_SAMPLES)
	uniform vec4 V_color[GFX_CHROMA_SAMPLES];
#endif

#ifdef BONE_MATRICES
	//TODO @Timon/Florian this and actually most of these should be refactored to .ogl if/when possible
	//although given how many and common they are, it seems necessary to also extend .ogl handling to allow including files or something
	// (to group common param sets into separate files)
	uniform mat4 M_boneworld[50];		//float4x4 mBone0[50] : BONEWORLD0;
	// TODO: P1 specific stuff
#endif
	
#ifdef VOLUME_POINT
	#define VOLUME_POINT_NUM 32	//ALSO defined in renderframe.cpp
// 	uniform vec4 V_point_pos[VOLUME_POINT_NUM];
	uniform mat4 M_offset[VOLUME_POINT_NUM];
	uniform vec4 V_scale[VOLUME_POINT_NUM];
	uniform int I_index[VOLUME_POINT_NUM];
	#ifndef VOLUME_POINT_FULL
	uniform int I_point_num;
	#endif
#endif
	
};


#ifdef GFX_VULKAN
layout(set = ENUM_BUFFER_MATERIAL, binding = 0, std140) uniform BUFFER_MATERIAL
#else
/*layout(binding = ENUM_BUFFER_EXTRA)*/ uniform BUF_material
#endif
{
#ifdef OCULUS_SHADER
	#define MAX_LAYER_COUNT 8

	vec4 baseColor;
	int baseMaskType;
	vec4 baseMaskParameters;
	vec4 baseMaskAxis;
	vec4 alphaMaskScaleOffset;
	vec4 normalMapScaleOffset;
	vec4 parallaxMapScaleOffset;
	vec4 roughnessMapScaleOffset;

	mat4 projectorInv;

//	bool useAlpha;
//	bool useNormalMap;
//	bool useRoughnessMap;
	bool useProjector;
	float elapsedSeconds;

	int layerCount;

	int layerSamplerModes[MAX_LAYER_COUNT];
	int layerBlendModes[MAX_LAYER_COUNT];
	int layerMaskTypes[MAX_LAYER_COUNT];
	vec4 layerColors[MAX_LAYER_COUNT];
	vec4 layerSurfaceScaleOffsets[MAX_LAYER_COUNT];
	vec4 layerSampleParameters[MAX_LAYER_COUNT];
	vec4 layerMaskParameters[MAX_LAYER_COUNT];
	vec4 layerMaskAxes[MAX_LAYER_COUNT];
	
/*	sampler2D alphaMask;
	sampler2D normalMap;
	sampler2D parallaxMap;
	sampler2D roughnessMap;
	sampler2D layerSurfaces[MAX_LAYER_COUNT];*/
#endif
	DPREDEF_BUFFER_MATERIAL
};

float epsilon = 0.000001f;

//TODO @Timon especially with AA we get NaNs at edges of transparent draws (mostly simple_hdr_out, lightcone) this seems to be mostly due to TO_linearRGB calls
//#define pow(x,y)	pow(max((x),0) + HALF3_SMALL_NUMBER, (y))


#define BGDIST (2000000.0f)
#define BGZ (1.0f / BGDIST)

#define PI (3.141592654f)
#define EUL (2.718281828459f)

#define mul(a,b) ((b) * (a))

vec2 SIGNED(vec2 v)
{
	return (v * 2.0) - 1.0;
}
vec3 SIGNED(vec3 v)
{
	return (v * 2.0) - 1.0;
}
/*
vec4 UNSIGNED(vec4 v)
{
	return (v * 0.5) + 0.5;
*/
vec4 SIGNED(vec4 v)
{
	return (v * 2.0) - 1.0;
}
#define SIGNED_pp SIGNED

float clip2uv(float v)
{
	v += 1;
	v /= 2;
	return v;
}
float uv2clip(float v)
{
	v *= 2;
	v -= 1;
	return v;
}
vec2 clip2uv(vec2 v)
{
	v += vec2(1);
	v /= vec2(2);
	return v;
}
vec2 uv2clip(vec2 v)
{
	v *= vec2(2);
	v -= vec2(1);
	return v;
}
vec3 clip2uv(vec3 v)
{
	v += vec3(1);
	v /= vec3(2);
	return v;
}
vec3 uv2clip(vec3 v)
{
	v *= vec3(2);
	v -= vec3(1);
	return v;
}

vec3 clipZ2uv(vec3 v)
{
	v.xy += vec2(1);
	v.xy /= vec2(2);
	return v;
}
vec3 uv2clipZ(vec3 v)
{
	v.xy *= vec2(2);
	v.xy -= vec2(1);
	return v;
}

vec3 clip2view(vec3 cs)
{
	vec4 p = M_invprojection * vec4(cs, 1);
	return p.xyz / p.w;
}

#ifdef GFX_OGL
	#define DEFAULT_TES_WINDING ccw
#else
	#define DEFAULT_TES_WINDING cw
#endif

/*
Unfortunately there are issues with const:
- glsl < 4.2 has different meaning for const
- amd-vulkan crashes weirdly,	e.g.
	scaleMat(const) is fine
	make_ColorMatrix(any param const) crashes
*/
#define CONST /*const*/
#define _IF if

#define tex2D texture
#define tex1D texture
#define tex2Dproj textureProj
#define tex2Dlod textureLod
#define tex3D texture
#define float2 vec2
#define float3 vec3
#define float4 vec4

#define half float
#define half2 vec2
#define half3 vec3
#define half4 vec4

#define float3x3 mat3
#define float4x4 mat4

float saturate(float v) {
	return clamp(v, 0, 1);
}
float2 saturate(float2 v) {
	return clamp(v, 0, 1);
}
float3 saturate(float3 v) {
	return clamp(v, 0, 1);
}
float4 saturate(float4 v) {
	return clamp(v, 0, 1);
}

float saturate0(float v)	{ return max(v, 0); }
vec2 saturate0(vec2 v)		{ return max(v, 0); }
vec3 saturate0(vec3 v)		{ return max(v, 0); }
vec4 saturate0(vec4 v)		{ return max(v, 0); }

float maxvec(vec2 v)
{
	return max(v.r, v.g);
}
float maxvec(vec3 v)
{
	return max(maxvec(v.rg), v.b);
}
float maxvec(vec4 v)
{
	return max(maxvec(v.rgb), v.a);
}

#define lerp(x,y,s)	mix(x,y,s)
#define frac fract

#define pow2(val) ((val) * (val))
#define dotself(val) dot((val), (val))

#define HALF_SMALL_NUMBER (0.00001)
#define HALF3_SMALL_NUMBER half3(HALF_SMALL_NUMBER, HALF_SMALL_NUMBER, HALF_SMALL_NUMBER)

#define FLOAT_SMALL_NUMBER (0.000000001)

// simple sRGB color conversion with 2.2f NOTE: preserve alpha
half3 TO_sRGB(CONST half3 inColor)
{
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(1.0/2.2)));
}

half4 TO_sRGB(CONST half4 inColor)
{
	return half4(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(1.0/2.2)), inColor.a);
}

half TO_linearRGB(CONST half inColor)
{
	return pow(inColor + HALF_SMALL_NUMBER, 2.2);
}

half3 TO_linearRGB(CONST half3 inColor)
{
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, vec3(2.2)));
}

half4 TO_linearRGB(CONST half4 inColor)
{
	return half4(pow(inColor.rgb + HALF3_SMALL_NUMBER, vec3(2.2)), inColor.a);
}

half3 D3DCOLOR_X_TO_linearRGB_HDR(CONST half4 inColor)
{
	//return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, 2.2) * inColor.a * LIGHTINTENSITY_SCALE);
	return half3(pow(inColor.rgb + HALF3_SMALL_NUMBER, half3(2.2)) );
}

float fresnel(CONST float3 V, CONST float3 N, CONST half Power)
{
	return (pow(1-abs(dot(V, N)), Power));    // note: abs() makes 2-sided materials work
}

//--- Color Correction matrix math ---

float4x4 scaleMat(CONST float s)
{
	return float4x4(
		s, 0, 0, 0,
		0, s, 0, 0,
		0, 0, s, 0,
		0, 0, 0, 1);
}
float4x4 scaleMat(CONST vec3 s)
{
	return float4x4(
		s.x, 0, 0, 0,
		0, s.y, 0, 0,
		0, 0, s.z, 0,
		0, 0, 0, 1);
}

float4x4 translateMat(CONST float3 t)
{
	return float4x4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		t, 1);
}

float4x4 saturationMat(CONST float s)
{ 
	CONST float rwgt = 0.3086;
	CONST float gwgt = 0.6094;
	CONST float bwgt = 0.0820;

	return float4x4(
		(1.0-s)*rwgt + s,	(1.0-s)*rwgt,  		(1.0-s)*rwgt,		0,
		(1.0-s)*gwgt, 		(1.0-s)*gwgt + s, 	(1.0-s)*gwgt,		0,
		(1.0-s)*bwgt,    	(1.0-s)*bwgt, 		(1.0-s)*bwgt + s,	0,
		0.0, 0.0, 0.0, 1.0);
}

float4x4 rotateMat(float3 d, CONST float ang)
{
	float s = sin(ang);
	float c = cos(ang);
	d = normalize(d);
	return float4x4(
		d.x*d.x*(1 - c) + c,		d.x*d.y*(1 - c) - d.z*s,	d.x*d.z*(1 - c) + d.y*s,	0,
		d.x*d.y*(1 - c) + d.z*s,	d.y*d.y*(1 - c) + c,		d.y*d.z*(1 - c) - d.x*s,	0, 
		d.x*d.z*(1 - c) - d.y*s,	d.y*d.z*(1 - c) + d.x*s,	d.z*d.z*(1 - c) + c,		0, 
		0, 0, 0, 1 );
}

mat4x3 make_ColorMatrix(CONST float inBrightness,CONST float inContrast,CONST float inSaturation,CONST float inHue)
{
	// construct color matrix

	// brightness - scale around (0.0, 0.0, 0.0)
	float4x4 brightnessMatrix = scaleMat(inBrightness);

	// contrast - scale around (0.5, 0.5, 0.5)
	float4x4 contrastMatrix = translateMat(vec3(-0.5));
	contrastMatrix = mul(contrastMatrix, scaleMat(inContrast) );
	contrastMatrix = mul(contrastMatrix, translateMat(vec3(0.5)) );

	// saturation
	float4x4 saturationMatrix = saturationMat(inSaturation);

	// hue - rotate around (1, 1, 1)
	float4x4 hueMatrix = rotateMat(float3(1, 1, 1), radians(inHue));

	// composite together matrices
	float4x4 m;
	m = brightnessMatrix;
	m = mul(m, contrastMatrix);
	m = mul(m, saturationMatrix);
	m = mul(m, hueMatrix);

	return mat4x3(m);
}

vec3 GetRGBBox(vec3 ray)
{
	ray = normalize(ray);
	vec3 mag = abs(ray);
	if (mag.r > mag.g && mag.r > mag.b) {
		if (ray.r >= 0)
			return vec3(1, 0, 0);
		else
			return vec3(0, 1, 1);
	}
	if (mag.g > mag.r && mag.g > mag.b) {
		if (ray.g >= 0)
			return vec3(0, 1, 0);
		else
			return vec3(1, 0, 1);
	}
	if (mag.b > mag.r && mag.b > mag.g) {
		if (ray.b >= 0)
			return vec3(0, 0, 1);
		else
			return vec3(1, 1, 0);
	}
	return vec3(0);
}


float random( float2 p )
{
  // We need irrationals for pseudo randomness.
  // Most (all?) known transcendental numbers will (generally) work.
  CONST float2 r = float2(
    23.1406926327792690,  // e^pi (Gelfond's constant)
     2.6651441426902251); // 2^sqrt(2) (Gelfond?Schneider constant)
  return frac( cos( /*f*/mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  //was 256.
}

float square(in float val)
{
	return val*val;
}

bool IsOutsideUV(float uv)
{
	return uv < 0 || uv > 1;
}

bool IsInsideUV(vec2 uv)
{
	return all(greaterThanEqual(uv, vec2(0))) && all(lessThanEqual(uv, vec2(1)));
}
bool IsOutsideUV(vec2 uv)
{
	return any(lessThan(uv, vec2(0))) || any(greaterThan(uv, vec2(1)));
}

vec4 Project(in vec4 val)
{
	val = M_projection * val;
	return val / val.w;
}
vec4 UnProject(in vec4 val)
{
	val = M_invprojection * val;
	return val / val.w;
}

vec3 Project(in vec3 val)
{
	vec4 tmp = M_projection * vec4(val, 1);
	return tmp.xyz / tmp.w;
}
vec3 UnProject(in vec3 val)
{
	vec4 tmp = M_invprojection * vec4(val, 1);
	return tmp.xyz / tmp.w;
}

vec3 view2world(in vec3 val)
{
	return (M_viewinverse * vec4(val, 1)).xyz;
// 	vec4 tmp = M_viewinverse * vec4(val, 1);
//	return tmp.xyz / tmp.w;
}
vec3 view2world_rot(in vec3 val)
{
	return mat3(M_viewinverse) * val;
}

vec3 world2view(in vec3 val)
{
	return (M_view * vec4(val, 1)).xyz;
}
vec3 world2view_rot(in vec3 val)
{
	return mat3(M_view) * val;
}


vec3 pix2volume(ivec3 pix)
{
	return pix / (V_volume_size.xyz - 1);
}
ivec3 volume2pix(vec3 uv)
{
	return ivec3(uv * (V_volume_size.xyz - 1));
}

/*
vec3 proj2volume(vec3 cs)
{
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}
vec3 volume2proj(vec3 uv)
{
	vec3 cs = uv2clipZ(uv);
// 	cs.z = 1 - cs.z;//flip for intuition
// 	cs.z *= 0.5;
// 	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
// 	cs.z = pow(cs.z, 2);
	cs.z *= F_volume_scale;
	cs.z += F_volume_off;
	return cs;
}*/

const float volume_near_scale = 1.0f;
const float volume_dist_scale = 1000.0f;

#define VOLUME_DIST_GODRAYS_LAYERS 1

const float volume_fom_min = 6000.0f;
// const float volume_fom_min = 0.0f;
const float volume_fom_max = 60000.0f;

#ifdef VOLUME_SHAD

#define VOLUME_SHAD_MARGIN /*def or ndef*/
#ifdef VOLUME_SHAD_MARGIN
	const float shvol_margin = 0.01;
#endif

const int shvol_offsets_num = 5;
const float shvol_offsets[shvol_offsets_num] = { 0, 0.63, 0.1, 0.32, 0.85 };

/*vec3 volume2shvol(vec3 uv)
{
	uv.xy += shvol_margin;
	uv.xy /= 1 + 2 * shvol_margin;
	return uv;
}
vec3 shvol2volume(vec3 uv)
{
	uv.xy *= 1 + 2 * shvol_margin;
	uv.xy -= shvol_margin;
	return uv;
}*/

float shvol_zoffset(ivec3 pix, int idx)
{
	if (idx >= 0 /*&& uv.z >= 1.0f / V_volume_size.z/**/) {
// 		idx /= 7;
// 		idx += pix.x + pix.y;
// 		idx += pix.x + int(V_volume_size.x) * pix.y;
// 		idx += pix.y + int(V_volume_size.y) * pix.x;
// 		idx = int(random(vec2(idx)) * shvol_offsets_num);
// 		idx = int(random(vec2(idx) + vec2(pix.xy)) * shvol_offsets_num);
// 		idx = int(random(vec2(idx) / 7 + vec2(pix.xy)) * (shvol_offsets_num - 1));
		idx %= shvol_offsets_num;
		return shvol_offsets[idx] / V_volume_size.z;
	}
	return 0;
}

vec3 volume2shvol(vec3 uv, ivec3 pix, int idx)
{
#ifdef VOLUME_SHAD_MARGIN
	uv.xy += shvol_margin;
	uv.xy /= 1 + 2 * shvol_margin;
#endif
	uv.z += shvol_zoffset(pix, idx);
	return uv;
}
vec3 volume2shvol(vec3 uv, ivec3 pix)
{
	return volume2shvol(uv, pix, U_offset);
}
vec3 volume2shvolPrev(vec3 uv, ivec3 pix)
{
	return volume2shvol(uv, pix, U_offset - 1);
}

vec3 shvol2volume(vec3 uv, ivec3 pix)
{
// 	return uv;
#ifdef VOLUME_SHAD_MARGIN
	uv.xy *= 1 + 2 * shvol_margin;
	uv.xy -= shvol_margin;
#endif
	uv.z -= shvol_zoffset(pix, U_offset);
	return uv;
}
#endif

float view2volume(float z)
{
	z = 0.1f / z; //TODO @Timon camera near-dist
	z -= F_volume_off;
	z /= F_volume_scale;
	z = sqrt(z);
	return z;
}
float volume2view(float z)
{
	z *= z;
	z *= F_volume_scale;
	z += F_volume_off;
	z = 0.1f / z; //TODO @Timon camera near-dist
	return z;
}


vec3 view2volume(vec3 vp)
{
	vec3 cs = Project(vp);
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
	cs.z = sqrt((cs.z));
// 	cs.z = sqrt(abs(cs.z));
// 	cs.z = pow(cs.z, 1.0f/2.0f);
// 	cs.z = pow(cs.z, 1.0f/4.0f);
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}
vec3 volume2view(vec3 uv)
{
	vec3 cs = uv2clipZ(uv);
// 	cs.z = 1 - cs.z;//flip for intuition
// 	cs.z *= 0.5;
	cs.z *= cs.z;
// 	cs.z = sqrt(cs.z);
// 	cs.z = pow(cs.z, 2.0f);
// 	cs.z = pow(cs.z, 4.0f);
	cs.z *= F_volume_scale;
	cs.z += F_volume_off;
	vec3 view = UnProject(cs);
	return view;
}

vec3 view2volume_linear(vec3 vp)
{
	vec3 cs = Project(vp);
	cs.z -= F_volume_off;
	cs.z /= F_volume_scale;
// 	cs.z *= cs.z;
	cs.z = sqrt((cs.z));
// 	cs.z = sqrt(abs(cs.z));
// 	cs.z = pow(cs.z, 1.0f/2.0f);
// 	cs.z = pow(cs.z, 1.0f/4.0f);
	
	cs.xy -= cs.xy * vec2(1.0f / V_volume_size.xy);//compensate for difference to between texel addressing and linear texture filtering
	cs.z -= uv2clip(cs.z) * 0.5f / V_volume_size.z;
	
	vec3 uv = clipZ2uv(cs);
// 	uv = saturate(uv);
	return uv;
}

vec3 volume_cellsize(vec3 uv)//TODO @Timon optimize, if needed with a precomputed matrix or something
{
	vec3 v0 = volume2view(uv);
	uv.xy += 1.0f / V_volume_size.xy;
	uv.z -= 1.0f / V_volume_size.z;
	vec3 v1 = volume2view(uv);
	return v1 - v0;
}

float cellsize_fadefactor(vec3 cellsize, float size)
{
// 	float fade = saturate(size * 0.5f - length(cellsize));
	float fade = saturate(size * 0.5f - cellsize.z);
	return fade;
}

float volume_getfadefactor(float viewz, float size)
{
/*	z = 0.1f / z; //TODO @Timon camera near-dist
	z -= F_volume_off;
	z /= F_volume_scale;
	z = sqrt(z);
	
	z -= 1.0f / V_volume_size.z;
	
	z *= z;
	z *= F_volume_scale;
	z += F_volume_off;
	z = 0.1f / z; //TODO @Timon camera near-dist
	/**/
// 	return 0.0;
	float n = 800 * size / 200;
	float f = 1400 * size / 200;
	n = min(n, V_volume_range[1] - min(size, V_volume_range[1] / 4));
	f = min(f, V_volume_range[1]);
	return smoothstep(n, f, viewz);
	
// 	float step = V_volume_range[1] - V_volume_range[0];
// 	step /= V_volume_size.z;
// 	float far = size;
// 	return smoothstep(, viewz);
/*	float volz = view2volume(viewz);
	volz -= 1.0f / V_volume_size.z;
	float nviewz = volume2view(volz);
	
	float dist = 0.1 / (0.1 / viewz + F_volume_scale / pow2(V_volume_size.z));	return saturate(size * 0.5 - abs(dist));
	
	return saturate(size * 0.5 - abs(nviewz - viewz));/**/
// 	return fade;
}

//-------------------------------------------------------------------------------
// Lighting/Shadow defines ( used in vertex + pixel shaders )
//-------------------------------------------------------------------------------

#define USE_TEXTURE_LIGHTING /**/
#define DEF_LIGHT_AMBIENT(_NR) /**/
#define DEF_LIGHT_DIR(_NR) /**/

#define B_material_override false
#define B_globallight_tonemap true
#define V_matparams vec4(0.5f)
#define V_deferred_lightparams vec4(1)
#define F_arealightcutoff 0.001f

#ifdef PROJECT_XR
	#define XR_TO_linearRGB(val)	TO_linearRGB(val)
#else
	#define XR_TO_linearRGB(val)	(val)
#endif

#include <jon_mod_defines.h>
#include <jon_mod_util_functions.h>/////////////////////////// JON MOD UTIL FUNCTIONS //////////////////////
//Included in the start of gbuffer_access.h, that is included most anywhere
void PackMetalSubsurface(inout float Metal, in float Subsurface)
{
	#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
		if(GetFragUV().x > 0.5)
		{		
	#endif
			//Metal and Subsurface are natureally mutually exclusice, so we can pack both in metal
		//	Subsurface *= (1.0 - saturate(Metal * 256.0 - 4.0));//DDS compression could mess worst case 4 rbg scale steps, so makes sure to nix very low metal!
			const float dds_bias = -4.0/256.0;
			const float dds_boost = 1.0 / dds_bias;
			Metal = saturate(Metal * dds_boost + dds_bias);
			Metal = (Metal * 0.5) + (0.5 - Subsurface * 0.5);
	#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
		}
	#endif

}
void PackMetal(inout float Metal)
{
	#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
		//Metal and Subsurface are natureally mutually exclusice, so we can pack both in metal
		#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
			if(GetFragUV().x > 0.5)
		#endif
			Metal = (Metal * 0.5) + 0.5;		
	#endif
}

void UnpackMetalSubsurface(inout float Metal, inout float Subsurface)
{
	#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
		#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
			if(GetFragUV().x > 0.5)
			{		
		#endif
			//Metal and Subsurface are natureally mutually exclusice, so we can pack both in metal
			Subsurface = max(0.0, 1.0 - Metal * 2.0);
			Metal = max(0.0, Metal * 2.0 - 1.0);
		#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
			}
		#endif
	#endif
}
void MetalStrict(inout float Metal)
{
	#ifdef JON_MOD_ENFORCE_STRICT_METALLIC
		#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
			if(GetFragUV().x > 0.5)
			{		
				Metal = smoothstep(0.25, 0.75, Metal);
			}
			else
			{
				Metal = Metal;
			}
		#else
			Metal = smoothstep(0.25, 0.75, Metal);
		#endif
	#endif
}
void RoughnessRemapSmoothVersion(inout float Smooth)
{
	#ifdef JON_MOD_ROUGHNESS_REMAP
		#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
			if(GetFragUV().x > 0.5)
			{		
				Smooth = 1.0 - pow2((1.0 - Smooth) * (1.0 - JON_MOD_ROUGHNESS_REMAP_PRE_SQUARE_RANGE) + JON_MOD_ROUGHNESS_REMAP_PRE_SQUARE_RANGE);
			}
			else
			{
				Smooth = Smooth;
			}
		#else
			Smooth = 1.0 - pow2((1.0 - Smooth) * (1.0 - JON_MOD_ROUGHNESS_REMAP_PRE_SQUARE_RANGE) + JON_MOD_ROUGHNESS_REMAP_PRE_SQUARE_RANGE);
		#endif
	#endif
}////////////////// JON MOD HOLODECK //////////////////
//Included in the very end of common.h, that is included most anywhere
/*
	Comment out to enable or disable. Change variable after define if relevant to tweak. 
	Indented #defines means the top non indeted one need to be one for them to work
	Have fun!
*/

//#define JON_MOD_SPECULAR_OVERSHOOT_FIX //default on, fixes geometric light white bright artefact
#define JON_MOD_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE //default on

#define JON_MOD_ROUGHNESS_REMAP // default on. Disney trick, since artists has a tendency to overuse the lower end of the roughness and neglect nuances in the high end, this one does a gentle remap improving both!
#define JON_MOD_ROUGHNESS_REMAP_PRE_SQUARE_RANGE 0.4142f//default 0.4142f, at this point 0.5 = 0.5, 0 = 0.17 1=1


// Human skin lowest index of refraction(IOR)1.35 = 0.28 in unreal specular, or #47, rgb71, 28%brightness, as linear color
// Human skin highest index of refraction(IOR)1.55 = 0.58 in unreal specular, or #94, rgb148, 58%brightness, as linear color
// Human hair(and nails technically too) highest index of refraction(IOR)1.55 = 0.58 in unreal specular, or #94, rgb148,
// Specular scale is 0.08, so (0.28 * 0.08), etc...
//#define JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
//	#define JON_MOD_SUBSURFACE_SUBDERMAL_ROUGHNESS 0.5
//	#define JON_MOD_SUBSURFACE_EPIDERMAL_ROUGHNESS -0.1
//	#define JON_MOD_SUBSURFACE_EPIDERMAL_F0 0.0224f

#define JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL//This upgrades EvalBRDF() to include this https://advances.realtimerendering.com/s2018/MaterialAdvancesInWWII-course_notes.pdf Which UE5 also uses.
	#define JON_MOD_USE_AMBIENT_DIFFUSE_TRICKS
	#define JON_MOD_USE_AMBIENT_SPECULAR_TRICKS
	#define JON_MOD_USE_AMBIENT_SPECULAR_TRICKS_PROBE_VERSION //don't know if this needs it since it already parallax corrects. Now it can be turned off seperately.
	
#define JON_MOD_USE_LUMINANCE_FRESNEL
	#define JON_MOD_USE_STRICTER_N_DOT_V

#define JON_MOD_SSSHADOWS //default on
	//near and far
	#define JON_MOD_SSSHADOWS_SUPPORT_BOTH_PRIMARY_LIGHTS //default on
	#define JON_MOD_SSSHADOWS_MAX_STEPS 64 //default 64, it's pretty rare to ever go this high be aware this is a times 2
	//far
	#define JON_MOD_SSSHADOWS_FADE_DISTANCE 5000.0 //not all PCF shadows have the same distance, so some lods will still shadow pop if we just use that, so with this we can enforce a max distance where everything will use Screenspace Shadows
	#define JON_MOD_SSSHADOWS_DITHER 1.0 //default 1
	#define JON_MOD_SSSHADOWS_RAY_MAX_DISTANCE 100.0 //default 100.0 = 100.0m distance. I think 1 is about 10cm, so a hundred meters is 10000
	#define JON_MOD_SSSHADOWS_BIAS 10.0 //default 10.0 = 1.0m
	#define JON_MOD_SSSHADOWS_MAX_THICKNESS 1000.0 //default 1000.0 = 100.0m shadows thicker than this from the camera are ignored, so as to things near ain't casting shadows on things far
	//near
	#define JON_MOD_SSSHADOWS_RAY_MAX_DISTANCE_NEAR 0.25 //default 25cm
	#define JON_MOD_SSSHADOWS_BIAS_NEAR 0.1 //0.5cm
	#define JON_MOD_SSSHADOWS_MAX_THICKNESS_NEAR 0.2 //2cm
	#define JON_MOD_SSSHADOWS_FADE_DISTANCE_NEAR 10.0 // 10.0m
	#define JON_MOD_SSSHADOWS_ATTENUATION_NEAR 1.0 //optional soft fade near shadows
	//filtering
	#define JON_MOD_SSSHADO_FILTER // filters with screenspace derivatives, might give very different result at different resolution
//pending implementation
//#define JON_MOD_SSSHADOWS_POINTLIGHTS

//debugs
//#define JON_MOD_SSSHADOWS_DEBUG_MODE
//#define JON_MOD_SSSHADOWS_LIGHT_TO_DEBUG 0 //options are 0 or 1 only!

//#define JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN

#define INVPI 	(0.318309886f)
////////////////// JON MOD LIGHTING FUNCTIONS //////////////////
//Included right before global_lights() in common.fh, that is included in all lighting code
// as well as in the start of lighting_common.h

#ifndef _JON_MOD_LIGHTING_FUNCTIONS_
//L we have to trasnform to view space
float ScreenSpaceShadows(	in vec3 light_ray, 
							in vec2 cascade_blend, 
							inout vec3 debug, 
							in int i)	
{
	float step_size = 1.0 / float(JON_MOD_SSSHADOWS_MAX_STEPS);
	
	// Compute ray step
	vec3 ray_step = light_ray * step_size * max(JON_MOD_SSSHADOWS_RAY_MAX_DISTANCE_NEAR, JON_MOD_SSSHADOWS_RAY_MAX_DISTANCE * cascade_blend.y);
	
	// Ray march towards the light
	float shadow = 0.0;
	vec2 ray_uv = vec2(0.0);
	vec2 fade = vec2(0.0);

	vec3 ray_pos = GetViewPos();
	float2 aspect = float2(0.5, -0.5 * V_viewportpixelsize.x / V_viewportpixelsize.y);

	//different ways of getting what we need
	//debug = fract(vec3(1.0 / vec2(GetDepth(GetFragUV()), GetDepth()), GetViewPos().z * 10.0));//why 10?
	//works too
	//debug = fract(vec3(1.0 / vec2(GetDepth((ray_pos.xy / ray_pos.z) * aspect + 0.5), GetDepth()), GetViewPos().z * 10.0));//why 10?
	
	float depth = (ray_pos.z * 10.0);
	vec2 dither = hash22(gl_FragCoord.xy);
	vec2 texel_size = (1.0 / V_viewportpixelsize.xy);
	float thickness_threshold = max(JON_MOD_SSSHADOWS_MAX_THICKNESS_NEAR, JON_MOD_SSSHADOWS_MAX_THICKNESS * ceil(cascade_blend.y));
	float depth_bias = max(JON_MOD_SSSHADOWS_BIAS_NEAR * (1.0 + depth * 0.001), JON_MOD_SSSHADOWS_BIAS * ceil(cascade_blend.y));
	float attenuation = ceil(cascade_blend.x) * step_size * JON_MOD_SSSHADOWS_ATTENUATION_NEAR;
	
	for (uint i = 0; i < JON_MOD_SSSHADOWS_MAX_STEPS; i++)
	{
		// Step the ray
		ray_pos -= ray_step;
		ray_uv = ray_pos.xy / ray_pos.z;

		fade = abs(ray_uv);
		
		// Ensure the UV coordinates are inside the screen
		if(max(fade.x, fade.y) > 1.0)
			break;
		
		float depth_step = 1.0 / GetDepth(ray_uv * aspect + 0.5 + uv2clip(fract(dither)) * texel_size);
		dither += step_size;
		float depth_delta = ray_pos.z * 10.0 - depth_step - depth_bias;
		
		if(depth_delta > 0.0 && depth_delta <  thickness_threshold)
		{
			// Fade out as we approach the edges of the screen
			fade				= 1.0 - saturate(fade * 100.0 - 99.0);
			shadow				= min(fade.x, fade.y);
			shadow				= 1 - attenuation * i;
			break;
		}

	}
	#ifdef JON_MOD_SSSHADOWS_DEBUG_MODE
		if(i == JON_MOD_SSSHADOWS_LIGHT_TO_DEBUG)
			debug.y = shadow;
	#endif
	
	return 1.0 - shadow * (cascade_blend.x + cascade_blend.y);
}

// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
// Similar to UE4/5 but with actual luminance, since that's a nice touch, rather than just cspec.g
vec3 schlick_f(vec3 cspec, float v_dot_h)
{
	float f = pow5(1.0 - v_dot_h);
	#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
		if(GetViewPos().x < 0.0)
			return f + (1-f) * cspec;
	#endif	
	return min(50.0 * dot(LUM_ITU601, cspec), 1.0) * f + (1.0 - f) * cspec;
}
// https://advances.realtimerendering.com/s2018/index.htm
// It has been extended here to fade out retro reflectivity contribution from area light in order to avoid visual artefacts.
vec3 chan_diff(vec3 cdiff, float a2, float n_dot_v, float n_dot_l, float v_dot_h, float n_dot_h, float arealight_weight, vec3 cspec)
{
	float g = saturate((1.0 / 18.0) * log2(2.0 / a2 - 1.0));
	
	float f0 = (v_dot_h + pow5(1.0 - v_dot_h));
	float fdv = (1.0 - 0.75 * pow5(1.0 - n_dot_v));
	float fdl = (1.0 - 0.75 * pow5(1.0 - n_dot_l));

	// Rough (f0) to smooth (fdv * fdv) response interpolation
	float fd = mix(f0, fdv * fdl, saturate(2.2 * g - 0.5));
	
	// Retro reflectivity contribution.
	float fb = ((34.5 * g - 59.0) * g + 24.5) * v_dot_h * exp2(-max(73.2 * g - 21.2, 8.9) * sqrt(n_dot_h));
	
	// It fades out when lights become area lights in order to avoid visual artefacts.
	fb *= arealight_weight;
	
	#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
		if(GetViewPos().x < 0.0)
			return cdiff * (1.0 / PI) * saturate(1.0f - dot(LUM_ITU601, cspec));
	#endif
		
	return cdiff * (INVPI * (fd + fb));
	
}
// https://iryoku.com/downloads/Practical-Realtime-Strategies-for-Accurate-Indirect-Occlusion.pdf
vec3 muli_bounce_ambient_occlusion(vec3 cdiff, float ambient_occlusion)
{

	vec3 a = 2.0404 * cdiff - 0.3324;
	vec3 b = -4.7951 * cdiff + 0.6417;
	vec3 c = 2.7552 * cdiff + 0.6903;
	return max(vec3(ambient_occlusion), ((ambient_occlusion * a + b) * ambient_occlusion + c) * ambient_occlusion);
}
// Point lobe in off-specular peak direction and specular occlusion from Unreal - but they got it from somwhere else, forgotten where, think I first encountered it in a Marmoset IBL article, that heavily quated the Frostbite PBR paper...?
vec3 off_specular_peak(vec3 normal, vec3 reflection, float roughness_sr)
{
	return mix(normal, reflection, (1.0 - roughness_sr) * (sqrt(1.0 - roughness_sr) + roughness_sr));	
}
float get_specular_occlusion(float n_dot_v, float roughness_sr, float ambient_occlusion)
{
	return clamp(pow(n_dot_v + ambient_occlusion, roughness_sr) - 1.0 + ambient_occlusion, 0.0, 1.0);
}

int max_spec_level_less_strict(samplerCube filtered_env_map)
{
	return textureQueryLevels(filtered_env_map) - 3;//Egosoft, You had -2 in yours, that's 4x4 pixels. I would not recommend at least 8x8
}


vec3 combined_ambient_brdf(samplerCube filtered_env_map, vec3 cspec, vec3 cdiff, vec3 normal, vec3 view, float roughness, float ambient_occlusion, vec4 ssr, vec3 flat_diffuse_addition)
{
	int lowest_mip = max_spec_level_less_strict(filtered_env_map);
	float n_dot_v = dot(normal, view);
	vec3 reflection = view - 2.0 * normal * n_dot_v;//view and normal are both normalized, so we don't need to too.
	n_dot_v = max(0.0, n_dot_v);
	//chan_diffuse is now baked into to T_preintegrated_GGX b channel
	vec3 env_brdfs = textureLod(T_preintegrated_GGX, vec2(roughness, n_dot_v), 0).xyz;
	
	float roughness_sr = roughness * roughness;
	#ifdef JON_MOD_USE_AMBIENT_SPECULAR_TRICKS
		reflection = off_specular_peak(normal, reflection, roughness_sr);
	#endif
	vec4 specular_ibl = textureLod(filtered_env_map, reflection, lowest_mip * sqrt(roughness));
	vec3 ambient_specular = mix(specular_ibl.rgb, ssr.rgb, ssr.a);

	ambient_specular *= (cspec * env_brdfs.x + min(dot(LUM_ITU601, cspec) * 50.0, 1.0) * env_brdfs.y);
	#ifdef JON_MOD_USE_AMBIENT_SPECULAR_TRICKS
		ambient_specular *= get_specular_occlusion(n_dot_v, roughness_sr, ambient_occlusion);
	#else
		ambient_specular *= ambient_occlusion;
	#endif

	vec3 ambient_diffuse = textureLod(filtered_env_map, normal, lowest_mip).rgb + flat_diffuse_addition;
	#ifdef JON_MOD_USE_AMBIENT_SPECULAR_TRICKS
		ambient_diffuse *= (cdiff * muli_bounce_ambient_occlusion(cdiff, ambient_occlusion)) * env_brdfs.b;	
	#else
		ambient_diffuse *= ambient_occlusion;
	#endif
	return ambient_specular + ambient_diffuse;
}

//l_pass_envmap_probe.f version
vec4 combined_ambient_probe_brdf(samplerCube filtered_env_map, vec3 cspec, vec3 cdiff, vec3 normal, vec3 view, vec3 reflection, float roughness, float ambient_occlusion, float ssr_alpha)
{
	int lowest_mip = max_spec_level_less_strict(filtered_env_map);
	float n_dot_v = dot(normal, view);

	n_dot_v = max(0.0, n_dot_v);
	//chan_diffuse is now baked into to T_preintegrated_GGX b channel
	vec3 env_brdfs = textureLod(T_preintegrated_GGX, vec2(roughness, n_dot_v), 0).xyz;
	
	float roughness_sr = roughness * roughness;
		
	#ifdef JON_MOD_USE_AMBIENT_SPECULAR_TRICKS_PROBE_VERSION
		reflection = off_specular_peak(normal, reflection, roughness_sr);
	#endif
	vec4 ambient_specular = textureLod(filtered_env_map, reflection, lowest_mip * sqrt(roughness));
	return vec4(0.0);

	ambient_specular.rgb *= (1.0 - ssr_alpha);
	ambient_specular.rgb *= (cspec * env_brdfs.x + min(dot(LUM_ITU601, cspec) * 50.0, 1.0) * env_brdfs.y);
	
	#ifdef JON_MOD_USE_AMBIENT_SPECULAR_TRICKS
		ambient_specular.rgb *= get_specular_occlusion(n_dot_v, roughness_sr, ambient_occlusion);
	#else
		ambient_specular.rgb *= ambient_occlusion;
	#endif

	vec3 ambient_diffuse = textureLod(filtered_env_map, normal, lowest_mip).rgb;
	#ifdef JON_MOD_USE_AMBIENT_SPECULAR_TRICKS
		ambient_diffuse *= (cdiff * muli_bounce_ambient_occlusion(cdiff, ambient_occlusion)) * env_brdfs.b;	
	#else
		ambient_diffuse *= ambient_occlusion;
	#endif
	return vec4(ambient_specular.rgb + ambient_diffuse, ambient_specular.a);

}

#define _JON_MOD_LIGHTING_FUNCTIONS_
#endif
/////////////////////////// JON MOD UTIL FUNCTIONS //////////////////////
//Included in the very end of common.h, that is included most anywhere
/*
Egosoft already got this one! and we inject after it's defined!
float pow2(float x)
{
	return x*x;
}
*/
float pow4(float x)
{
	return pow2(pow2(x));
}
float pow5(float x)
{
	return pow4(x)*x;
}
// from https://blog.selfshadow.com/publications/blending-in-detail/
//nice angle corrected blend
vec3 blend_reoriented_normals(vec3 n1, vec3 n2)
{

	n1 = vec3(n1.xy, n1.z + 1.0);
	n2 = vec3(-n2.xy, n2.z);

    return normalize(n1 * dot(n1, n2) - n2 * n1.z);
}

// Hash without Sine
// MIT License...
/* Copyright (c)2014 David Hoskins.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.*/

//----------------------------------------------------------------------------------------
// https://www.shadertoy.com/view/4djSRW
//  1 out, 1 in...
float hash11(float p)
{
    p = fract(p * .1031);
    p *= p + 33.33;
    p *= p + p;
    return fract(p);
}

//----------------------------------------------------------------------------------------
//  1 out, 2 in...
float hash12(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

//----------------------------------------------------------------------------------------
//  1 out, 3 in...
float hash13(vec3 p3)
{
	p3  = fract(p3 * .1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return fract((p3.x + p3.y) * p3.z);
}
//----------------------------------------------------------------------------------------
// 1 out 4 in...
float hash14(vec4 p4)
{
	p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.x + p4.y) * (p4.z + p4.w));
}

//----------------------------------------------------------------------------------------
//  2 out, 1 in...
vec2 hash21(float p)
{
	vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx+p3.yz)*p3.zy);

}

//----------------------------------------------------------------------------------------
///  2 out, 2 in...
vec2 hash22(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return fract((p3.xx+p3.yz)*p3.zy);

}

//----------------------------------------------------------------------------------------
///  2 out, 3 in...
vec2 hash23(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx+33.33);
    return fract((p3.xx+p3.yz)*p3.zy);
}

//----------------------------------------------------------------------------------------
//  3 out, 1 in...
vec3 hash31(float p)
{
   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));
   p3 += dot(p3, p3.yzx+33.33);
   return fract((p3.xxy+p3.yzz)*p3.zyx); 
}


//----------------------------------------------------------------------------------------
///  3 out, 2 in...
vec3 hash32(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy+p3.yzz)*p3.zyx);
}

//----------------------------------------------------------------------------------------
///  3 out, 3 in...
vec3 hash33(vec3 p3)
{
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy + p3.yxx)*p3.zyx);

}

//----------------------------------------------------------------------------------------
// 4 out, 1 in...
vec4 hash41(float p)
{
	vec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
    
}

//----------------------------------------------------------------------------------------
// 4 out, 2 in...
vec4 hash42(vec2 p)
{
	vec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);

}

//----------------------------------------------------------------------------------------
// 4 out, 3 in...
vec4 hash43(vec3 p)
{
	vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
}

//----------------------------------------------------------------------------------------
// 4 out, 4 in...
vec4 hash44(vec4 p4)
{
	p4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));
    p4 += dot(p4, p4.wzxy+33.33);
    return fract((p4.xxyz+p4.yzzw)*p4.zywx);
}#include <jon_mod_buffer_encoding_functions.h>
// #define USE24BITNORMALCOMPRESSION

//Lambert Azimuthal Equal-Area Projection
vec2 EncodeNormalLA(vec3 n)
{
	float p = sqrt(-n.z * 8 + 8);
	return n.xy / p + 0.5;
}
vec3 DecodeNormalLA(vec2 n)
{
	vec2 fenc = n * 4 - 2;
	float f = dot(fenc,fenc);
	float g = sqrt(1 - f/4);
	return vec3(fenc * g, f/2 - 1);
}

//Stereographic Projection
const float Normal_Stereographic_Scale = 0.3;	//TODO @Timon optimize for quality, keep in mind it affects normal blending for complex_projection*
//WARNING: if these are changed ffx_cacao_bindings.hlsl needs to be adjusted as well
float2 EncodeNormalSG(float3 n)
{
	float2 ret = n.xy / (1 - n.z);
	ret /= Normal_Stereographic_Scale;
//	return ret / 2 + 0.5;
	return ret;
}
float3 DecodeNormalSG(float2 n)
{
//	float3 ret = float3(n * 2 * Normal_Stereographic_Scale - Normal_Stereographic_Scale, 1);
	float3 ret = float3(n * Normal_Stereographic_Scale, 1);
	float g = 2.0 / dot(ret, ret);
	ret.xy *= g;
	ret.z = g - 1;
	ret.z = -ret.z;
	return ret;
}

#if 0

vec2 pack16(float value){
    float f = clamp(value, 0.0, 1.0)*255.0;
    float digitLow = fract(f);
    float digitHigh = floor(f)/255.0;
    return vec2(digitHigh, digitLow);
}       
    
float unpack16(vec2 value){
    return value.x+value.y/255.0;
}

vec4 packNormal32(in vec3 n) {
    vec2 spheremapped = encode(n);
	//return vec4(n, 1);
	return vec4(spheremapped, 0, 0);
    // return vec4(pack16(spheremapped.x), pack16(spheremapped.y));
}
vec3 unpackNormal32(in vec4 data) {
	//return data.xyz;
	return normalize(decode(data.x, data.y));
    // return normalize(decode(unpack16(data.xy), unpack16(data.zw)));
}

// Crytek BFN
//vec3 packBestFitNormal(in vec3 n) {
//    vec3 np = n.xyz;
//    // vec3 np = n.xyz*2-1;
//    np = normalize(np);
//    vec3 nu = abs(np);
//    float maxNU = max(nu.z, max(nu.x, nu.y));
//    vec2 uv = nu.z < maxNU ? (nu.y < maxNU ? nu.yz : nu.xz) : nu.xy; 
//    uv = uv.x < uv.y ? uv.yx : uv.xy;
//    uv.y /= uv.x;
//    np /= maxNU;
//    // float scale = pow(texture(T_normalfittex, uv).r, 1.0f/2);
//     //uv.y = 1- uv.y;
//    // float scale = texture(T_normalfittex, uv.xy + vec2(1.0f/256.0f)).r;
//    float scale = textureLod(T_normalfittex, uv.xy, 0).r;
//    np *= scale;
//    // return np;
//    np = np * 0.5 + 0.5;
//
//    // np = TO_linearRGB(vec4(np, 0)).xyz;
//
//    return np;
//    // return np * 0.5 + 0.5; // store unsigned
//}
//vec3 unpackBestFitNormal(in vec3 n) {
//	return normalize(n * 2 - 1);
//}
// octahedral normal encoding (http://jcgt.org/published/0003/02/01/paper.pdf)
float signNotZero(in float k) {
	return k >= 0.0 ? 1.0 : -1.0;
}
vec2 signNotZero(in vec2 v) {
	return vec2(signNotZero(v.x), signNotZero(v.y));
}
vec2 octEncode(in vec3 v) {
	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
	vec2 result = v.xy * (1.0 / l1norm);
	if (v.z < 0.0) {
		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
	}
	return result;
}

vec3 twoNorm12sEncodedAs3Unorm8sInVec3Format(vec2 s) {
	vec3 u;
	u.x = s.x * (1.0 / 16.0);
	float t = floor(s.y*(1.0 / 256));
	u.y = (frac(u.x) * 256) + t;
	u.z = s.y - (t * 256);
	// Instead of a floor, you could just add vec3(-0.5) to u, 
	// and the hardware will take care of the flooring for you on save to an RGB8 texture
	return floor(u) * (1.0 / 255.0);
}

float packSnorm12Float(float f) {
	return round(clamp(f + 1.0, 0.0, 2.0) * float(2047));
}
vec3 vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format(vec2 v) {
	vec2 s = vec2(packSnorm12Float(v.x), packSnorm12Float(v.y));
	return twoNorm12sEncodedAs3Unorm8sInVec3Format(s);
}
vec3 encodeOct(in vec3 v) {
#ifndef USE24BITNORMALCOMPRESSION
	return v;
#endif
	return vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format(octEncode(v));
}

// octahedral normal decoding
vec3 finalDecode(float x, float y) {
	vec3 v = vec3(x, y, 1.0 - abs(x) - abs(y));
	if (v.z < 0) {
		v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
	}
	return normalize(v);
}
vec2 twoNorm12sEncodedAsUVec3InVec3FormatToPackedVec2(vec3 v) {
	vec2 s;
	// Roll the (*255s) in during the quasi bit shifting. This causes two of the three multiplications to happen at compile time
	float temp = v.y * (255.0 / 16.0);
	s.x = v.x * (255.0*16.0) + floor(temp);
	s.y = fract(temp) * (16 * 256) + (v.z * 255.0);
	return s;
}

float unpackSnorm12(float f) {
	return clamp((float(f) / float(2047)) - 1.0, -1.0, 1.0);
}
float unpackSnorm12(uint u) {
	return unpackSnorm12(float(u));
}
vec2 twoSnorm12sEncodedAsUVec3InVec3FormatToVec2(vec3 v) {
	vec2 s = twoNorm12sEncodedAsUVec3InVec3FormatToPackedVec2(v);
	return vec2(unpackSnorm12(s.x), unpackSnorm12(s.y));
}
vec3 decodeOct(in vec3 p) {
#ifndef USE24BITNORMALCOMPRESSION
	p = normalize(p);	// the normals often aren't normal enough
	return p;
#endif
	vec2 v = twoSnorm12sEncodedAsUVec3InVec3FormatToVec2(p);
	return finalDecode(v.x, v.y);
}

// Most precise compression, only used for debug
vec2 octPEncode(in vec3 v) {
    float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
    vec2 result = v.xy * (1.0/l1norm);
    if (v.z < 0.0) {
        result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
    }
    return result;
}
vec2 encodeIntoSnorm12sStoredAsVec2(vec3 v) {
    vec3 normv = normalize(v);
    vec2 s = octPEncode(normv);
    s = floor(clamp(s, -1.0, 1.0) * 2047 ) * ( 1.0 / 2047 );

    // Prime the loop
    vec2 bestRepresentation = s;
    float highestCosine = dot(finalDecode(s.x, s.y), normv);
    for (int i = 0; i < 2; ++i) {
            for (int j = 0; j < 2; ++j) {
                // This branch will be evaluated at compile time
                if ( (i != 0) || (j != 0) ) {
                    vec2 candidate = vec2(i,j) * (1.0 / 2047 ) + s;
                    vec3 roundTrip = finalDecode(candidate.x, candidate.y);

                    float cosine = dot(roundTrip, normv);
                    if (cosine > highestCosine) {
                        bestRepresentation = candidate;
                        highestCosine      = cosine;
                    }
                }
            }
    }
    return bestRepresentation;
}
vec3 encodeOct2(in vec3 v) {
    return vec2To2Snorm12sEncodedAs3Unorm8sInVec3Format(encodeIntoSnorm12sStoredAsVec2(v));
}

#endif

//WARNING: if these are changed ffx_cacao_bindings.hlsl needs to be adjusted as well
void UniWriteNormal(out vec4 col, vec3 normal)
{
	normal = mat3(M_view) * normal;
	col.xyz = normal;
//	col.xy = EncodeNormalLA(normal);
	col.xy = EncodeNormalSG(normal);
// 	col.z = 0;
}
void UniReadNormal(vec4 col, out vec3 normal)
{
	normal = col.xyz;
// 	normal = NormalReZ(normal);
//	normal = DecodeNormalLA(col.xy);
	normal = DecodeNormalSG(col.xy);
//	normal = mat3(M_view) * col.xyz;
}

void UniReadNormalRaw(vec4 col, out vec3 normal)
{
	normal = col.xyz;
// 	normal = NormalReZ(normal);
//	normal = DecodeNormalLA(col.xy);
	normal = DecodeNormalSG(col.xy);
	normal = mat3(M_viewinverse) * normal;
}

/************************************************************************
    Position from zbuffer
************************************************************************/

void RetrieveZBufferViewPos(out vec3 view_pos, in vec2 uv)
{
    // todo: somehow make sure that this is nooped when z writes are enabled
    if(!B_deferred_draw)
	{
#ifdef OVERRIDE_DEPTH
        vec4 p = M_invprojection * vec4(uv*2-1, RTResolve(OVERRIDE_DEPTH, uv).r, 1);
#else
        vec4 p = M_invprojection * vec4(uv*2-1, RTResolve(T_zdepth, uv).r, 1);
#endif
        view_pos = p.xyz / p.w;
    }
}

void RetrieveZBufferViewPos(out vec3 view_pos)
{
//	RetrieveZBufferViewPos(view_pos, gl_FragCoord.xy / V_viewportpixelsize.xy);
	//TODO @Timon the above doesn't work when rendering with a smaller viewport (most RenderTargets),
	//iirc the above is only used by ssao so maybe refactor to use a generic version with an offset? or something
	if(!B_deferred_draw) {
#ifdef OVERRIDE_DEPTH
		vec4 p = M_invprojection * vec4(gl_FragCoord.xy / V_viewportpixelsize.xy*2 - 1, RTResolve(OVERRIDE_DEPTH).r, 1);
#else
		vec4 p = M_invprojection * vec4(gl_FragCoord.xy / V_viewportpixelsize.xy*2 - 1, RTResolve(T_zdepth).r, 1);
#endif
		view_pos = p.xyz / p.w;
	}
}

/************************************************************************
	GBUFFER access
************************************************************************/

// full gbuffer read, mainly for ssr
#define RETRIEVE_GBUFFER(NORMAL, BASECOLOR, METAL, SMOOTH) \
{ \
	RETRIEVE_GBUFFER_NORMAL0(NORMAL); \
	RETRIEVE_GBUFFER_BASECOLOR(BASECOLOR); \
	RETRIEVE_GBUFFER_METAL_SMOOTH(METAL, SMOOTH); \
}

#define RETRIEVE_GBUFFER_NORMAL0(NORMAL0) \
{ \
	vec4 data0 = RTResolve(T_gbuffer3); \
	UniReadNormal(data0, NORMAL0);	\
}

#define RETRIEVE_GBUFFER_BASECOLOR(BASECOLOR) \
{ \
	vec4 data1 =  RTResolve(T_gbuffer2); \
	BASECOLOR.rgb = data1.rgb; \
}
#define RETRIEVE_GBUFFER_METAL_SMOOTH(METAL, SMOOTH) \
{ \
	vec4 data =  RTResolve(T_gbuffer4); \
	SMOOTH = data.r; \
	METAL = data.g; \
}

#define RETRIEVE_GBUFFER_UV_NORMAL0(UV, NORMAL0) \
{ \
	vec4 data = RTResolve(T_gbuffer3, UV); \
	UniReadNormal(data, NORMAL0);	\
}

#define RETRIEVE_GBUFFER_UV_SMOOTH(UV, SMOOTH) \
{ \
	vec4 data = RTResolve(T_gbuffer4, UV); \
	SMOOTH = data.r; \
}

#define RETRIEVE_GBUFFER_UV_NORMAL0_SMOOTH(UV, NORMAL0, SMOOTH) \
{ \
	vec2 _uv = (UV);			\
	RETRIEVE_GBUFFER_UV_NORMAL0(_uv, NORMAL0)	\
	RETRIEVE_GBUFFER_UV_SMOOTH(_uv, SMOOTH)	\
}


/************************************************************************
	legacy gbuffer access
************************************************************************/
// depending on final gbuffer layout, cherry picked access

void RetrieveGBufferNormal(out vec3 normal, in vec2 uv) {
	normal = vec3(0,0,1);
    if(!B_deferred_draw) {
		RETRIEVE_GBUFFER_UV_NORMAL0(uv, normal);
    }
}

// mainly for compability with code using old gbuffer layout
void RetrieveGBufferNormalViewZ(out vec3 normal, out float view_z, in vec2 uv) {
	normal = vec3(0,0,1);
	view_z = 0;
    // deferred draws are not allowed to read g/zbuffer
    if(!B_deferred_draw) {
        vec3 view_pos;
        RetrieveZBufferViewPos(view_pos, uv);
        view_z = view_pos.z;
		RETRIEVE_GBUFFER_UV_NORMAL0(uv, normal);
    }
}

// mainly for compability with code using old gbuffer layout
void RetrieveGBufferViewZ(out float view_z) {
    view_z = 0;
    // todo: check if this is problematic for transparent draws with z write
    // maybe use downsampled depth?
    if(!B_deferred_draw) {
        vec3 view_pos;
        RetrieveZBufferViewPos(view_pos);
        view_z = view_pos.z;
    }
}

/************************************************************************
	Renderpass input gbuffer access
************************************************************************/

#ifdef MAIN_MSAA
vec4 RI_SubpassLoad(in subpassInputMS inputattachment)
{
	#ifdef PER_SAMPLE
	return subpassLoad(inputattachment, gl_SampleID);
	#else
	return subpassLoad(inputattachment, 0);
	#endif
}
#else
vec4 RI_SubpassLoad(in subpassInput inputattachment)
{
	return subpassLoad(inputattachment);
}
#endif

#define RI_GBUFFER(NORMAL, BASECOLOR, METAL, SMOOTH) \
{ \
	RI_GBUFFER_NORMAL0(NORMAL); \
	RI_GBUFFER_BASECOLOR(BASECOLOR); \
	RI_GBUFFER_METAL_SMOOTH(METAL, SMOOTH);	\
}

#define RI_GBUFFER_RAW(NORMAL, BASECOLOR, METAL, SMOOTH) \
{ \
	RI_GBUFFER_NORMAL0_RAW(NORMAL); \
	RI_GBUFFER_BASECOLOR(BASECOLOR); \
	RI_GBUFFER_METAL_SMOOTH(METAL, SMOOTH);	\
}

#define RI_GBUFFER_NORMAL0(NORMAL0) \
{ \
	vec4 data0 = RI_SubpassLoad(Input_gbuffer3); \
	UniReadNormal(data0, NORMAL0);	\
}

#define RI_GBUFFER_NORMAL0_RAW(NORMAL0) \
{ \
	vec4 data0 = RI_SubpassLoad(Input_gbuffer3); \
	UniReadNormalRaw(data0, NORMAL0);	\
}

#define RI_GBUFFER_BASECOLOR(BASECOLOR) \
{ \
	vec4 data1 = RI_SubpassLoad(Input_gbuffer2); \
	BASECOLOR.rgb = data1.rgb; \
}

#define RI_GBUFFER_METAL_SMOOTH(METAL, SMOOTH) \
{ \
	vec2 data = RI_SubpassLoad(Input_gbuffer4).rg; \
	SMOOTH = data.r; \
	METAL = data.g; \
}

#define RI_GBUFFER_NORMAL_Z(DATA) RI_GBufferNormalViewZ(DATA.xyz, DATA.w);
void RI_GBufferNormalViewZ(out vec3 normal, out float view_z) {
	normal = vec3(0, 0, 1);
	view_z = 0;
	// deferred draws are not allowed to read g/zbuffer
	if (!B_deferred_draw) {
		vec3 view_pos;
		RetrieveZBufferViewPos(view_pos);
		view_z = view_pos.z;
		
		RI_GBUFFER_NORMAL0(normal);
	}
}

#define RI_GBUFFER_PBR(DATA) RI_GBufferPBR(DATA.x, DATA.y);
void RI_GBufferPBR(out float smoothness, out float metalness)
{
	RI_GBUFFER_METAL_SMOOTH(metalness, smoothness);
}

/************************************************************************
	OUTPUT thing
************************************************************************/
// let the engine choose between gbuffer output for full deferred lighting
// or simple mainlight lighting for non-deferred solids+transparents

#define STORE_GBUFFER(NORMAL, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	OUT_Color = vec4(GLOW, 1);				\
	OUT_Color1 = vec4(ALBEDO, 1);	\
	OUT_Color2 = vec4(0, 0, 0, 1);			\
	UniWriteNormal(OUT_Color2, NORMAL);		\
	OUT_Color3 = vec4(SMOOTH, METAL, 0, 1);			\
}

#define STORE_GBUFFERA(A, NORMAL, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	OUT_Color = vec4(GLOW, A);				\
	OUT_Color1 = vec4(ALBEDO, A);	\
	OUT_Color2 = vec4(0, 0, 0, A);			\
	UniWriteNormal(OUT_Color2, NORMAL);		\
	OUT_Color3 = vec4(SMOOTH, METAL, 0, A);	\
}

#define DEFERRED_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	STORE_GBUFFERA(A, N, ALBEDO, METAL, SMOOTH, GLOW); \
}

#define GENERAL_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
 	MetalStrict(METAL);	\
	PackMetal(METAL);	\
	RoughnessRemapSmoothVersion(SMOOTH);	\
   if (B_deferred_draw) { \
		DEFERRED_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW);	\
	} \
	else { \
		OUT_Color.a = (A); \
		OUT_Color.rgb = (GLOW) + global_lights(N, GetFragView(), ALBEDO, METAL, smooth2rough(SMOOTH), false); \
	} \
}

#define GENERAL_OUTPUT(N, ALBEDO, METAL, SMOOTH, GLOW) GENERAL_OUTPUTA(ColorBaseDiffuse.a * F_alphascale, N, ALBEDO, METAL, SMOOTH, GLOW)


#define DEFERRED_OVERLAY_ALPHA8(A, N_pp, ALBEDO, METAL, SMOOTH, GLOW) \
{ \
	MetalStrict(METAL);	\
	PackMetal(METAL);	\
	RoughnessRemapSmoothVersion(SMOOTH);	\
	OUT_Color = vec4(GLOW, 0);					\
	OUT_Color1 = vec4(ALBEDO, A);		\
	OUT_Color2 = vec4(CalcViewNormalOffset(N_pp), 0, A);	\
	OUT_Color3 = vec4(SMOOTH, METAL, 0, A);	\
}

#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING

	#define GENERAL_OUTPUTA_SUBSURFACE(A, N, ALBEDO, METAL, SUBSURFACE, SMOOTH, GLOW) \
	{ \
		MetalStrict(METAL);	\
		PackMetalSubsurface(METAL, SUBSURFACE);	\
		RoughnessRemapSmoothVersion(SMOOTH);	\
		if (B_deferred_draw) { \
			DEFERRED_OUTPUTA(A, N, ALBEDO, METAL, SMOOTH, GLOW);	\
		} \
		else { \
			OUT_Color.a = (A); \
			OUT_Color.rgb = (GLOW) + global_lights(N, GetFragView(), ALBEDO, METAL, smooth2rough(SMOOTH), false); \
		} \
	}
	
	#define GENERAL_OUTPUT_SUBSURFACE(N, ALBEDO, METAL, SUBSURFACE, SMOOTH, GLOW) GENERAL_OUTPUTA_SUBSURFACE(ColorBaseDiffuse.a * F_alphascale, N, ALBEDO, METAL, SUBSURFACE, SMOOTH, GLOW)
	
#endif#define P1_SHADERS
#include <common.fh>

#ifdef JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL
vec3 integrate_GGX_and_retroreflective_diffuse(float roughness, float n_dot_v)
{
  vec3 normal = vec3(0.0f, 0.0f, 1.0f);

  vec3 view = vec3(sqrt(1.0f - n_dot_v * n_dot_v), 0, n_dot_v);
  float a = 0.0f; float b = 0.0f; float c = 0.0f;
 #ifdef JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL
	CONST uint num_samples = 512u;//the diffuse needs a ton more samples - and the specular ones looks even better with more too!
#else
	CONST uint num_samples = 64u;//was 32
#endif	
  for(uint i=0u; i< num_samples; ++i)
  {
	vec2 uv = hammersley_2d(i, num_samples);
	
	vec3 half_dir = importance_sample_GGX(uv, roughness, normal);
	vec3 light = 2 * dot(view, half_dir) * half_dir - view;
	float n_dot_l = max(0.0f, light.z);
	// float n_dot_l = light.z;
	float n_dot_h = clamp(half_dir.z, 0.0f, 1.0f);
	// float n_dot_h = half_dir.z;
	float v_dot_h = clamp(dot(view, half_dir), 0.0f, 1.0f);
	// float v_dot_h = dot(view, half_dir);
	if( n_dot_l > 0.0f)
	// if( true )
	{
		
		float k = (roughness*roughness)/2;
		float G = G_Smith(k, n_dot_v, n_dot_l);
		// float G = G_smith(roughness, n_dot_v, n_dot_l);
	
		float G_vis = G * v_dot_h / (n_dot_h * n_dot_v);
		// G_vis = Vis_Smith(roughness, n_dot_v, n_dot_l);
		// float G_vis = G / (4.0f*n_dot_l*n_dot_v);
		float F_c = pow(1.0f - v_dot_h, 5);
		// float F0 = 0.5f; // reflectance at normal incidence
		// float F_c = F0 + (1-F0)*pow( 1.0f - v_dot_h, 5 );
		a += (1.0f - F_c) * G_vis;
		b += F_c * G_vis;
#ifdef JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL
		// we can throw the retroreflective diffuse BRDF in here!
		float a2 = roughness*roughness;
		float g = saturate((1.0 / 18.0) * log2(2.0 / a2 - 1.0));
		float f0 = (v_dot_h + pow5(1.0 - v_dot_h));
		float fdv = (1.0 - 0.75 * pow5(1.0 - n_dot_v));
		float fdl = (1.0 - 0.75 * pow5(1.0 - n_dot_l));
	
		// Rough (f0) to smooth (fdv * fdv) response interpolation
		float fd = mix(f0, fdv * fdl, saturate(2.2 * g - 0.5));
		
		// Retro reflectivity contribution.
		float fb = ((34.5 * g - 59.0) * g + 24.5) * v_dot_h * exp2(-max(73.2 * g - 21.2, 8.9) * sqrt(n_dot_h));
		c += (fd + fb) * n_dot_l;
#endif		
	}
	
  }
  return vec3(a, b, c) * (1.0 / num_samples);
}

void main()
{
  	OUT_Color = vec4(0);
    OUT_Color.xyz = integrate_GGX_and_retroreflective_diffuse(IO_uv0.x, IO_uv0.y);
  	// OUT_Color = vec4(IO_uv0, 1, 1);
}
#else
vec2 integrate_GGX(float roughness, float n_dot_v)
{
  vec3 normal = vec3(0.0f, 0.0f, 1.0f);

  vec3 view = vec3(sqrt(1.0f - n_dot_v * n_dot_v), 0, n_dot_v);
  float a = 0.0f; float b = 0.0f;
  CONST uint num_samples = 32u;
  for(uint i=0u; i< num_samples; ++i)
  {
    vec2 uv = hammersley_2d(i, num_samples);

    vec3 half_dir = importance_sample_GGX(uv, roughness, normal);
    vec3 light = 2 * dot(view, half_dir) * half_dir - view;
    float n_dot_l = max(0.0f, light.z);
    // float n_dot_l = light.z;
    float n_dot_h = clamp(half_dir.z, 0.0f, 1.0f);
    // float n_dot_h = half_dir.z;
    float v_dot_h = clamp(dot(view, half_dir), 0.0f, 1.0f);
    // float v_dot_h = dot(view, half_dir);

    if( n_dot_l > 0.0f)
    // if( true )
    {
      float k = (roughness*roughness)/2;
      float G = G_Smith(k, n_dot_v, n_dot_l);
      // float G = G_smith(roughness, n_dot_v, n_dot_l);

      float G_vis = G * v_dot_h / (n_dot_h * n_dot_v);
      // G_vis = Vis_Smith(roughness, n_dot_v, n_dot_l);
      // float G_vis = G / (4.0f*n_dot_l*n_dot_v);
      float F_c = pow(1.0f - v_dot_h, 5);
      // float F0 = 0.5f; // reflectance at normal incidence
      // float F_c = F0 + (1-F0)*pow( 1.0f - v_dot_h, 5 );
      a += (1.0f - F_c) * G_vis;
      b += F_c * G_vis;
    }
  }
  return vec2(a, b) / num_samples;
}

void main()
{
  	OUT_Color = vec4(0);
    OUT_Color.xy = integrate_GGX(IO_uv0.x, IO_uv0.y);
  	// OUT_Color = vec4(IO_uv0, 1, 1);
}
	
#endif/************************************************************************
    Lighting things
************************************************************************/

#define DEFERRED_HACK_TO_linearRGB(val)	(val)
#define DEFERRED_HACK_TO_sRGB(val)		(val)

#include <common_light.h>
#include <jon_mod_lighting_functions.h>

int IrradianceLevel()
{
	return int(F_ibl_maxvalidlevel);
}

int IrradianceLevel(samplerCube filtered_env_map)
{
	return textureQueryLevels(filtered_env_map) - 1;
}

float smooth2rough(in float smoothness) {
	return saturate(1.01f - smoothness);
	return 0.0001f + (1-smoothness) * (1-smoothness);
}

// redirect reflection based on roughness
float3 get_lobe_dominant_dir(float3 N, float3 R, float roughness) {
	float smoothness = saturate(1 - roughness);
	float lerpFactor = smoothness * (sqrt(smoothness) + roughness);
	return lerp(N, R, lerpFactor);
}

// DFG term approx
float3 DFGAnalytic( float3 cspec, float gloss, float n_dot_v ) {
    float x = gloss;
    float y = n_dot_v;

    float b1 = -0.1688;
    float b2 = 1.895;
    float b3 = 0.9903;
    float b4 = -4.853;
    float b5 = 8.404;
    float b6 = -5.069;
    float bias = saturate( min( b1 * x + b2 * x * x, b3 + b4 * y + b5 * y * y + b6 * y * y * y ) );

    float d0 = 0.6045;
    float d1 = 1.699;
    float d2 = -0.5228;
    float d3 = -3.603;
    float d4 = 1.404;
    float d5 = 0.1939;
    float d6 = 2.661;
    float delta = saturate( d0 + d1 * x + d2 * y + d3 * x * x + d4 * x * y + d5 * y * y + d6 * x * x * x );
    float scale = delta - bias;

    bias *= saturate( 50.0 * cspec.y );
    return cspec * scale + bias;
}

// simple tonemapping
float A = 0.15;
float B = 0.50;
float C = 0.10;
float D = 0.20;
float E = 0.02;
float F = 0.30;
float W = 11.2;

// uncharted2/naughty dog tonemap
// (cmp. http://filmicgames.com/archives/75 https://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/)
float3 u2Tonemap(float3 x)
{
	return ((x*(A*x + C*B) + D*E) / (x*(A*x + B) + D*F)) - E / F;
}


/************************************************************************
    IBL + sampling
************************************************************************/
float G_Schlick_GGX(float k, float n_dot_v)
{
	return n_dot_v / (n_dot_v * (1.0f - k) + k);
} 
float G_Smith(float k, float n_dot_v, float n_dot_l)
{
	return G_Schlick_GGX(k, n_dot_v) * G_Schlick_GGX(k, n_dot_l);
}


/************************************************************************
    BRDF
************************************************************************/
vec3 EvalBRDF(in vec3 cspec, in vec3 cdiff, in float roughness, in vec3 l, in vec3 v, in vec3 n, in vec2 mask) {
	
#ifdef JON_MOD_USE_STRICTER_N_DOT_V
    CONST float e = 0.0001f;
	float n_dot_v = abs(dot(n, v)) * (1.0 - e) + e;//the n and v are normalized, we shouldn't need the clamp
#else	
    CONST float e = 0.00000001f;
	float n_dot_v = saturate(abs(dot(n, v))+e);
	// float n_dot_v = max(e, dot(n, v));
#endif
	vec3 h = normalize(v+l);
	float n_dot_l = saturate(dot(n, l));
	float n_dot_h = saturate(dot(n, h));
	// float l_dot_h = saturate(dot(l, h));
	float v_dot_h = saturate(dot(v, h));
	
	float a = roughness*roughness;
	// a = roughness; // test
	float a2 = a*a;
	float k = a/2;
	
	float d = (n_dot_h * a2 - n_dot_h) * n_dot_h +1;
	float D = (a2 / ( PI*d*d) );
	// float D = (a2 / max(e, PI*d*d) );
	
	//course_notes_moving_frostbite_to_pbr_v32
// 	float V = 0.5 * 1.0/( n_dot_l * ( n_dot_v * (1-a)+a) + n_dot_v * ( n_dot_l * (1-a)+a));
	float V = 0.5 * 1.0/max(e, n_dot_l * ( n_dot_v * (1-a)+a) + n_dot_v * ( n_dot_l * (1-a)+a));//happens with MSAA on mesh edges, there are other ways to catch it (e.g. early per-light if (n_dot_l <= 0) discard) but this seems the most universal at first glance? although it could result in more pronounced highlights at edges? TODO @Timon/Markus test
	
#ifdef JON_MOD_USE_LUMINANCE_FRESNEL
	vec3 F = schlick_f(cspec, v_dot_h);
#else
	float f = pow(1-v_dot_h, 5);
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
// 	float f = exp2( ( -5.55473 * v_dot_h - 6.98316 ) * v_dot_h );
	vec3 F = f + (1-f) * cspec;
#endif
	float f_diff = pow(1-n_dot_v, 5);
	// 	vec3 diff = f_diff + (1-f_diff) * cdiff;
	// energy conservation using reflectance luminance
	// vec3 albedo = cdiff * saturate( 1.0f - dot(LUM_ITU601, cspec));
#ifdef JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL
	float arealight_weight = 1.0;
	cdiff = chan_diff(cdiff, a2, n_dot_v, n_dot_l, v_dot_h, n_dot_h, arealight_weight, cspec);
#else
	cdiff = cdiff * saturate(1.0f - dot(LUM_ITU601, cspec));
	cdiff *= (1.0 / PI);
#endif	
	// return vec3(v_dot_h);
	// return (cdiff/PI);
	return cdiff*mask.x + (D*V*F)*mask.y;

}
vec3 EvalBRDF(in vec3 cspec, in vec3 cdiff, in float roughness, in vec3 l, in vec3 v, in vec3 n) {
	return EvalBRDF(cspec, cdiff, roughness, l, v, n, vec2(1));
}

// simplified cook torrance
vec3 EvalBRDFSimple(in vec3 cspec, in vec3 cdiff, in float roughness, in vec3 l, in vec3 v, in vec3 n) {
	
	vec3 h = normalize(v+l);
	float n_dot_l = saturate(dot(n, l));
	float n_dot_h = saturate(dot(n, h));
	
	float a = roughness*roughness;
	float a2 = a*a;
	float k = a/2;
	
	float d = (n_dot_h * a2 - n_dot_h) * n_dot_h +1;
	float D = (a2 / ( PI*d*d) );
	float V = 0.25;
	vec3 F = cspec;
	return (cdiff/PI) + (D*V*F);
}
// simplified cook torrance returning specular color only
vec3 EvalBRDFSimpleSpec(in vec3 cspec, in float roughness, in vec3 l, in vec3 v, in vec3 n) {

	CONST vec3 h = normalize(v + l);
	CONST float n_dot_h = saturate(dot(n, h));

	//float a = roughness*roughness;
	CONST float a2 = roughness*roughness*roughness*roughness;
	

	CONST float d = (n_dot_h * a2 - n_dot_h) * n_dot_h + 1;
	CONST float D = (a2 / (PI*d*d));
	CONST float V = 0.25;
	CONST vec3 F = cspec;
	return (D*V*F);
}

/************************************************************************
    Area lights
************************************************************************/
// area local lights, modify light direction + energy
float EvalSphereLight(float radius, vec3 center, vec3 v, vec3 n, vec3 R, float roughness, out vec3 L) {

	float m = roughness*roughness;
	// m = roughness; // test, needed?
	float invdistance = 1 / sqrt(dot(center, center));
	
	// representative point method for area specular
	float3 centertoray = dot( center, R ) * R - center; // vector from sphere center to closest point on ray
	float3 pointsurface = center + centertoray * saturate( radius / sqrt( max(0.0001f, dot( centertoray, centertoray ) ) )); // closest point on sphere surface
	L = (pointsurface);
	// L = normalize(pointsurface);
	
	// sphere energy normalization
	float sphereangle = saturate( radius * invdistance );
	float spherenorm = m / saturate( m + 0.5 * sphereangle );
	// other spherenorm
	spherenorm = 1.0 / (1.0 + (1.0 / (PI * max(0.001f, m)))*sphereangle);
	return spherenorm;
	return spherenorm * spherenorm;
}

float EvalTubeLight(float radius, vec3 l0, vec3 l1, vec3 v, vec3 n, vec3 R, float roughness, out vec3 L) {
	float m = roughness*roughness;
	 m = roughness; // test
	float tube_length = length(l1 - l0);
	vec3 tubecenter = (l0+l1)/2;
	float invdistance = 1 / sqrt(dot(tubecenter, tubecenter));

	// closest point on line
	float3 L01 = l1 - l0; // tube line
	float a = pow( tube_length , 2);
	float b = dot( R, L01 );
	float t = saturate( dot( l0, b*R - L01 ) / (a - b*b) );
	vec3 linepoint = l0 + t * L01; // closest point on tube

	float tubenorm = m / saturate(m + 0.5 * saturate(tube_length * invdistance));

	// apply sphere approx
	return tubenorm * EvalSphereLight(radius, linepoint, v, n, R, roughness, L);
}

/************************************************************************
    Image based lighting
************************************************************************/

vec4 spec_first_sum_ibl(samplerCube filtered_env_map, float roughness, vec3 normal, vec3 view)
{
	vec3 R = reflect(-view, normal);

	// R = mix( R, get_lobe_dominant_dir(normal, R, rm),rm*rm);
	// R = get_lobe_dominant_dir(normal, R, rm);

	// sqrt to compensate for precision shift
	float sqrtrough = (roughness); //sqrt(roughness);
	//TODO @Timon/Florian/Markus that sqrt was important for correctness, we should look into un-fuck-up-ing it
	return textureLod(filtered_env_map, R, MaxSpecularLevel(filtered_env_map) * sqrtrough);
}

vec4 spec_first_sum_ibl(samplerCube filtered_env_map, float roughness, vec3 reflectdir)
{
	// sqrt to compensate for precision shift
	float sqrtrough = (roughness); //sqrt(roughness);
	//TODO @Timon/Florian/Markus that sqrt was important for correctness, we should look into un-fuck-up-ing it

	return textureLod(filtered_env_map, reflectdir, MaxSpecularLevel(filtered_env_map) * sqrtrough);
}

vec3 spec_brdf(vec3 first_sum, vec3 spec_color, float roughness, float n_dot_v)
{
	//float fslum = length(first_sum);
	//first_sum = pow(first_sum, vec3(3)) * 4;
	//first_sum = pow(first_sum, vec3(3))*2 ;
	//return first_sum;

	vec2 env_brdf = textureLod(T_preintegrated_GGX, vec2(roughness, n_dot_v), 0).xy;
	return first_sum * (spec_color * env_brdf.x + env_brdf.y);
}

vec4 spec_brdf_ibl4(samplerCube filtered_env_map, vec3 spec_color, float roughness, vec3 reflectdir, float n_dot_v)
{
	vec4 first_sum = spec_first_sum_ibl(filtered_env_map, roughness, reflectdir);
	return vec4(spec_brdf(first_sum.rgb, spec_color, roughness, n_dot_v), first_sum.a);
}

vec3 spec_brdf_ibl(samplerCube filtered_env_map, vec4 refl_override, vec3 amblight, vec3 spec_color, float roughness, vec3 normal, vec3 view)
{
	float n_dot_v = saturate(dot(normal, view));

	vec3 first_sum = mix(spec_first_sum_ibl(filtered_env_map, roughness, normal, view).rgb, refl_override.rgb, refl_override.a);
	first_sum += amblight;

	return spec_brdf(first_sum, spec_color, roughness, n_dot_v);
}

vec3 spec_brdf_ibl(vec4 refl_override, vec3 amblight, vec3 spec_color, float roughness, vec3 normal, vec3 view)
{
	return spec_brdf_ibl(T_ibl_envmap, refl_override, amblight, spec_color, roughness, normal, view);
}

vec3 simple_spec_brdf_ibl(samplerCube filtered_env_map, vec3 spec_color, float roughness, vec3 normal, vec3 view) {

	float n_dot_v = saturate(dot(normal, view));
	vec3 R = reflect(-view, normal);

	// sqrt to compensate for precision shift
	float sqrtrough = sqrt(roughness);
	vec3 first_sum = textureLod(filtered_env_map, R, MaxSpecularLevel(filtered_env_map) * sqrtrough).rgb;

	first_sum = DEFERRED_HACK_TO_linearRGB(first_sum);
	
	//return DFGAnalytic(spec_color, 1-roughness, n_dot_v);
	return first_sum * DFGAnalytic(spec_color, 1-roughness, n_dot_v);
}

vec3 get_irradiance(samplerCube filtered_env_map, in vec3 n) {
	vec3 irradiance = textureLod(filtered_env_map, n, IrradianceLevel(filtered_env_map)).rgb;
	irradiance = DEFERRED_HACK_TO_linearRGB(irradiance);
	return irradiance;
}

void get_colors(in vec3 albedo, in float metalness, out vec3 cspec, out vec3 cdiff) {
    cdiff = albedo * (1.0-metalness);
    cspec = mix(vec3(0.04), albedo, metalness);
	cdiff = cdiff * saturate(1.0f - dot(LUM_ITU601, cspec)); // cheap luminance energy conservation
}

// simplified forward lighting, no ssao, no shadows
vec3 simple_light(in vec3 clight, in vec3 l, in vec3 n, in vec3 v, in vec3 albedo, in float metalness, in float roughness)
{
    vec3 cspec;
    vec3 cdiff;
/*
	//include is not included here, and simple_light is not used by Egosoft
	#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
		float Subsurface = 0.0;
		UnpackMetalSubsurface(metalness, Subsurface);
	#endif
*/	

   get_colors(albedo, metalness, cspec, cdiff);
	float n_dot_l = saturate(dot(n, l));
    
    vec3 result = vec3(0);
    result += EvalBRDF(cspec, cdiff, roughness, l, v, n) * clight * n_dot_l;

	vec3 wv = v * mat3(M_view);
	vec3 wn = n * mat3(M_view);
	wv = v;
	wn = n;

    vec3 spec_amb = simple_spec_brdf_ibl(T_ibl_envmap, cspec, roughness, wn, wv);
	vec3 diff_amb = cdiff * get_irradiance(T_ibl_envmap, wn);

	vec3 ambientlight = spec_amb + diff_amb;

    result += ambientlight;
	// result = cdiff;
	result.rgb = DEFERRED_HACK_TO_sRGB(result);
    return result;
}

float GetSSAO()
{
	if (B_ssao_enabled) {
		return RTResolveSoft(T_occlusionresolve_swap).r;
	}
	return 1.0;
}
#define P1_SHADERS
#include <common.fh>
 

USE_TEXTURE_LIGHTING

DEF_LIGHT_AMBIENT(1)
DEF_LIGHT_DIR(1)
DEF_LIGHT_DIR(2)


void main()
{
	float SmoothnessVal = U_smoothness;
	float MetalnessVal = U_metallness;
	_IF(S_smooth_bool)
	{
		SmoothnessVal *= tex2D(S_smooth_map, IO_uv0).r;
	}

	_IF(S_metal_bool)
	{
		MetalnessVal *= tex2D(S_metal_map, IO_uv0).r;
	}

	half4 ColorBaseDiffuse = S_diffuse_color.rgba;
	_IF(S_diffuse_bool)
	{
		ColorBaseDiffuse.rgba = tex2D(S_diffuse_map, IO_uv0).rgba;
		if (S_diffuse_color.rgb != float3(1.0f, 1.0f, 1.0f))
		{
			ColorBaseDiffuse.rgba *= S_diffuse_color.rgba;
		}
	}


	//AlphaTest(ColorBaseDiffuse.a * F_alphascale);

	_IF(S_diffuse_detail_bool)
	{
		half4 DiffDetailv = tex2D(S_diffuse_detail_map, IO_uv0 * S_diffuse_detail_tiling).rgba * S_diffuse_detailstr;
		ColorBaseDiffuse.rgb = (ColorBaseDiffuse.rgb*DiffDetailv.rrr);
		SmoothnessVal = blendOverlay(SmoothnessVal, DiffDetailv.g);
		MetalnessVal = blendOverlay(MetalnessVal, DiffDetailv.b);
	}




	_IF(B_vertexdata0)
	{
		// NOTE: none blend areas need 128 grey!
		//ColorBaseDiffuse.rgb = blendOverlay(ColorBaseDiffuse.rgb, IO_colorRGB_specstrA.rgb);
		if (S_diffuse_color.rgb == float3(1.0f, 1.0f, 1.0f))
		{
			ColorBaseDiffuse.rgb = ColorBaseDiffuse.rgb* IO_colorRGB_specstrA.rgb;
		}
		//	SmoothnessVal *= IO_colorRGB_specstrA.a; //disabled, this causes some assets to loose smoothness!
		//TexSpecularStrPure = saturate(blendOverlay(TexSpecularStr.rgb,TO_linearRGB(IO_colorRGB_specstrA.rgb)));

	}
	CONST half3 diffnorm = ColorBaseDiffuse.rgb;

	_IF(S_diffuse_paint_bool) // after VertexColors
	{
		// blend in the paint layer
		CONST half4 ColorPaint = S_diffuse_paintstr * tex2D(S_diffuse_paint_map, IO_uv_paint).rgba;
		// we want to keep the black areas in the diffusemap so dont blend if luminance is low.
		ColorBaseDiffuse.rgb = blendAlpha(ColorBaseDiffuse.rgb, ColorPaint.rgb, ColorPaint.a);// * saturate(3.0 * luminance(ColorBaseDiffuse.rgb)));
																							  // reduce the specular on locations where we add paint.
																							  //test deactivated
		ColorBaseDiffuse.a = saturate(ColorBaseDiffuse.a+ColorPaint.a);
		CONST half specstrmod = lerp(1.0, 0.15, saturate(2.0 * ColorPaint.a));
		//	TexSpecularStr.rgb *= specstr;
		SmoothnessVal *= specstrmod;
		MetalnessVal *= specstrmod;
	}


	half3 ColorGlow = S_color_glow_color.rgb;
	_IF(S_color_glow_bool)
	{
		half4 val = S_color_glowstr * tex2D(S_color_glow_map, IO_uv0) * U_mat_dynamicglow;
		ColorGlow = val.rgb;
		ColorGlow *= 1 + val.a * (10 - 1);		//boost multiplier 1-10x (TODO @Timon @Markus decide range)
	}

	// apply the additional detail/structure layers	
	_IF(B_vertexdata1)
	{
		_IF(S_color_dirt_bool)
		{
			// blend in age layer, vertex need to be GREY on none apply areas
			CONST half4 ColorDirt = tex2D(S_color_dirt_map, IO_uv0 * S_color_dirt_tiling).rgba;
			CONST half3 ColorBaseDirt = blendMultiply(ColorBaseDiffuse.rgb, ColorDirt.rgb);
			CONST float dirtFactor = IO_damage_detail_age.b*S_color_dirtstr;
			ColorBaseDiffuse.rgb = blendAlpha(ColorBaseDiffuse.rgb, ColorBaseDirt.rgb, dirtFactor);
			ColorBaseDiffuse.a = saturate(ColorBaseDiffuse.a+ColorDirt.a* dirtFactor);
			//MetalnessVal = blendMultiply(MetalnessVal, min((ColorDirt.a* IO_damage_detail_age.b*S_color_dirtstr),1.0f));
			SmoothnessVal -= blendMultiply(SmoothnessVal, (1.0f - ColorDirt.a)*dirtFactor);
		}
	}
	/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	Combining 2 normal maps
	Artists wanted detail normal maps
	Blending 2 normal maps just flattens both
	Want to get results as if blending 2 heightmaps
	Warp 2nd normal map
	using normals from the 1st normal map:
	float3x3 nBasis = float3x3(
	float3 (n1.z, n1.x,-n1.y),
	float3 (n1.x, n1.z,-n1.y),
	float3 (n1.x, n1.y, n1.z ));
	n = normalize (n2.x*nBasis[0] + n2.y*nBasis[1] + n2.z*nBasis[2]);!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

	INPUT_NTB_TWOSIDED()
	
	float3 Normal = vec3(0);
	STANDARD_NORMAL_DETAIL_MAP(Normal)
	
	
	float backfaceFactor = 1.0f;
	if (gl_FrontFacing) {
		backfaceFactor = (0.8f - min(pow(ColorBaseDiffuse.a, 0.40f), 0.80f));
	}
	CONST half3 VertexToEye = normalize(IO_VertexToEye.xyz).xyz;

	float specShadow = 1.0f;
	float envShadow = 1.0f;
	_IF(B_shadow)
	{
		float n_dot_l = max(0.0f, dot(V_direction1.xyz, Normal.xyz));
		specShadow = GetShadow(n_dot_l);
		envShadow = (specShadow + 0.50f) / 1.50f; // Boost shadow values for envmap influence due to it being more like an ambient effect.
	}

	float Roughness = smooth2rough(SmoothnessVal);
	half3 ColorEnvi = S_environmentstr * global_envmap_resolve_glass(Normal, VertexToEye, Roughness, envShadow).rgb;

	//float fresnel(CONST float3 V, CONST float3 N, CONST half Power, CONST half Str, CONST half minRange)
/*	float fresnel_fac = fresnel(VertexToEye, Normal, 2.0, 1.0, 0.20);
	ColorEnvi.rgb *= vec3(fresnel_fac);
	*/

	//change the reflectivity based on light direction
	//also change the fresnel based on light direction??

	float ndl = max(0.0f, dot((V_direction1.xyz), Normal.xyz));
	//float ndl = max(0.0f, dot(Normal.xyz, normalize(V_direction1.xyz)));
	//ColorEnvi.rgb *= vec3(max(0.025, (0.5+ndl)/1.5));
	ColorEnvi.rgb = ColorEnvi.rgb*(1.0-U_env_dir_influence) + ColorEnvi.rgb*vec3(max(0.025, (U_dir_min + ndl) / (1.0-U_dir_min)))*U_env_dir_influence;
	//float fresnel_fac = fresnel(VertexToEye, Normal, (0.50+(1.0-ndl))/1.5, 1.0, 0.00);
	float fresnel_fac = fresnel(VertexToEye, Normal, U_fresnel_power, 1.0, U_fresnel_min);
	
	ColorEnvi.rgb = ColorEnvi.rgb*(1.0-U_fresnel_influence)+ColorEnvi.rgb*vec3(fresnel_fac)* U_fresnel_influence;
	
/*	if (luminance(ColorEnvi.rgb) > 0.051) {
		ColorEnvi.rgb *= max(0.0,1.0- luminance(ColorEnvi.rgb)*4.0);// normalize(ColorEnvi.rgb);
	}*/

	
//	OUT_Color.a = 0.8f;
//	OUT_Color.rgb = ColorEnvi;	return;
// 	OUT_Color.rgb = abs(GetFragWorld() / 5000);		return;
// 	OUT_Color.rgb = abs(inverse(M_envmapprobe_world[0]) * vec4(GetFragWorld(), 1)).xyz;		return;

	_IF(S_envi_light_bool)
	{
		ColorEnvi.rgb += envShadow * S_envi_lightstr * texture(S_envi_light_map, reflect(-VertexToEye, Normal)).rgb;
	}
	if (gl_FrontFacing)
	{
		ColorEnvi.rgb *= backfaceFactor;
	}

	//------------------------------
	
	OBJECTRENDERMODE_SOLID()

	CONST float light_radius = V_deferred_lightparams.x * 10; // dbg scale

	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	vec3 Albedo = ColorBaseDiffuse.rgb;
	float Metalness = MetalnessVal;



	float3 ldir =  normalize(V_direction1.xyz);
	float3 lcolor = XR_TO_linearRGB(V_lightcolor1.rgb) * F_globallightscale;// todo: slightly refactor the following
	
	//float3 lcolor = normalize(V_lightcolor1.rgb * F_globallightscale);// todo: slightly refactor the following
	
	float direct_occlusion = saturate(dot(ldir, Normal));
	float direct_occlusion2 = saturate(dot(-ldir, Normal));
//	vec3 view_pos;
//	RetrieveZBufferViewPos(view_pos);

	//vec3 v = normalize(-view_pos);
	vec3 v = normalize(VertexToEye);
	vec3 R = reflect(v, Normal);

	
	vec3 L;
	vec3 L2;
	vec3 E_sph = direct_occlusion * lcolor * EvalSphereLight(light_radius, ldir * 1000, v, Normal, R, Roughness, L);// +simple_light(lcolor, ldir, Normal.xyz, v, Albedo, Metalness, Roughness);
	vec3 E_sph2 = direct_occlusion2 * lcolor * EvalSphereLight(light_radius, -ldir * 1000, v, Normal, R, Roughness, L2);// +simple_light(lcolor, ldir, Normal.xyz, v, Albedo, Metalness, Roughness);
	//E_sph *= PI; // diffuse normalization
	L = normalize(L);
	L2 = normalize(L2);
	vec3 light_accum = ColorBaseDiffuse.rgb;// -ColorBaseDiffuse.rgb;// vec3(0);


	get_colors(Albedo, Metalness, cspec, cdiff);
	if (gl_FrontFacing)
	{
		cspec *= backfaceFactor;
	}

	//light_accum += ColorBaseDiffuse.rgb*(ColorBaseDiffuse.a) + EvalBRDF(cspec, cdiff, Roughness, L, v, Normal, vec2(ColorBaseDiffuse.a, 1)) *E_sph*ColorBaseDiffuse.a +ColorEnvi.rgb; // specular
	light_accum += specShadow * EvalBRDF(cspec, cdiff, Roughness, L, v, Normal, vec2(ColorBaseDiffuse.a, 1)) * E_sph * ColorBaseDiffuse.a;  // specular
	light_accum += specShadow * EvalBRDF(cspec, cdiff, Roughness, L2, v, Normal, vec2(ColorBaseDiffuse.a, 1)) * E_sph2 * ColorBaseDiffuse.a; // specular 2
	light_accum += ColorEnvi.rgb;
	//light_accum += ColorBaseDiffuse.rgb*(ColorBaseDiffuse.a) + EvalBRDF(cspec*ColorBaseDiffuse.a, cdiff*ColorBaseDiffuse.a, Roughness, L, v, Normal, vec2(ColorBaseDiffuse.a, 1)) *E_sph +ColorEnvi.rgb; // specular

	float t = dot(ldir, -VertexToEye) * U_backlitfactor;
	float cutoff = 0.95f;
	if (t > cutoff )
	{
		float vt = pow((t - cutoff) / (1.0f - cutoff), 2.0f);
		vec3 newCol = lerp(ColorBaseDiffuse.rgb * 0.0, ColorBaseDiffuse.rgb * 10.0, vt);
		light_accum += newCol;//*max( length(newCol.xyz) ,1.0);
		ColorBaseDiffuse.a += min(vt*4.0f*ColorBaseDiffuse.a,0.1f);
		ColorBaseDiffuse.a = saturate(ColorBaseDiffuse.a);
	}
	
	
	OUT_Color = float4(light_accum.xyz, saturate(ColorBaseDiffuse.a + min( length(light_accum.xyz) ,0.1)));// + saturate(1.0f - pow(dot(Normal, VertexToEye), 0.1f))*0.25f));
	//OUT_Color = float4(ColorBaseDiffuse.rgb, 1);
	//OUT_Color = float4(light_accum.xyz, ColorBaseDiffuse.a);
	//OUT_Color = float4(light_accum.xyz, saturate((ColorBaseDiffuse.a + length(light_accum.xyz)*0.25f) + saturate(1.0f - pow(dot(Normal, VertexToEye), 0.1f))*0.25f));
	//float a = saturate(1.0f - pow(dot(Normal, VertexToEye), 0.02f));
	//OUT_Color = float4(a,a,a,1);
	//OUT_Color = float4(E_sph.xyz,1.0f);
	//OUT_Color = float4(1, 0, 0, 1);
}

#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
//#define SPEC_BOOST 2.0
//#define DIFF_BOOST 1.0
//#define SPEC_POWER 1.0 // 15.0

// instance data
in vec3 IO_lightcolor;
in float IO_Intensity;
in vec3 IO_RadiusSizeXY;
in float IO_spotatten;
in float IO_SpecIntensity;
in float IO_Range;

in vec3 IO_Apex;
in vec3 IO_Direction;
in vec3 IO_right;
in vec3 IO_up;

in vec3 IO_view_center;

// currently unused
// in mat4 IO_areaaxis;


//float3 projectOnPlane(float3 p, float3 pc, float3 pn)
//{
//	float distance = dot(pn, p-pc);
//	return p - distance*pn;
//}
//
//int sideOfPlane(float3 p, float3 pc, float3 pn)
//{
//	if (dot(p-pc,pn)>=0.0) return 1; else return 0;
//}
//
//float isInBox (float3 p, float3 Apex, float3 Direction, float3 right, float3 up, float3 RangeSizeXY)
//{
//	if (sideOfPlane(p,Apex,Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x,-Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+right*RangeSizeXY.y*0.5f,-right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-right*RangeSizeXY.y*0.5f,right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+up*RangeSizeXY.z*0.5f,-up) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-up*RangeSizeXY.z*0.5f,up) == 0) return 0;
//
//	return 1;
//}


#ifdef LPASS_AREA_PLANE
#if 1
vec3 planeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;

	// vec3 planeNormal = IO_Direction;
	float t = dot( L, IO_Direction ) / dot( dir, IO_Direction );
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2( dot(r,IO_right), dot(r,IO_up) );

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if( !onSurface ) {
		vec3 bestP = L;
		float bestDot = 0.0;

		for( int i=0; i<4; ++i ) { // todo: simplify/vectorize?

			// axis and size
			vec3 ld = i>1 ? IO_right : IO_up;
			vec2 sz = i>1 ? lsize.xy : lsize.yx;

			// vector to edge center
			vec3 l0 = L + sz.y * (i>1 ? IO_up : IO_right) * ((i%2)!=0 ? -1.0 : 1.0);
			// vec3 l0 = L + IO_areaaxis[i].xyz;
				
			float dirL0 = dot(dir,l0);
			float dirld = dot(dir,ld);
			float l0ld = dot(l0,ld);
			float t = (l0ld*dirL0 - dot(l0,l0)*dirld) / (l0ld*dirld - dot(ld,ld)*dirL0); // magic
			t = clamp( t, -sz.x, sz.x );
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot( normalize(P), dir );
			if( dp > bestDot ) {
				bestP = P;
				bestDot = dp;
			}
		}
		return bestP;
		// L = bestP;
	}
	else {
		return p0;
		// L = p0;
	}
}
#else
// potentially slightly faster version
vec3 planeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float t = dot(L, IO_Direction) / dot(dir, IO_Direction);
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2(dot(r, IO_right), dot(r, IO_up));

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if (!onSurface) {
		vec3 bestP = L;
		float bestDot = 0.0;

		vec3 lda[4] = vec3[](IO_up, IO_up, IO_right, IO_right);
		vec2 sza[4] = vec2[](lsize.yx, lsize.yx, lsize.xy, lsize.xy);

		for (int i = 0; i<4; ++i) { // todo: simplify/vectorize?

			vec3 ld = lda[i];
			vec2 sz = sza[i];

			// vector to edge center
			vec3 l0 = L + IO_areaaxis[i].xyz;

			float dirL0 = dot(dir, l0);
			float dirld = dot(dir, ld);
			float l0ld = dot(l0, ld);
			float t = (l0ld*dirL0 - dot(l0, l0)*dirld) / (l0ld*dirld - dot(ld, ld)*dirL0);
			t = clamp(t, -sz.x, sz.x);
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot(normalize(P), dir);
			if (dp > bestDot) {
				bestP = P;
				bestDot = dp;
			}
		}

		return bestP;
	}
	else {
		return p0;
	}
}
#endif
#endif

#ifdef LPASS_AREA_TUBE
vec3 tubeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float tubeLength = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_RadiusSizeXY.y : IO_RadiusSizeXY.z;
	vec3 tubeDir = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_right : IO_up;

	float dirL0 = dot(dir, L);
	float dirLd = dot(dir, tubeDir);
	float l0ld = dot(L, tubeDir);
	float t = (l0ld*dirL0 - dot(L, L)*dirLd) / (l0ld*dirLd - dot(tubeDir, tubeDir)*dirL0);
	t = clamp(t, -tubeLength, tubeLength);
	vec3 P = L + t*tubeDir;
	return P;
}
#endif

#ifndef LPASS_AREA_POINT
vec3 sphereRPM(in vec3 dir, in vec3 L, float lradius) {
	//closest point on sphere to ray
	vec3 closestPoint = dot(L, dir) * dir;
	vec3 centerToRay = closestPoint - L;
	float t = lradius / sqrt( dot(centerToRay, centerToRay) );
	// L = L + centerToRay * saturate(t);
	return L + centerToRay * saturate(t);
}
#endif

float getPhysicalAtt(in vec3 lraw) {
	// CONST float invSqScale = 1.0/5.0; // better color behavior over large distances
	CONST float invSqScale = 1.0; // no scaling
	// return 1.0 / ( 1 + dot(lraw, lraw)); // "inverse square" attenuation
	float dst = max(0.0f, length(lraw) - IO_RadiusSizeXY.x) * invSqScale;
	//float dstFromSurfaceSq = max(0.0f, dot(invSqScale*lraw, invSqScale*lraw));
	//float dstFromSurfaceSq = dot(invSqScale*lraw, invSqScale*lraw);
	//dstFromSurfaceSq = 
	return 1.0 / (1 + dst*dst); // "inverse square" attenuation
	//return 1.0 / (1 + dstFromSurfaceSq); // "inverse square" attenuation
}

// unused
// float getFillAtt(in vec3 lraw) {
// 	float cutoff = F_arealightcutoff; // 5%
// 	float atten_factor = sqrt(1.0/cutoff -1);
// 	vec3 t = (lraw/(IO_Range/2))*atten_factor;

// 	vec3 tt = lraw/(IO_Range/2);
// 	// return 1-dot(tt, tt);

// 	float scale_dst2 = dot(t, t);
// 	return saturate(1.0/(1+scale_dst2)-cutoff) * 1.0/(1.0-cutoff);
// }

void main()
{
	vec3 view_pos; // needed
	RetrieveZBufferViewPos(view_pos);

	// light stuff
	CONST vec3 tolight = IO_view_center - view_pos;
	vec3 L = tolight; // L vector, gets modified
	float distance = sqrt(dot(tolight,tolight));
	float invDistance = 1.0 / distance;
	// vec3 direction = tolight * invDistance; // light direction
	// mainly readability
	float lradius = IO_RadiusSizeXY.x;
	vec2 lsize = IO_RadiusSizeXY.yz;

	if (length(tolight) >  IO_RadiusSizeXY.x+ length(IO_RadiusSizeXY.yz) + IO_Range*2.0f) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	
	// attenuation
	// plane RPM (just clamped) for diffuse + attenuation
	float atten = 1.0f;
	vec3 ldiff = tolight;
	vec3 lraw = tolight; // from patch to closest point on ray/plane
	#if defined(LPASS_AREA_TUBE) || defined(LPASS_AREA_PLANE)
// 	if( lsize.x + lsize.y > 0.0 )
	{
		vec3 toSource = ldiff;
		vec2 uv = vec2( dot(-toSource,IO_right), dot(-toSource,IO_up) );
		uv = clamp( uv, -lsize.xy, lsize.xy );
		toSource += uv.x*IO_right + uv.y*IO_up;
		lraw = toSource;
		// distance_atten = 1.0 / ( 1 + 0.01*dot(toSource, toSource));
	}
	#endif
	ldiff = normalize(lraw);
	float dstFromSurface = max(0.0f, length(lraw) - lradius);
	float dstNorm = (IO_Range);// / 2.0;
	float linattenA = saturate(1.0 - dstFromSurface/ dstNorm);

	atten *= getPhysicalAtt(lraw) * linattenA;
	
	// spot attenuation, derived from single angle
	float sp0 = saturate(IO_spotatten)*0.99;

	float diratten = 1;
	if(sp0 > 0)
	{
		diratten = 0.5*dot(-ldiff, IO_Direction)+0.5; // 0-1
		diratten = (diratten-sp0)/(1-sp0); // remap
		diratten = saturate(diratten);
		diratten *= diratten;
	}
	atten *= diratten;

	

	float sizeMin = min(lsize.x, lsize.y);
	float sizeMax = max(lsize.x, lsize.y);
	float sizeSum = lsize.x + lsize.y;
	CONST float threshold = 0.001f;

	// accumulation
	float diffuse_occlusion = 1.0f;
	vec4 finalColor = vec4(0);
	if (atten <= 0) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	{
		vec3 Normal;
		RI_GBUFFER_NORMAL0(Normal);
		
		vec3 v = normalize(-view_pos);
		vec3 dir = reflect(-v, Normal);
/*
#define USE_TUBELIGHTMATH
#ifdef USE_TUBELIGHTMATH
		if (sizeMin > threshold) {
			 L = planeRPM(dir, L);
			// L = planeRPMb(dir, L);
		}
		else if (sizeMax > threshold) {
			 L = tubeRPM(dir, L);
		}
#else
		if (sizeSum > threshold) {
			L = planeRPM(dir, L);
		}
#endif
		if (lradius > 0.0) {
			L = sphereRPM(dir, L, lradius);
		}
*/
#ifdef LPASS_AREA_PLANE
// 		if (sizeMin > threshold) {
			 L = planeRPM(dir, L);
			// L = planeRPMb(dir, L);
// 		}
		if (lradius > 0.0) {
			L = sphereRPM(dir, L, lradius);
		}
#endif
#ifdef LPASS_AREA_TUBE
// 		if (sizeMax > threshold) {
			 L = tubeRPM(dir, L);
// 		}
		if (lradius > 0.0) {
			L = sphereRPM(dir, L, lradius);
		}
#endif
#ifdef LPASS_AREA_SPHERE
		L = sphereRPM(dir, L, lradius);
#endif
		vec3 Lnorm = normalize(L);
		
		// wrt to plane RPM
		float n_dot_l = saturate(dot(Lnorm, Normal));
//		if (n_dot_l <= 0) {
//			discard;
//		}
		
		vec3 Albedo;
		float Metalness;
		float Smoothness;
		RI_GBUFFER(Normal, Albedo, Metalness, Smoothness);

		float diffndotl = saturate(dot(Normal, ldiff));
		vec3 cspec = vec3(0);
		vec3 cdiff = vec3(0);
		get_colors(Albedo, Me

		#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
			float Subsurface = 0.0;
			UnpackMetalSubsurface(Metalness, Subsurface);
		#endif
	
		talness, cspec, cdiff);

		float Roughness = smooth2rough(Smoothness);//was Smoothness*Smoothness - changed for consistency

		Roughness = max(Roughness, 0.05f); // avoid nans after squared divisions
		// float a = max(Roughness*Roughness, 0.0001f);
		float a = Roughness*Roughness;
		float a2 = a*a;
		float norm = 1.0 / (PI * a2); // factor used for spec mod

		// AO used to attenuate diffuse component
		
		if (B_ssao_enabled) {
			float ambient_occlusion = GetSSAO();
			// weight strength over distance
			float ssao_weight = 0.5*(linattenA*linattenA);
			diffuse_occlusion = saturate(ambient_occlusion);
		}
		else /**/{//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
			//looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
			diffuse_occlusion = 1.0f;
		}

		// diffuse contribution
		vec3 Idiff = IO_lightcolor.rgb * diffndotl * diffuse_occlusion;
		finalColor.rgb += Idiff * cdiff/PI ;


		// energy convservation using spec D mod
		float sizeGuess = lsize.x + lsize.y + lradius;
		float solidAngleGuess = saturate( sizeGuess * invDistance );
		float specatten = 1.0 / ( 1.0 + norm * solidAngleGuess );
		
		// horizon mod
		float horizon = 1.0 - n_dot_l;
		horizon *= horizon;
		horizon *= horizon;
		specatten = specatten - specatten * horizon;
		
		// specular contribution
		vec3 Ispec = IO_SpecIntensity * IO_lightcolor.rgb * specatten * n_dot_l;
		// vec3 Ispec = IO_SpecIntensity * IO_Intensity * IO_lightcolor.rgb * specatten * diffndotl;
		finalColor.rgb += Ispec * EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec2(0,1));
	}
	finalColor.rgb *= atten;

/*	if (B_render_arealightshape) {
		// draw influence outline
		if(abs(linattenA - 0.01) < 0.01 || abs(sqrt(diratten) - 0.01) < 0.01)
			finalColor.rgb = IO_lightcolor.rgb;
		if(linattenA < 0.01 || sqrt(diratten) < 0.01) {
				finalColor.rgb = vec3(0,1,0);
			if(sizeMin > threshold) { // its a plane
				finalColor.rgb = vec3(1,0,0);
			} 
			else if (sizeMax > threshold) { // a tube
				finalColor.rgb = vec3(1,1,0);
			}
		}
	}*/

	finalColor.rgb = clamp(finalColor.rgb, 0, 10); // safety
	finalColor.rgb = clamp(finalColor.rgb, 0, 2); // reduce flares
	finalColor.rgb *= diffuse_occlusion;
	
	OUT_Color.rgb = finalColor.rgb;
	OUT_Color.a = 0;
	
	LPASS_SHAPE_FINAL_ATTEN(atten)
#ifdef LPASS_COUNT
	OUT_Color *= FLOAT_SMALL_NUMBER;

	if (IO_Intensity == 0.0) {
		discard ;
	}
	OUT_Color.rgb += 1.0f / LPASS_COUNT;
#endif
}
#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
//#define SPEC_BOOST 2.0
//#define DIFF_BOOST 1.0
//#define SPEC_POWER 1.0 // 15.0

// instance data
in vec3 IO_lightcolor;
in float IO_Intensity;
in vec3 IO_RadiusSizeXY;
in float IO_spotatten;
in float IO_SpecIntensity;
in float IO_Range;

in vec3 IO_Apex;
in vec3 IO_Direction;
in vec3 IO_right;
in vec3 IO_up;

in vec3 IO_view_center;

// currently unused
// in mat4 IO_areaaxis;


//float3 projectOnPlane(float3 p, float3 pc, float3 pn)
//{
//	float distance = dot(pn, p-pc);
//	return p - distance*pn;
//}
//
//int sideOfPlane(float3 p, float3 pc, float3 pn)
//{
//	if (dot(p-pc,pn)>=0.0) return 1; else return 0;
//}
//
//float isInBox (float3 p, float3 Apex, float3 Direction, float3 right, float3 up, float3 RangeSizeXY)
//{
//	if (sideOfPlane(p,Apex,Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x,-Direction) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+right*RangeSizeXY.y*0.5f,-right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-right*RangeSizeXY.y*0.5f,right) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f+up*RangeSizeXY.z*0.5f,-up) == 0) return 0;
//	if (sideOfPlane(p,Apex+Direction*RangeSizeXY.x*0.5f-up*RangeSizeXY.z*0.5f,up) == 0) return 0;
//
//	return 1;
//}

vec3 planeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;

	// vec3 planeNormal = IO_Direction;
	float t = dot( L, IO_Direction ) / dot( dir, IO_Direction );
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2( dot(r,IO_right), dot(r,IO_up) );

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if( !onSurface ) {
		vec3 bestP = L;
		float bestDot = 0.0;

		for( int i=0; i<4; ++i ) { // todo: simplify/vectorize?

			// axis and size
			vec3 ld = i>1 ? IO_right : IO_up;
			vec2 sz = i>1 ? lsize.xy : lsize.yx;

			// vector to edge center
			vec3 l0 = L + sz.y * (i>1 ? IO_up : IO_right) * ((i%2)!=0 ? -1.0 : 1.0);
			// vec3 l0 = L + IO_areaaxis[i].xyz;
				
			float dirL0 = dot(dir,l0);
			float dirld = dot(dir,ld);
			float l0ld = dot(l0,ld);
			float t = (l0ld*dirL0 - dot(l0,l0)*dirld) / (l0ld*dirld - dot(ld,ld)*dirL0); // magic
			t = clamp( t, -sz.x, sz.x );
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot( normalize(P), dir );
			if( dp > bestDot ) {
				bestP = P;
				bestDot = dp;
			}
		}
		return bestP;
		// L = bestP;
	}
	else {
		return p0;
		// L = p0;
	}
}

// potentially slightly faster version
#if 0
vec3 planeRPMb(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float t = dot(L, IO_Direction) / dot(dir, IO_Direction);
	vec3 p0 = t * dir;

	vec3 r = p0 - L;
	vec2 uv = vec2(dot(r, IO_right), dot(r, IO_up));

	bool onSurface = abs(uv.x) < lsize.x && abs(uv.y) < lsize.y;
	if (!onSurface) {
		vec3 bestP = L;
		float bestDot = 0.0;

		vec3 lda[4] = vec3[](IO_up, IO_up, IO_right, IO_right);
		vec2 sza[4] = vec2[](lsize.yx, lsize.yx, lsize.xy, lsize.xy);

		for (int i = 0; i<4; ++i) { // todo: simplify/vectorize?

			vec3 ld = lda[i];
			vec2 sz = sza[i];

			// vector to edge center
			vec3 l0 = L + IO_areaaxis[i].xyz;

			float dirL0 = dot(dir, l0);
			float dirld = dot(dir, ld);
			float l0ld = dot(l0, ld);
			float t = (l0ld*dirL0 - dot(l0, l0)*dirld) / (l0ld*dirld - dot(ld, ld)*dirL0);
			t = clamp(t, -sz.x, sz.x);
			vec3 P = l0 + t*ld;

			// test point
			float dp = dot(normalize(P), dir);
			if (dp > bestDot) {
				bestP = P;
				bestDot = dp;
			}
		}

		return bestP;
	}
	else {
		return p0;
	}
}
#endif

vec3 tubeRPM(in vec3 dir, in vec3 L) {
	vec2 lsize = IO_RadiusSizeXY.yz;
	float tubeLength = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_RadiusSizeXY.y : IO_RadiusSizeXY.z;
	vec3 tubeDir = (IO_RadiusSizeXY.y > IO_RadiusSizeXY.z) ? IO_right : IO_up;

	float dirL0 = dot(dir, L);
	float dirLd = dot(dir, tubeDir);
	float l0ld = dot(L, tubeDir);
	float t = (l0ld*dirL0 - dot(L, L)*dirLd) / (l0ld*dirLd - dot(tubeDir, tubeDir)*dirL0);
	t = clamp(t, -tubeLength, tubeLength);
	vec3 P = L + t*tubeDir;
	return P;
}

vec3 sphereRPM(in vec3 dir, in vec3 L, float lradius) {
	//closest point on sphere to ray
	vec3 closestPoint = dot(L, dir) * dir;
	vec3 centerToRay = closestPoint - L;
	float t = lradius / sqrt( dot(centerToRay, centerToRay) );
	// L = L + centerToRay * saturate(t);
	return L + centerToRay * saturate(t);
}

float getPhysicalAtt(in vec3 lraw) {
	// CONST float invSqScale = 1.0/5.0; // better color behavior over large distances
	CONST float invSqScale = 1.0; // no scaling
	// return 1.0 / ( 1 + dot(lraw, lraw)); // "inverse square" attenuation
	float dst = max(0.0f, length(lraw) - IO_RadiusSizeXY.x) * invSqScale;
	//float dstFromSurfaceSq = max(0.0f, dot(invSqScale*lraw, invSqScale*lraw));
	//float dstFromSurfaceSq = dot(invSqScale*lraw, invSqScale*lraw);
	//dstFromSurfaceSq = 
	return 1.0 / (1 + dst*dst); // "inverse square" attenuation
	//return 1.0 / (1 + dstFromSurfaceSq); // "inverse square" attenuation
}

// unused
// float getFillAtt(in vec3 lraw) {
// 	float cutoff = F_arealightcutoff; // 5%
// 	float atten_factor = sqrt(1.0/cutoff -1);
// 	vec3 t = (lraw/(IO_Range/2))*atten_factor;

// 	vec3 tt = lraw/(IO_Range/2);
// 	// return 1-dot(tt, tt);

// 	float scale_dst2 = dot(t, t);
// 	return saturate(1.0/(1+scale_dst2)-cutoff) * 1.0/(1.0-cutoff);
// }

void main()
{
	vec3 view_pos; // needed
	RetrieveZBufferViewPos(view_pos);

	// light stuff
	CONST vec3 tolight = IO_view_center - view_pos;
	vec3 L = tolight; // L vector, gets modified
	float distance = sqrt(dot(tolight,tolight));
	float invDistance = 1.0 / distance;
	// vec3 direction = tolight * invDistance; // light direction
	// mainly readability
	float lradius = IO_RadiusSizeXY.x;
	vec2 lsize = IO_RadiusSizeXY.yz;

	if (length(tolight) >  IO_RadiusSizeXY.x+ length(IO_RadiusSizeXY.yz) + IO_Range*2.0f)
		discard;
	
	// attenuation
	// plane RPM (just clamped) for diffuse + attenuation
	float atten = 1.0f;
	vec3 ldiff = tolight;
	vec3 lraw = tolight; // from patch to closest point on ray/plane
	if( lsize.x + lsize.y > 0.0 )
	{
		vec3 toSource = ldiff;
		vec2 uv = vec2( dot(-toSource,IO_right), dot(-toSource,IO_up) );
		uv = clamp( uv, -lsize.xy, lsize.xy );
		toSource += uv.x*IO_right + uv.y*IO_up;
		lraw = toSource;
		// distance_atten = 1.0 / ( 1 + 0.01*dot(toSource, toSource));
	}
	ldiff = normalize(lraw);
	float dstFromSurface = max(0.0f, length(lraw) - lradius);
	float dstNorm = (IO_Range);// / 2.0;
	float linattenA = saturate(1.0 - dstFromSurface/ dstNorm);

	atten *= getPhysicalAtt(lraw) * linattenA;
	
	// spot attenuation, derived from single angle
	float sp0 = saturate(IO_spotatten)*0.99;

	float diratten = 1;
	if(sp0 > 0)
	{
		diratten = 0.5*dot(-ldiff, IO_Direction)+0.5; // 0-1
		diratten = (diratten-sp0)/(1-sp0); // remap
		diratten = saturate(diratten);
		diratten *= diratten;
	}
	atten *= diratten;

	

	float sizeMin = min(lsize.x, lsize.y);
	float sizeMax = max(lsize.x, lsize.y);
	float sizeSum = lsize.x + lsize.y;
	CONST float threshold = 0.001f;

	// accumulation
	float diffuse_occlusion = 1.0f;
	vec4 finalColor = vec4(0);
	if(atten > 0)
	{

		//vec3 Normal; // needed
		//vec3 Albedo; // needed
		//vec3 Glow; // not needed
		//float Metalness; // needed
		//float Smoothness; // needed
		//RETRIEVE_GBUFFER(Normal, Albedo, Glow, Metalness, Smoothness);

		vec3 Normal;
		vec3 Normal2;
		vec3 Albedo;
		vec3 Glow;
		float GlowStr;
		float Metalness;
		float Smoothness;
		RI_GBUFFER(Normal, Albedo, Metalness, Smoothness);

		float diffndotl = saturate(dot(Normal, ldiff));
		vec3 cspec = vec3(0);
		vec3 cdiff = vec3(0);
		#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
			float Subsurface = 0.0;
			UnpackMetalSubsurface(Metalness, Subsurface);
		#endif
		get_colors(Albedo, Metalness, cspec, cdiff);

		float Roughness = smooth2rough(Smoothness);//was Smoothness*Smoothness - changed for consistency

		Roughness = max(Roughness, 0.05f); // avoid nans after squared divisions
		// float a = max(Roughness*Roughness, 0.0001f);
		float a = Roughness*Roughness;
		float a2 = a*a;
		float norm = 1.0 / (PI * a2); // factor used for spec mod

		// AO used to attenuate diffuse component
		
		if (B_ssao_enabled) {
			float ambient_occlusion = GetSSAO();
			// weight strength over distance
			float ssao_weight = 0.5*(linattenA*linattenA);
			diffuse_occlusion = saturate(ambient_occlusion);
		}
		else /**/{//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
			//looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
			diffuse_occlusion = 1.0f;
		}

		// diffuse contribution
		vec3 Idiff = IO_lightcolor.rgb * diffndotl * diffuse_occlusion;
		finalColor.rgb += Idiff * cdiff/PI ;


		vec3 v = normalize(-view_pos);
		vec3 dir = reflect(-v, Normal);
#define USE_TUBELIGHTMATH
#ifdef USE_TUBELIGHTMATH
		if (sizeMin > threshold) {
			 L = planeRPM(dir, L);
			// L = planeRPMb(dir, L);
		}
		else if (sizeMax > threshold) {
			 L = tubeRPM(dir, L);
		}
#else
		if (sizeSum > threshold) {
			L = planeRPM(dir, L);
		}
#endif
		if (lradius > 0.0) {
			L = sphereRPM(dir, L, lradius);
		}

		// energy convservation using spec D mod
		float sizeGuess = lsize.x + lsize.y + lradius;
		float solidAngleGuess = saturate( sizeGuess * invDistance );
		float specatten = 1.0 / ( 1.0 + norm * solidAngleGuess );
		vec3 Lnorm = normalize(L);

		// wrt to plane RPM
		float n_dot_l = saturate(dot(Lnorm, Normal));
	
		// horizon mod
		float horizon = 1.0 - n_dot_l;
		horizon *= horizon;
		horizon *= horizon;
		specatten = specatten - specatten * horizon;

		// specular contribution
		vec3 Ispec = IO_SpecIntensity * IO_lightcolor.rgb * specatten * n_dot_l;
		// vec3 Ispec = IO_SpecIntensity * IO_Intensity * IO_lightcolor.rgb * specatten * diffndotl;
		finalColor.rgb += Ispec * EvalBRDF(cspec, cdiff, Roughness, Lnorm, v, Normal, vec2(0,1));
	// finalColor.rgb = vec3(n_dot_l);
	}
	finalColor.rgb *= atten;

/*	if (B_render_arealightshape) {
		// draw influence outline
		if(abs(linattenA - 0.01) < 0.01 || abs(sqrt(diratten) - 0.01) < 0.01)
			finalColor.rgb = IO_lightcolor.rgb;
		if(linattenA < 0.01 || sqrt(diratten) < 0.01) {
				finalColor.rgb = vec3(0,1,0);
			if(sizeMin > threshold) { // its a plane
				finalColor.rgb = vec3(1,0,0);
			} 
			else if (sizeMax > threshold) { // a tube
				finalColor.rgb = vec3(1,1,0);
			}
		}
	}*/

	finalColor.rgb = clamp(finalColor.rgb, 0, 10); // safety
	finalColor.rgb = clamp(finalColor.rgb, 0, 2); // reduce flares
	finalColor.rgb *= diffuse_occlusion;
	
	OUT_Color.rgb = finalColor.rgb;
	OUT_Color.a = 0;
	
#ifdef LPASS_COUNT
	OUT_Color *= FLOAT_SMALL_NUMBER;
	OUT_Color.rgb += 1.0f / LPASS_COUNT;
#endif
}
#define P1_SHADERS
#include <common.fh>


//TODO
// wenn radius > 0.5*length, gibt es artefakte an den stirnflchen! 

// HACK TO BOOS LOCAL SPEC!
#define SPEC_BOOST 2.0
#define DIFF_BOOST 1.0
#define SPEC_POWER 1.0 // 15.0

in float IO_radius;
in float IO_SpecularIntensity;
in vec3 IO_l1;
in vec3 IO_l2;
in vec3 IO_center;
in vec4 IO_worldviewpos;
in vec3 IO_lightcolor;
in float IO_Intensity;

void main()
{
	OUT_Color = vec4(0);
	
	CONST half2 LightPower = half2(SPEC_POWER, 6.2); // We need power from light here

	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos);

 	// Calculate the frustum ray using the view-space position.
    CONST float3 PositionWV = (IO_worldviewpos.xyz / IO_worldviewpos.z) * view_pos.z; // scale back to z = 1.0 and scale to stored Z
	
	float Ldist = length(IO_l2 - IO_l1);
	Ldist *=Ldist;
	float t = dot(IO_l1 - PositionWV, IO_l2 - IO_l1) / Ldist;
	t = saturate(-t);
 	float3 Lx = IO_l1 + (t * (IO_l2 - IO_l1));
 	
	// Start normal light calculations
	CONST float3 L = Lx.xyz - PositionWV.xyz; // build L with light center and reconstructed Z pos
	
	CONST float LightDistance = length(L);

	if (LightDistance > length(IO_l2 - IO_l1) + IO_radius) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}

	CONST half DistanceNorm2 = IO_radius*0.9/LightDistance;
	CONST half PSquareDistanceAtt = saturate( 1.0 - 1.0/ pow(DistanceNorm2,2.0));

	if (PSquareDistanceAtt <= 0) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	
	vec3 Normal;
	RI_GBUFFER_NORMAL0(Normal);
	
	float n_dot_l = saturate(dot(Normal, normalize(L)));
	if (n_dot_l <= 0.0f) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	
	vec4 finalColor = vec4(0);
	vec3 l0 = IO_l1 - view_pos;
	vec3 l1 = IO_l2 - view_pos;
	vec3 n = (Normal);
	vec3 v = normalize(-view_pos.xyz);
	
	vec3 Albedo;
	float Metalness;
	float Smoothness;
	RI_GBUFFER_BASECOLOR(Albedo);
	RI_GBUFFER_METAL_SMOOTH(Metalness, Smoothness);
	
	float Roughness = smooth2rough(Smoothness);

	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);

	#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
		float Subsurface = 0.0;
		UnpackMetalSubsurface(Metalness, Subsurface);
	#endif

	get_colors(Albedo, Metalness, cspec, cdiff);
#ifndef LOCALSPEC
	cspec = cspec * 0.0f;
#endif
	
	vec3 clight = IO_lightcolor.rgb;

	float diffuse_occlusion = 1.0f;
	if (B_ssao_enabled) {
		float ambient_occlusion = GetSSAO();
		diffuse_occlusion = saturate(ambient_occlusion);
	}
	
#ifdef LOCALSPEC
	finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, normalize(L), v, n, vec2(1, IO_SpecularIntensity)) * clight * n_dot_l;
#else 
	finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, normalize(L), v, n, vec2(1, 0)) * clight * n_dot_l;
#endif
	float atten = PSquareDistanceAtt;
	finalColor.rgb *= atten;

	finalColor.rgb = DEFERRED_HACK_TO_sRGB(finalColor.rgb);

	OUT_Color.rgb = finalColor.rgb*diffuse_occlusion;
	OUT_Color.a = 0;
	
	LPASS_SHAPE_FINAL_ATTEN(atten)
#ifdef LPASS_COUNT
	OUT_Color *= FLOAT_SMALL_NUMBER;

	if (IO_Intensity == 0.0) {
		discard ;
	}
	OUT_Color.rgb += 1.0f / LPASS_COUNT;
#endif
}
#define P1_SHADERS
#include <common.fh>

in float IO_radius;
in vec3 IO_center;
in vec4 IO_worldviewpos;

#ifdef LPASS_BLEND_DEBUG
in vec4 IO_lightcolor;
#endif

void main()
{
	OUT_Color = vec4(0);
	OUT_Color.a = 1;
	
	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos);

	if (view_pos.z > BGDIST) {
	//	OUT_Color.r = 1;	return;
		discard;
	}

	vec4 finalColor = vec4(0);

	vec3 wn;
	vec3 Albedo;
	float Metalness;
	float Smoothness;
	RI_GBUFFER_RAW(wn, Albedo, Metalness, Smoothness);
	float Roughness = smooth2rough(Smoothness);

	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	get_colors(Albedo, Metalness, cspec, cdiff);

	float ambient_occlusion = GetSSAO();//TODO @Timon/Florian maybe it'd just be better to go back to the traditional subtract later in the frame...

	// PositionWS: vector from camera to pixel in world-space
// 	vec3 PositionWS = view_pos * mat3(M_view);
// 	PositionWS += V_cameraposition.xyz;
	vec3 PositionWS = view2world(view_pos);
	float3 PositionLS = EnvMapMulMatrix(M_envmapprobe_world, PositionWS);
// 	DebugStore(PositionLS); 	return;

	float blend = EnvMapFading(PositionLS);

	// apply lod fade-out
	blend *= U_fade_lod;

	// wv: direction from from pixel to camera in world-space
	vec3 wv = normalize(-view_pos) * mat3(M_view);
	float v_dot_n = saturate(dot(wv, wn));
	// smaller cone at edges to highlight fresnel
	
	//Jon Note, this is not a good idea, the energy intensity that you think you're simulating should already be covered in the fresnel term.
	#ifdef JON_MOD_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE
		float ambRoughness = Roughness;
	#else
		// smaller cone at edges to highlight fresnel
		float ambRoughness = mix(Roughness*0.3, Roughness, pow(v_dot_n, 1.0/3.0));
		//ambRoughness = Roughness; // deactivated, effect too strong
	#endif	

	float ssr = 0;
	if (U_pass) {
		//Jon comment, I've seen worse :P
		ssr = SSR_GetHit(RTResolveSoft(T_ssr).a); // this seems like the least stupid way to get proper diffuse envmap probes while keeping specular SSR?:/
	}

	{
		vec3 R = reflect(-wv, wn);
		R = EnvMapAdjust(PositionWS, R);
		#ifdef JON_MOD_USE_RETROREFLECTIVE_DIFFUSE_MODEL
			#ifdef JON_MOD_COMPARE_VANILLA_SPLIT_SCREEN
				if(GetViewPos().x > 0.0)
				{
					finalColor = combined_ambient_probe_brdf(S_input_rt, cspec, cdiff, wn, wv, R, ambRoughness, ambient_occlusion, ssr);
				}
				else
				{	
					float n_dot_v = saturate(dot(wn, wv));
					vec4 spec_amb = spec_brdf_ibl4(S_input_rt, cspec, ambRoughness, R, n_dot_v);
					spec_amb.rgb *= saturate(1 - ssr);//ssr takes priority over envmap probe specular, however the diffuse and alpha shouldn't be affected so that globallight can accurately mix everything together
					vec3 diff_amb = cdiff * get_irradiance(S_input_rt, wn);
			
					finalColor.rgb = (spec_amb.rgb + diff_amb) * ambient_occlusion;
					finalColor.a = spec_amb.a;
					finalColor.a = saturate(finalColor.a);
				}
			#else
				finalColor = combined_ambient_probe_brdf(S_input_rt, cspec, cdiff, wn, wv, R, ambRoughness, ambient_occlusion, ssr);
			#endif
		#else	
			float n_dot_v = saturate(dot(wn, wv));
			vec4 spec_amb = spec_brdf_ibl4(S_input_rt, cspec, ambRoughness, R, n_dot_v);
			spec_amb.rgb *= saturate(1 - ssr);//ssr takes priority over envmap probe specular, however the diffuse and alpha shouldn't be affected so that globallight can accurately mix everything together
			vec3 diff_amb = cdiff * get_irradiance(S_input_rt, wn);
	
			finalColor.rgb = (spec_amb.rgb + diff_amb) * ambient_occlusion;
			finalColor.a = spec_amb.a;
			finalColor.a = saturate(finalColor.a);
		#endif
	}
#ifdef LPASS_BLEND_DEBUG
	OUT_Color.rgb = IO_lightcolor.rgb;
	OUT_Color.a = 1;
	OUT_Color *= saturate(1 - ssr);	//arguable whether we want to know how ssr behaves?
#else
	OUT_Color.rgb = finalColor.rgb;
	OUT_Color.a = finalColor.a;
#endif
	OUT_Color *= blend;
}
#define P1_SHADERS
#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
#define SPEC_BOOST 2.0
#define DIFF_BOOST 1.0
#define SPEC_POWER 1.0 // 15.0

in float IO_Intensity;
in vec3 IO_worldview_center;
in float IO_radius;
in float IO_SpecularIntensity;

in vec4 IO_worldviewpos;
in vec3 IO_lightcolor;

void main()
{
	OUT_Color = vec4(0);
	
	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos);
	
	float3 L = IO_worldview_center - view_pos; // build L with light center and reconstructed Z pos
//	OUT_Color = vec4(IO_worldview_center.xyz/5000, 1);
	
 	float LightDistance = length(L);
//	OUT_Color = half4(LightDistance/IO_radius, 0, 0, 1);

	if (LightDistance > IO_radius) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}

	vec3 l = normalize(L);
	
	vec3 Normal;
	RI_GBUFFER_NORMAL0(Normal);
	
	float n_dot_l = saturate(dot(l, Normal));
	if (n_dot_l <= 0.0f) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}

	vec3 Albedo;
	float Metalness;
	float Smoothness;
	RI_GBUFFER_BASECOLOR(Albedo);
	RI_GBUFFER_METAL_SMOOTH(Metalness, Smoothness);
	
	float Roughness = smooth2rough(Smoothness);
	
	vec3 v = normalize(-view_pos);
	
	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
		float Subsurface = 0.0;
		UnpackMetalSubsurface(Metalness, Subsurface);
	#endif
	get_colors(Albedo, Metalness, cspec, cdiff);
	#ifndef LOCALSPEC
		cspec *= 0.0f;
	#endif

	float radius = IO_radius*0.9;
	float a = pow(saturate(1.0f-pow(LightDistance/radius,4.0f)), 2.0f);
	float b = 1.0/pow(LightDistance, 2.0f) + 1.0f;
	float PSquareDistanceAtt = saturate(a/b);
	
	float4 finalColor;
	
	//Jon :P, know the feeling!
	//TODO @Timon this is all so wrong, but historical reasons... 
#ifdef LOCALSPEC
	finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec2(1, IO_SpecularIntensity)) * IO_lightcolor.rgb * n_dot_l;
#else
	finalColor.rgb = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec2(1,0)) * IO_lightcolor.rgb * n_dot_l;
#endif
	float atten = PSquareDistanceAtt;
	finalColor.rgb *= atten;
	finalColor.a = 1;
	
	finalColor = DEFERRED_HACK_TO_sRGB(finalColor);
	
	float diffuse_occlusion = 1.0f;// AO used to attenuate diffuse component
	if (B_ssao_enabled) {
		float ambient_occlusion = GetSSAO();
		diffuse_occlusion = saturate(ambient_occlusion);
	}
	else {//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
		  //looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
		diffuse_occlusion = 1.0f;
	}

	OUT_Color.rgb = finalColor.rgb*diffuse_occlusion;
	OUT_Color.a = 0;

	LPASS_SHAPE_FINAL_ATTEN(atten)
#ifdef LPASS_COUNT
	OUT_Color *= FLOAT_SMALL_NUMBER;

	if (IO_Intensity == 0.0) {
		discard ;
	}
	OUT_Color.rgb += 1.0f / LPASS_COUNT;
#endif
}
#define P1_SHADERS
#include <common.fh>


// HACK TO BOOS LOCAL SPEC!
#define SPEC_BOOST 2.0
#define DIFF_BOOST 1.0
#define SPEC_POWER 1.0 // 15.0

//gl_Position				// Pos						: POSITION;
in vec3 IO_lightcolor;		// LightColor / TEXCOORD1
in vec3 IO_direction;		// Direction				: TEXCOORD2;
in vec3 IO_apex;			// Apex	: TEXCOORD3;
in vec3 IO_range_radius_index;	// Range_Radius				: TEXCOORD4;
in float IO_SpecularIntensity;
in float IO_Intensity;

/*
float getPhysicalAtt(in vec3 lraw) {
	// CONST float invSqScale = 1.0/5.0; // better color behavior over large distances
	CONST float invSqScale = 1.0; // no scaling
								  // return 1.0 / ( 1 + dot(lraw, lraw)); // "inverse square" attenuation
	float dst = max(0.0f, length(lraw) - IO_range_radius_index.x) * invSqScale;
	//float dstFromSurfaceSq = max(0.0f, dot(invSqScale*lraw, invSqScale*lraw));
	//float dstFromSurfaceSq = dot(invSqScale*lraw, invSqScale*lraw);
	//dstFromSurfaceSq = 
	return 1.0 / (1 + dst*dst); // "inverse square" attenuation
								//return 1.0 / (1 + dstFromSurfaceSq); // "inverse square" attenuation
}
*/
void main()
{
	OUT_Color = vec4(0);
	
	float index = IO_range_radius_index.z;
	
	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos);
	
	// Calculate the frustum ray using the view-space position.
	CONST float3 PositionWV = (IO_worldview_pos.xyz / IO_worldview_pos.z) * view_pos.z; // scale back to z = 1.0 and scale to stored Z

	CONST float3 d = PositionWV - IO_apex;
	CONST float LightDistance = length(d);

	if (LightDistance > IO_range_radius_index.x) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	
	CONST float LinearDistanceAtt = pow(smoothstep(0.9f* IO_range_radius_index.x, 0.0f, LightDistance), 2.0f);// square falloff

	CONST half DistanceNorm2 = IO_range_radius_index.x / LightDistance;
	//CONST half PSquareDistanceAtt = saturate( 1.0 - 1.0/ pow(DistanceNorm2,2.0));

	float a = pow(saturate(1.0f - pow(LightDistance / IO_range_radius_index.x, 4.0f)), 2.0f);
	float b = 1.0 / pow(LightDistance, 2.0f) + 1.0f; //1.0f / pow(LightDistance, 2.0f) + 1.0f;
	float PSquareDistanceAtt = a / b;

	PSquareDistanceAtt = max(0.0f, (1.0f - 1.0f / ((pow(IO_range_radius_index.x / LightDistance, 0.20f)))) *(pow(IO_range_radius_index.x / LightDistance, 1.40f)));

	CONST float RadialDistance = length(cross(PositionWV - IO_apex, PositionWV - (IO_apex + IO_direction*10000.0f))) / length((IO_apex + IO_direction*10000.0f) - IO_apex);
	CONST float3 proj = float3(dot(IO_apex - PositionWV, (IO_direction*10000.0f) / length(IO_direction*10000.0f)));
	CONST float maxradialDist = sqrt(pow(LightDistance, 2.0) - pow(length(proj), 2.0));
	CONST float lightToSurfaceAngle = degrees(acos(dot(normalize(d), IO_direction)));
	//float RadialDistanceAtt = pow(smoothstep(IO_range_radius_index.y*0.95f,IO_range_radius_index.y*0.75f,lightToSurfaceAngle),1.0f/2.0f); //version restricted to fallof only on the outer cone!
	float RadialDistanceAtt = pow(smoothstep(IO_range_radius_index.y*0.95f, 0.0f, lightToSurfaceAngle), 1.0f / 2.0f);

	if (index > 1.0) {
		RadialDistanceAtt *= tex2D(S_diffuse_map, float2(1.0f - RadialDistanceAtt, 0.03125f + (index - 1.0f)*0.0625f)).r;
	}
	if (RadialDistanceAtt <= 0) {
		LPASS_SHAPE_EARLY_DISCARD()
		discard;
	}
	
	vec3 Normal;
	RI_GBUFFER_NORMAL0(Normal);
	
	float3 L = d.xyz - Normal*LightDistance*0.5f;
	
	vec3 l;// = normalize(IO_apex - view_pos);
	l = normalize(-L);
	float n_dot_l = saturate(dot(Normal, l));
	if (n_dot_l <= 0) {
		discard;
	}

	vec3 v = normalize(-view_pos);
	
	vec3 Albedo;
	float Metalness;
	float Smoothness;
	RI_GBUFFER_BASECOLOR(Albedo);
	RI_GBUFFER_METAL_SMOOTH(Metalness, Smoothness);
	
	float Roughness = smooth2rough(Smoothness);

	vec3 cspec = vec3(0);
	vec3 cdiff = vec3(0);
	#ifdef JON_MOD_ENABLE_SUBSURFACE_GBUFFER_PACKING
		float Subsurface = 0.0;
		UnpackMetalSubsurface(Metalness, Subsurface);
	#endif
	get_colors(Albedo, Metalness, cspec, cdiff);

	vec3 clight = IO_lightcolor.rgb;

	float3 light;
	#ifdef LOCALSPEC
	light = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec2(1, IO_SpecularIntensity)) * clight * n_dot_l;
	
	#else
	light = EvalBRDF(cspec, cdiff, Roughness, l, v, Normal, vec2(1, 0)) * clight * n_dot_l;
	
	#endif
	
	
	float4 finalColor;
	finalColor.rgb = light;

	vec3 Ispec = IO_SpecularIntensity * IO_lightcolor.rgb * n_dot_l;
	
	finalColor.rgb += Ispec * EvalBRDFSimpleSpec(cspec, Roughness, l, v, Normal);

	float atten = RadialDistanceAtt*PSquareDistanceAtt;
	finalColor.rgb *= atten;
	finalColor.a = 1;

	float diffuse_occlusion = 1.0f;
	if (B_ssao_enabled) {
		float ambient_occlusion = GetSSAO();
		diffuse_occlusion = saturate(ambient_occlusion);
	}
	else {//TODO @Timon without this the attenuation breaks with vulkan nvidia-381.22 geforce 650ti on linux
		  //looks like either glslang or nvidia-driver bug, or I'm not aware of some detail of the spec
		diffuse_occlusion = 1.0f;
	}

	finalColor = DEFERRED_HACK_TO_sRGB(finalColor);
	finalColor.rgb = clamp(finalColor.rgb, 0, 2)*diffuse_occlusion; // reduce flares

	OUT_Color.rgb = finalColor.rgb;
	OUT_Color.a = 0;
	
	LPASS_SHAPE_FINAL_ATTEN(atten)
#ifdef LPASS_COUNT
	OUT_Color *= FLOAT_SMALL_NUMBER;

	if (IO_Intensity == 0.0) {
		discard ;
	}
	OUT_Color.rgb += 1.0f / LPASS_COUNT;
#endif
}
#include <common.fh>


// Lighting
USE_TEXTURE_LIGHTING
//USE_SHADOW_MAP
DEF_LIGHT_AMBIENT(1)
DEF_LIGHT_DIR(1)
DEF_LIGHT_DIR(2)
DEF_LIGHT_DIR(3)

void main()
{
	CONST mat3x3 inCOLORMATRIX_BASE = mat3x3(make_ColorMatrix(U_base_brightness_shift, U_base_contrast_shift, U_base_saturation_shift, U_base_hue_shift));
	CONST mat3x3 inCOLORMATRIX_PAINT = mat3x3(make_ColorMatrix(U_paint_brightness_shift, U_paint_contrast_shift, U_paint_saturation_shift, U_paint_hue_shift));
	
	CONST half3 VertexToEye = normalize(IO_VertexToEye.xyz);	// V

	half4 ColorBaseDiffuse = half4(TO_linearRGB(S_diffuse_color.rgb), 0.0);
	half4 ColorBaseDiffuseSub = half4(1.0,1.0,1.0,0.0);

	float SmoothnessVal = U_smoothness;
	float MetalnessVal = U_metallness;
	_IF(S_smooth_bool)
	{
		SmoothnessVal *= tex2D(S_smooth_map, IO_uv0).r;
	}
	
	_IF(S_metal_bool)
	{
		MetalnessVal *= tex2D(S_metal_map, IO_uv0).r;
	}

	float max = U_ethnicity_european + U_ethnicity_african + U_ethnicity_asian;
	float3 E = float3(U_ethnicity_european / max, U_ethnicity_african / max, U_ethnicity_asian / max);


	_IF(S_diffuse_bool) //alpha = hueShift Mask (dont shift)
	{
		//ColorBaseDiffuse			= tex2D(S_diffuse_map, IO_uv0).rgba;	//Base Diffuse + alpha
		
		ColorBaseDiffuse = tex2D(S_diffuse_map, IO_uv0).rgba*E.x + tex2D(S_diffuse2_map, IO_uv0).rgba*E.y+ tex2D(S_diffuse3_map, IO_uv0).rgba*E.z;
		ColorBaseDiffuse.rgb = ColorBaseDiffuse.rgb*(1.0 - U_age) + ColorBaseDiffuse.rgb*tex2D(S_diffuse4_map, IO_uv0).rgb*U_age;
		
		ColorBaseDiffuse.rgb		= blendAlpha(ColorBaseDiffuse.rgb, mul(ColorBaseDiffuse.rgb, inCOLORMATRIX_BASE), ColorBaseDiffuse.a);
	}
	CONST half3 diffnorm = ColorBaseDiffuse.rgb;

	//--------------------------------------------------------------------------------------
	// apply the paint layer
	//--------------------------------------------------------------------------------------
	//alpha blend paint layer with diffuse base color
	_IF(S_diffuse_paint_bool)
	{
		half4 ColorPaint		= S_diffuse_paintstr * tex2D(S_diffuse_paint_map, IO_uv0).rgba;
		ColorPaint.rgb 			= mul(ColorPaint.rgb, inCOLORMATRIX_PAINT);	//apply Paint matrix
		// PROBLEM: we have to apply it to both layers since we do seperate lighting, result is a bit oversaturated!
		ColorBaseDiffuse.rgb	= blendAlpha(ColorBaseDiffuse.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
		ColorBaseDiffuseSub.rgb	= blendAlpha(ColorBaseDiffuseSub.rgb, ColorPaint.rgb, ColorPaint.a); // not overlay since we dont want to mix with skin! 
	}
	
	
	INPUT_NTB_TWOSIDED()
	
	float3 Normal = vec3(0);
	//STANDARD_NORMAL_MAP(Normal)


		Normal = IO_normal;			
				
		vec3 texnorm = TEXTURE_NORMAL(normal, IO_uv0);
		vec2 texnorm2 = TEXTURE_NORMAL_XY(normal2, IO_uv0);
		vec2 texnorm3 = TEXTURE_NORMAL_XY(normal3, IO_uv0);

		half3 NormalAge_pp = TEXTURE_NORMAL(normal4, IO_uv0).xyz;


		texnorm.xy = texnorm.xy*E.x + texnorm2*E.y+ texnorm3*E.z+NormalAge_pp.xy*U_age;
		
		texnorm = normalize(texnorm);				
		Normal = CalcWorldNormal(texnorm);			
				
	
	
	
	// Shadow value, Ohoh we just have shadow calced for the main light so we only need to darken the light we have for the first global ? (does this always match?)
	float Shadow = 1.0f;
	_IF(B_shadow)
	{
		Shadow = GetShadow();
		// for now shadows only apply to solid geometry
//		Shadow = saturate(Shadow + (1.0 - F_alphascale)); // TODO: Bug -> last 20% dont work correctly we have a offset 0.1->0.2 somewhere
	}
		
//--------------------------------------------------------------------------------------
//				normals
//--------------------------------------------------------------------------------------	
	//TODO @timon verify inversion
// 	Normal.xyz *= sign(-in_vFace); //why we have to inverse it for max?
	
	vec3 ColorGlow = vec3(0.0f);
/*	half RimLight = fresnel(VertexToEye, Normal, U_fresnel_power/2) * ((1.0 + 2.0f*SmoothnessVal) / 3.0);  // apply occl to mask out hair/ear/sheek fresnel
	//half3 FresnelColor_Lin = TO_linearRGB(U_fresnel_color.rgb) * U_fresnel_strength*0.20;
	half3 FresnelColor_Lin = U_fresnel_color.rgb * U_fresnel_strength*0.05;

	ColorGlow += fresnel(VertexToEye, Normal, U_face_rim_power*2)*ColorBaseDiffuse.rgb*U_face_rim_strength*4.0;
	ColorGlow += (RimLight * FresnelColor_Lin.rrr);
	ColorGlow *= (Shadow + 1.0f) / 2.0f;
	ColorGlow = vec3(0.0f);*/
	
	// DEFERRED_HACK
	// Normal.xyz = mat3(M_view) * Normal.xyz; // view space normal
	// float smoothness = SmoothnessVal;
	// smoothness = 0.55;
	// GENERAL_OUTPUT(Normal.xyz, ColorBaseDiffuse.rgb, vec3(0), MetalnessVal, smoothness);

	//vec3 ColorGlow = vec3(0.0f);
	float GlowStr = 0.0f;
	float cc = 0.0f;
	//SmoothnessVal = 0.6f;
	//MetalnessVal = 0.0f;
	// GENERAL_OUTPUT(Normal.xyz, vec3(0, 0, -1), cc, ColorBaseDiffuse.rgb, ColorGlow, GlowStr, MetalnessVal, SmoothnessVal);
	GENERAL_OUTPUT(Normal, ColorBaseDiffuse.rgb, MetalnessVal, SmoothnessVal, ColorGlow);
	   
	//OUT_Color = ColorBaseDiffuse.rgba;
	//OUT_Color = half4(RimLight,RimLight,RimLight, 1.0f);
}

#include <common.fh>

const int baselvl = 1;

float ambRoughness;

uint ray_axis;
uint ray_other;
float ray_ofact;
float ray_ooff;
float ray_zfact;
float ray_zoff;

// float ray_dfact;	//ray distance for each step

int starti;

float i2lvl(int i)
{
	float sm = saturate(1.0f - ambRoughness);
// 	float dist = ray_dfact * abs(i - starti);
	float dist = abs(i - starti);
// 	float dist = abs(i - starti);
	dist = saturate(dist / (sm * 2000.0f));
// 	dist = pow2(dist);
// 	dist = sqrt(dist);
// 	dist = 0.0f;
	float f = 0;
	f += dist;
	f += 0.2f * ambRoughness;
	f = saturate(f);
	return f * U_size;
}

float getz(int i, int lvl)
{
	ivec2 pix;
	pix[ray_axis] = i;
	pix[ray_other] = int(i * ray_ofact + ray_ooff);
	
	float z = texelFetch(T_maindepth_mips, pix >> lvl, lvl - baselvl).x;
	return z;
}

uint getflags(int i, int lvl)
{
	ivec2 pix;
	pix[ray_axis] = i;
	pix[ray_other] = int(i * ray_ofact + ray_ooff);
	
	uint flags = texelFetch(T_flags, pix >> lvl, lvl).r;
	return flags;
}

vec2 getuv(int i)
{
	vec2 pix;
	pix[ray_axis] = i;
	pix[ray_other] = int(i * ray_ofact + ray_ooff);
	return pix / (V_viewportpixelsize.xy * 2);
}

vec4 TAA_color = vec4(0);
float TAA_mix = 1.0f;
void TAA_OUT(vec3 col, vec2 hit_dist)
{
// 	OUT_Color = col;	return;
// 	OUT_Color = vec4(col, SSR_Encode(hit_dist));	return;
	vec2 ohd = SSR_Decode(TAA_color.a);
	ohd.y = hit_dist.y;//TODO @Timon distance broken by interpolated fetch so ignore
	OUT_Color.rgb = mix(TAA_color.rgb, col.rgb, TAA_mix);
	OUT_Color.a = SSR_Encode(mix(ohd, hit_dist, TAA_mix));
}

void TAA_OUT()
{
	TAA_OUT(vec3(0), vec2(0));
}

void main()
{
	OUT_Color = vec4(0);
// 	OUT_Color.rgb = textureLod(T_maincolor_last, GetFragUV(), 0).rgb;	return;
	
	
	vec2 pix_uv = GetFragUV();
	vec2 pix_ss = uv2clip(pix_uv);
	
	vec2 vpsize = V_viewportpixelsize.xy * 2;	//we're rendering at half-res but we want the full-res to be tha basis
	
	vec3 view_pos;
	RetrieveZBufferViewPos(view_pos, pix_uv);
	if (view_pos.z > BGDIST) {
// 		OUT_Color.r = 1;
		return;
	}
// 	OUT_Color.rgb = view_pos;	OUT_Color.a = 1;	return;
// 	TAA_OUT(vec4(view_pos, 1));	return;
	
	#if 1
	{
		vec4 reproj;
	//	reproj = vec4(uv2clip(pix_uv), gl_FragCoord.z, 1);
		if (IsStationary(GetFlags(pix_uv))) {
			reproj.xy = pix_uv;
			TAA_mix = 0.3;
		}
		else {
			reproj = vec4(Project(view_pos), 1);
			reproj = M_texturematrix0 * reproj;
			reproj /= reproj.w;
			reproj.xy = clip2uv(reproj.xy);
			vec2 dist = abs(reproj.xy - pix_uv);
			TAA_mix = 0.1 + 0.7 * ( smoothstep(0, 8.0 / V_viewportpixelsize.x, dist.x + dist.y));
		}
		if (U_pass != 0) {
			TAA_color = textureLod(S_input_rt, reproj.xy, 0);//TODO @Timon interpolated fetch effectively breaks distance info
			if (any(isnan(TAA_color)) || any(isinf(TAA_color))) {
				TAA_color = vec4(0);
			}
		}
		else {
			TAA_mix = 1;
			TAA_color = vec4(0);
		}
// 		TAA_mix = 0.1;
// 		OUT_Color = vec4(vec3(TAA_mix), 0);		return;
		//TODO @Timon don't TAA for stationary objects
	}
	#endif
	
	float constfade = 1;
	vec3 normal;
	float smoothness;
	RETRIEVE_GBUFFER_UV_NORMAL0_SMOOTH(pix_uv, normal, smoothness);
	
	if (any(isnan(normal))) {
		TAA_OUT();
		return;
	}
	else if (any(isinf(normal))) {
		TAA_OUT();
		return;
	}
	
// 	OUT_Color.rgb = normal;		return;
	
	vec3 ray = reflect(normalize(view_pos), normal);
// 	OUT_Color.rgb = ray;		return;
	if (ray.z < -0.4) {//rays facing camera are unlikely to hit something sensible
// 		OUT_Color.g = 1;
		//TODO @Timon many cases where this is too much:/
// 		return;
	}
	if (ray.z < -0.2) {
		constfade = smoothstep(-0.4, -0.2, ray.z);
	}
	float Roughness = smooth2rough(smoothness);
	
	float v_dot_n = saturate(dot(view_pos, normal));
	// smaller cone at edges to highlight fresnel
	#ifdef JON_MOD_DISABLE_EGOSOFT_SMOOTHER_GRAZING_ANGLE
		ambRoughness = Roughness;
	#else
		ambRoughness = mix(Roughness*0.75, Roughness, pow(v_dot_n, 1.0/3.0));
	#endif
	
// 	if (Roughness >= 0.5) //don't bother for really rough surfaces since it'll have very little impact
// 		return;
	
	{
		vec2 pos;
		{
			switch(int(U_offset + pix_ss.x + pix_ss.y) % 8) {
			case 0:		pos[0] = 0.5000f;	pos[1] = 0.3333f;	break;	//halton
			case 1:		pos[0] = 0.2500f;	pos[1] = 0.6667f;	break;
			case 2:		pos[0] = 0.7500f;	pos[1] = 0.1111f;	break;
			case 3:		pos[0] = 0.1250f;	pos[1] = 0.4444f;	break;
			case 4:		pos[0] = 0.6250f;	pos[1] = 0.7778f;	break;
			case 5:		pos[0] = 0.3750f;	pos[1] = 0.2222f;	break;
			case 6:		pos[0] = 0.8750f;	pos[1] = 0.5555f;	break;
			case 7:		pos[0] = 0.0625f;	pos[1] = 0.8889f;	break;
			}
			pos *= vec2(2);
			pos -= vec2(1);
		}
		float scale = 0.01f + 0.2f * (ambRoughness);
		scale *= 0.05f;
		scale *= saturate(1.0f - TAA_mix);
		view_pos.xy += pos * scale;
	}
	vec3 view0_cs = Project(view_pos);
	vec3 view1_cs = Project(view_pos + ray);
	vec3 view0_uv = vec3(clip2uv(view0_cs.xy), view0_cs.z);
	vec3 view1_uv = vec3(clip2uv(view1_cs.xy), view1_cs.z);
// 	vec3 view0_pix = vec3(view0_uv.xy * vpsize.xy, view0_uv.z);
	vec3 view0_pix = vec3(gl_FragCoord.xy * 2, view0_uv.z);
	vec3 view1_pix = vec3(view1_uv.xy * vpsize.xy, view1_uv.z);
// 	vec3 ray_cs = view1_cs - view0_cs;
// 	vec3 ray_uv = view1_uv - view0_uv;
	vec3 ray_pix = view1_pix - view0_pix;
// 	ray_uv.xy = clip2uv(view1_cs.xy) - clip2uv(view0_cs.xy);
// 	vec3 ray_uv = clip2uv(ray_cs);
// 	ray_pix = normalize(ray_pix);
	
// 	OUT_Color.rg = abs(view0_pix.xy - gl_FragCoord.xy * 2);
// 	OUT_Color.rg *= 1000;
// 	OUT_Color.rgb = ray_cs;
// 	OUT_Color.rgb = ray_pix;
// 	return;
	{
		if (abs(ray_pix.y) >= abs(ray_pix.x)) {
			ray_axis = 1;
			ray_other = 0;
		}
		else {
			ray_axis = 0;
			ray_other = 1;
		}
		
// 		ray_dfact = length(ray) / abs(ray_pix[ray_axis]);
		ray_pix /= vec3(abs(ray_pix[ray_axis]));
// 		OUT_Color.rgb = ray_pix; 	return;
		
		ray_ofact = ray_pix[ray_other] / ray_pix[ray_axis];
		ray_ooff = view0_pix[ray_other] - ray_ofact * view0_pix[ray_axis];
		
		ray_zfact = ray_pix[2] / ray_pix[ray_axis];
		ray_zoff = view0_pix[2] - ray_zfact * view0_pix[ray_axis];
		
// 		ray_dfact = length(ray) / abs(ray_pix[ray_axis]);
		//TODO @Timon ray_dfact is clearly 1, for it to really make sense it'd have to be above the first divide, but arguably it looks better this way since you always get a certain amount of it as a percentage of the screensize (except it's steps, so resolution dependent TODO @Timon at least fix that)
	}
/*	if (abs(ray_pix[ray_axis]) < 0.999) {
		OUT_Color.rb = vec2(1);
		return;
	}/**/
	
	starti = int(view0_pix[ray_axis]);
	int i = starti;
	int dir = int(1.1 * ray_pix[ray_axis]);	//often the ray is just barely below 1
	if (IsComplex(getflags(i, 1))) {
		TAA_OUT();
		return;
	}
/*	{
		OUT_Color.rgba = vec4(0);
// 		OUT_Color[ray_axis] = float(abs(dir)) / 2;
		OUT_Color[ray_axis] = abs(ray_ofact);
		if (OUT_Color[ray_axis] > 1) {
			OUT_Color.b = 1;
		}
		return;
	}/**/
	
	int lvl = baselvl;
	
	uint a = 0;
	uint end = 400;
	
	i += dir << lvl;	//otherwise insta-hit when right cheek is against the wall
	uint abort = 0;
	for (; a < end; ++a) {
		int mask = (1 << lvl) - 1;
		int pi = i;
		i += 1 * (dir << lvl);
		int minlvl = baselvl;
// 		minlvl = 4;
// 		minlvl = max(minlvl, int(i2lvl(i)));
		
		float walk_z_near;
		float walk_z_far;
		vec3 walk_pix = vec3(0.0);
		walk_pix[ray_axis] = i;
		walk_pix[ray_other] = i * ray_ofact + ray_ooff;
		{
			int inext = i;
			int iprev = pi;
			if (dir > 0) {
				inext |= mask;
				iprev &= ~mask;
			}
			else {
				inext &= ~mask;
				iprev |= mask;
			}
			if (dir * ray_zfact <= 0) {
				walk_z_far = inext * ray_zfact + ray_zoff;
				walk_z_near = iprev * ray_zfact + ray_zoff;
			}
			else {
				walk_z_near = inext * ray_zfact + ray_zoff;
				walk_z_far = iprev * ray_zfact + ray_zoff;
			}
		}
		float hit_z = texelFetch(T_maindepth_mips, ivec2(walk_pix.xy) >> (lvl - 0), lvl - baselvl).x;
		if (hit_z - walk_z_far >= 0) {
// 			minlvl = clamp(minlvl, baselvl, 4);
			if (lvl <= minlvl)
			{
				if (hit_z < BGZ) {
					TAA_OUT();
					return;//don't reflect background the envmap will do it better
				}
				uint flags = 0;
				flags = getflags(i, lvl);
				if (!IsComplexDepth(flags)) {
					bool reproject = true;
					if ((flags & FLAG_STATIONARY) != 0) {
						reproject = false;
					}
					float threshold = 0;
					float slope_fact = 0;
					{
						float zn = getz(i + (dir << lvl), lvl);
						float zp = getz(i - 2 * (dir << lvl), lvl);
						
						float sn = zn - hit_z;
						float sp = hit_z - zp;
						
						if (abs(sp - sn) < 0.06 * hit_z)
						{
							threshold = abs(sp);
						}/**/
					}/**/
					if (hit_z - walk_z_near <= threshold)
					{
						{
							vec3 n;
							RetrieveGBufferNormal(n, getuv(i));
							if (dot(ray, n) >= 0) {
								TAA_OUT();
								return;
							}
						}
						vec4 reproj;
						if (reproject) {
							reproj = vec4(uv2clip(walk_pix.xy / (vpsize.xy)), hit_z, 1);
							reproj = M_texturematrix0 * reproj;
							reproj /= reproj.w;
							reproj.xy = clip2uv(reproj.xy);
						}
						else {
							reproj.xy = walk_pix.xy / (vpsize.xy);
						}
						float reslvl = 0;
// 						reslvl = minlvl;
// 						reslvl = i2lvl(i);
// 						reslvl = min(reslvl, 6);
						
						float fade = 1;
						{
							int outi = i + 40 * (dir << lvl);
							vec2 out_pix;
							out_pix[ray_axis] = outi;
							out_pix[ray_other] = outi * ray_ofact + ray_ooff;
							
							vec2 tmp = uv2clip(out_pix.xy / vpsize.xy);
							tmp = abs(tmp);
							tmp = 1 - saturate(tmp);
							
							fade = tmp.x * tmp.y;
							fade = smoothstep(0.0, 0.1, fade);
	// 						OUT_Color.rgb = vec3(fade);			return;
						}
	// 					OUT_Color.rg = reproj.xy;
	// 					OUT_Color.b = TO_linearRGB(slope_fact) * 1000000;
	// 					OUT_Color.b = TO_linearRGB(ray_dfact * abs(i - starti) / 1000.0f);
	// 					OUT_Color.b = TO_linearRGB(reslvl / U_size);
						vec3 outcol;
						outcol = textureLod(T_maincolor_last, reproj.xy, reslvl).rgb;
						outcol = min(outcol, vec3(2.0f));	//limit extremely bright reflections a bit
						
						if (any(isnan(outcol)) || any(isinf(outcol))/**/) {//TODO @Timon remove
							TAA_OUT();
							return;
						}
						TAA_OUT(outcol, vec2(fade, float(abs(i - starti)) / 1000));
						return;
					}
 #if defined(QUALITY_MEDIUM) || defined(QUALITY_HIGH)
					if (++abort > 32)	//this will not break if only a few pixels are blocking (it's mostly to handle the damn rail guards around docks:/)	//TODO @Timon maybe use higher mips as heuristic?
 #endif
					{
						TAA_OUT();
						return;
					}
				}
// 				OUT_Color.g = 1;
// 				return;
			}
			else
			{
				i -= dir << lvl;
				--lvl;
			}
		}
		else {
			if (i <= 0 || i >= vpsize[ray_axis] - 1) {
// 				OUT_Color.b = 1;
				TAA_OUT();
				return;
			}
			if (lvl < 6) {
				++lvl;
			}
		}
	}
	TAA_OUT();
}
